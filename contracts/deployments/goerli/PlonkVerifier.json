{
  "address": "0x8b5eC2ABCBa46AdDe084224F6706c12fB1F6896d",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "domainSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "numInputs",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma0",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "q1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "q2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "q3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "q4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qM12",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qM34",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qO",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qC",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qH1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qH2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qH3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qH4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qEcc",
              "type": "tuple"
            }
          ],
          "internalType": "struct IPlonkVerifier.VerifyingKey[]",
          "name": "verifyingKeys",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256[][]",
          "name": "publicInputs",
          "type": "uint256[][]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire0",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "prodPerm",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split0",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "zeta",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "zetaOmega",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "wireEval0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wireEval1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wireEval2",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wireEval3",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wireEval4",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigmaEval0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigmaEval1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigmaEval2",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigmaEval3",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prodPermZetaOmegaEval",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPlonkVerifier.PlonkProof[]",
          "name": "proofs",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes[]",
          "name": "extraTranscriptInitMsgs",
          "type": "bytes[]"
        }
      ],
      "name": "batchVerify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xff74b288c5da8ae585a7712fb60189e0ee6b45e7806da2706996aa5e36895ccf",
  "receipt": {
    "to": null,
    "from": "0xb19A0B7Cf8BC81492841537b43d49dEdA35DcE4F",
    "contractAddress": "0x8b5eC2ABCBa46AdDe084224F6706c12fB1F6896d",
    "transactionIndex": 17,
    "gasUsed": "3366524",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x82adaca0e9a76957ceaedbde184ddde31bb5583e0afe82cfdfe8ab9257030f1b",
    "transactionHash": "0xff74b288c5da8ae585a7712fb60189e0ee6b45e7806da2706996aa5e36895ccf",
    "logs": [],
    "blockNumber": 7033385,
    "cumulativeGasUsed": "4225752",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "a2a06204e48e5b061a7d8a091eecad05",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"domainSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numInputs\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"q1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"q2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"q3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"q4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qM12\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qM34\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qO\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qC\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qH1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qH2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qH3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qH4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qEcc\",\"type\":\"tuple\"}],\"internalType\":\"struct IPlonkVerifier.VerifyingKey[]\",\"name\":\"verifyingKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"publicInputs\",\"type\":\"uint256[][]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"prodPerm\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"zeta\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"zetaOmega\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"wireEval0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wireEval1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wireEval2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wireEval3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wireEval4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaEval0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaEval1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaEval2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaEval3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prodPermZetaOmegaEval\",\"type\":\"uint256\"}],\"internalType\":\"struct IPlonkVerifier.PlonkProof[]\",\"name\":\"proofs\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"extraTranscriptInitMsgs\",\"type\":\"bytes[]\"}],\"name\":\"batchVerify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"batchVerify((uint256,uint256,(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256))[],uint256[][],((uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)[],bytes[])\":{\"details\":\"Batch verify multiple TurboPlonk proofs.\",\"params\":{\"extraTranscriptInitMsgs\":\"An array of bytes from transcript initialization messages\",\"proofs\":\"An array of Plonk proofs\",\"publicInputs\":\"A two-dimensional array of public inputs.\",\"verifyingKeys\":\"An array of verifier keys\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/verifier/PlonkVerifier.sol\":\"PlonkVerifier\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IPlonkVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n//\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n//\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/BN254.sol\\\";\\n\\ninterface IPlonkVerifier {\\n    // Flatten out TurboPlonk proof\\n    struct PlonkProof {\\n        // the first 5 are 4 inputs and 1 output wire poly commmitments\\n        // i.e., batch_proof.wires_poly_comms_vec.iter()\\n        // wire0 is 32 bytes which is a pointer to BN254.G1Point\\n        BN254.G1Point wire0; // 0x00\\n        BN254.G1Point wire1; // 0x20\\n        BN254.G1Point wire2; // 0x40\\n        BN254.G1Point wire3; // 0x60\\n        BN254.G1Point wire4; // 0x80\\n        // the next one is the  product permutation poly commitment\\n        // i.e., batch_proof.prod_perm_poly_comms_vec.iter()\\n        BN254.G1Point prodPerm; // 0xA0\\n        // the next 5 are split quotient poly commmitments\\n        // i.e., batch_proof.split_quot_poly_comms\\n        BN254.G1Point split0; // 0xC0\\n        BN254.G1Point split1; // 0xE0\\n        BN254.G1Point split2; // 0x100\\n        BN254.G1Point split3; // 0x120\\n        BN254.G1Point split4; // 0x140\\n        // witness poly com for aggregated opening at `zeta`\\n        // i.e., batch_proof.opening_proof\\n        BN254.G1Point zeta; // 0x160\\n        // witness poly com for shifted opening at `zeta * \\\\omega`\\n        // i.e., batch_proof.shifted_opening_proof\\n        BN254.G1Point zetaOmega; // 0x180\\n        // wire poly eval at `zeta`\\n        uint256 wireEval0; // 0x1A0\\n        uint256 wireEval1; // 0x1C0\\n        uint256 wireEval2; // 0x1E0\\n        uint256 wireEval3; // 0x200\\n        uint256 wireEval4; // 0x220\\n        // extended permutation (sigma) poly eval at `zeta`\\n        // last (sigmaEval4) is saved by Maller Optimization\\n        uint256 sigmaEval0; // 0x240\\n        uint256 sigmaEval1; // 0x260\\n        uint256 sigmaEval2; // 0x280\\n        uint256 sigmaEval3; // 0x2A0\\n        // product permutation poly eval at `zeta * \\\\omega`\\n        uint256 prodPermZetaOmegaEval; // 0x2C0\\n    }\\n\\n    // The verifying key for Plonk proofs.\\n    struct VerifyingKey {\\n        uint256 domainSize; // 0x00\\n        uint256 numInputs; // 0x20\\n        // commitment to extended perm (sigma) poly\\n        BN254.G1Point sigma0; // 0x40\\n        BN254.G1Point sigma1; // 0x60\\n        BN254.G1Point sigma2; // 0x80\\n        BN254.G1Point sigma3; // 0xA0\\n        BN254.G1Point sigma4; // 0xC0\\n        // commitment to selector poly\\n        // first 4 are linear combination selector\\n        BN254.G1Point q1; // 0xE0\\n        BN254.G1Point q2; // 0x100\\n        BN254.G1Point q3; // 0x120\\n        BN254.G1Point q4; // 0x140\\n        // multiplication selector for 1st, 2nd wire\\n        BN254.G1Point qM12; // 0x160\\n        // multiplication selector for 3rd, 4th wire\\n        BN254.G1Point qM34; // 0x180\\n        // output selector\\n        BN254.G1Point qO; // 0x1A0\\n        // constant term selector\\n        BN254.G1Point qC; // 0x1C0\\n        // rescue selector qH1 * w_ai^5\\n        BN254.G1Point qH1; // 0x1E0\\n        // rescue selector qH2 * w_bi^5\\n        BN254.G1Point qH2; // 0x200\\n        // rescue selector qH3 * w_ci^5\\n        BN254.G1Point qH3; // 0x220\\n        // rescue selector qH4 * w_di^5\\n        BN254.G1Point qH4; // 0x240\\n        // elliptic curve selector\\n        BN254.G1Point qEcc; // 0x260\\n    }\\n\\n    /// @dev Batch verify multiple TurboPlonk proofs.\\n    /// @param verifyingKeys An array of verifying keys\\n    /// @param publicInputs A two-dimensional array of public inputs.\\n    /// @param proofs An array of Plonk proofs\\n    /// @param extraTranscriptInitMsgs An array of bytes from\\n    /// transcript initialization messages\\n    /// @return _ A boolean that is true for successful verification, false otherwise\\n    function batchVerify(\\n        VerifyingKey[] memory verifyingKeys,\\n        uint256[][] memory publicInputs,\\n        PlonkProof[] memory proofs,\\n        bytes[] memory extraTranscriptInitMsgs\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x05bacaa9c265b454292a0e68d4746c5c8ae1624459c8ba76248abd513100b8d1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/BN254.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n//\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n//\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\n//\\n// Based on:\\n// - Christian Reitwiessner: https://gist.githubusercontent.com/chriseth/f9be9d9391efc5beb9704255a8e2989d/raw/4d0fb90847df1d4e04d507019031888df8372239/snarktest.solidity\\n// - Aztec: https://github.com/AztecProtocol/aztec-2-bug-bounty\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Utils.sol\\\";\\n\\n/// @notice Barreto-Naehrig curve over a 254 bit prime field\\nlibrary BN254 {\\n    // use notation from https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/\\n    //\\n    // Elliptic curve is defined over a prime field GF(p), with embedding degree k.\\n    // Short Weierstrass (SW form) is, for a, b \\\\in GF(p^n) for some natural number n > 0:\\n    //   E: y^2 = x^3 + a * x + b\\n    //\\n    // Pairing is defined over cyclic subgroups G1, G2, both of which are of order r.\\n    // G1 is a subgroup of E(GF(p)), G2 is a subgroup of E(GF(p^k)).\\n    //\\n    // BN family are parameterized curves with well-chosen t,\\n    //   p = 36 * t^4 + 36 * t^3 + 24 * t^2 + 6 * t + 1\\n    //   r = 36 * t^4 + 36 * t^3 + 18 * t^2 + 6 * t + 1\\n    // for some integer t.\\n    // E has the equation:\\n    //   E: y^2 = x^3 + b\\n    // where b is a primitive element of multiplicative group (GF(p))^* of order (p-1).\\n    // A pairing e is defined by taking G1 as a subgroup of E(GF(p)) of order r,\\n    // G2 as a subgroup of E'(GF(p^2)),\\n    // and G_T as a subgroup of a multiplicative group (GF(p^12))^* of order r.\\n    //\\n    // BN254 is defined over a 254-bit prime order p, embedding degree k = 12.\\n    uint256 public constant P_MOD =\\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 public constant R_MOD =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fp2 = x0 * z + x1\\n    struct G2Point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    /// @return the generator of G1\\n    // solhint-disable-next-line func-name-mixedcase\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    /// @return the generator of G2\\n    // solhint-disable-next-line func-name-mixedcase\\n    function P2() internal pure returns (G2Point memory) {\\n        return\\n            G2Point({\\n                x0: 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                x1: 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,\\n                y0: 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                y1: 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n            });\\n    }\\n\\n    /// @dev check if a G1 point is Infinity\\n    /// @notice precompile bn256Add at address(6) takes (0, 0) as Point of Infinity,\\n    /// some crypto libraries (such as arkwork) uses a boolean flag to mark PoI, and\\n    /// just use (0, 1) as affine coordinates (not on curve) to represents PoI.\\n    function isInfinity(G1Point memory point) internal pure returns (bool result) {\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n            result := and(iszero(x), iszero(y))\\n        }\\n    }\\n\\n    /// @return r the negation of p, i.e. p.add(p.negate()) should be zero.\\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\\n        if (isInfinity(p)) {\\n            return p;\\n        }\\n        return G1Point(p.x, P_MOD - (p.y % P_MOD));\\n    }\\n\\n    /// @return res = -fr the negation of scalar field element.\\n    function negate(uint256 fr) internal pure returns (uint256 res) {\\n        return R_MOD - (fr % R_MOD);\\n    }\\n\\n    /// @return r the sum of two points of G1\\n    function add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n        uint256[4] memory input;\\n        input[0] = p1.x;\\n        input[1] = p1.y;\\n        input[2] = p2.x;\\n        input[3] = p2.y;\\n        bool success;\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"Bn254: group addition failed!\\\");\\n    }\\n\\n    /// @return r the product of a point on G1 and a scalar, i.e.\\n    /// p == p.mul(1) and p.add(p) == p.mul(2) for all points p.\\n    function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\\n        uint256[3] memory input;\\n        input[0] = p.x;\\n        input[1] = p.y;\\n        input[2] = s;\\n        bool success;\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"Bn254: scalar mul failed!\\\");\\n    }\\n\\n    /// @dev Multi-scalar Mulitiplication (MSM)\\n    /// @return r = \\\\Prod{B_i^s_i} where {s_i} are `scalars` and {B_i} are `bases`\\n    function multiScalarMul(G1Point[] memory bases, uint256[] memory scalars)\\n        internal\\n        view\\n        returns (G1Point memory r)\\n    {\\n        require(scalars.length == bases.length, \\\"MSM error: length does not match\\\");\\n\\n        r = scalarMul(bases[0], scalars[0]);\\n        for (uint256 i = 1; i < scalars.length; i++) {\\n            r = add(r, scalarMul(bases[i], scalars[i]));\\n        }\\n    }\\n\\n    /// @dev Compute f^-1 for f \\\\in Fr scalar field\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function invert(uint256 fr) internal view returns (uint256 output) {\\n        bool success;\\n        uint256 p = R_MOD;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), fr)\\n            mstore(add(mPtr, 0x80), sub(p, 2))\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            output := mload(0x00)\\n        }\\n        require(success, \\\"Bn254: pow precompile failed!\\\");\\n    }\\n\\n    /**\\n     * validate the following:\\n     *   x != 0\\n     *   y != 0\\n     *   x < p\\n     *   y < p\\n     *   y^2 = x^3 + 3 mod p\\n     */\\n    /// @dev validate G1 point and check if it is on curve\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function validateG1Point(G1Point memory point) internal pure {\\n        bool isWellFormed;\\n        uint256 p = P_MOD;\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n\\n            isWellFormed := and(\\n                and(and(lt(x, p), lt(y, p)), not(or(iszero(x), iszero(y)))),\\n                eq(mulmod(y, y, p), addmod(mulmod(x, mulmod(x, x, p), p), 3, p))\\n            )\\n        }\\n        require(isWellFormed, \\\"Bn254: invalid G1 point\\\");\\n    }\\n\\n    /// @dev Validate scalar field, revert if invalid (namely if fr > r_mod).\\n    /// @notice Writing this inline instead of calling it might save gas.\\n    function validateScalarField(uint256 fr) internal pure {\\n        bool isValid;\\n        assembly {\\n            isValid := lt(fr, R_MOD)\\n        }\\n        require(isValid, \\\"Bn254: invalid scalar field\\\");\\n    }\\n\\n    /// @dev Evaluate the following pairing product:\\n    /// @dev e(a1, a2).e(-b1, b2) == 1\\n    /// @dev caller needs to ensure that a1, a2, b1 and b2 are within proper group\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        uint256 out;\\n        bool success;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, mload(a1))\\n            mstore(add(mPtr, 0x20), mload(add(a1, 0x20)))\\n            mstore(add(mPtr, 0x40), mload(a2))\\n            mstore(add(mPtr, 0x60), mload(add(a2, 0x20)))\\n            mstore(add(mPtr, 0x80), mload(add(a2, 0x40)))\\n            mstore(add(mPtr, 0xa0), mload(add(a2, 0x60)))\\n\\n            mstore(add(mPtr, 0xc0), mload(b1))\\n            mstore(add(mPtr, 0xe0), mload(add(b1, 0x20)))\\n            mstore(add(mPtr, 0x100), mload(b2))\\n            mstore(add(mPtr, 0x120), mload(add(b2, 0x20)))\\n            mstore(add(mPtr, 0x140), mload(add(b2, 0x40)))\\n            mstore(add(mPtr, 0x160), mload(add(b2, 0x60)))\\n            success := staticcall(gas(), 8, mPtr, 0x180, 0x00, 0x20)\\n            out := mload(0x00)\\n        }\\n        require(success, \\\"Bn254: Pairing check failed!\\\");\\n        return (out != 0);\\n    }\\n\\n    function fromLeBytesModOrder(bytes memory leBytes) internal pure returns (uint256 ret) {\\n        for (uint256 i = 0; i < leBytes.length; i++) {\\n            ret = mulmod(ret, 256, R_MOD);\\n            ret = addmod(ret, uint256(uint8(leBytes[leBytes.length - 1 - i])), R_MOD);\\n        }\\n    }\\n\\n    /// @dev Check if y-coordinate of G1 point is negative.\\n    function isYNegative(G1Point memory point) internal pure returns (bool) {\\n        return (point.y << 1) < P_MOD;\\n    }\\n\\n    // @dev Perform a modular exponentiation.\\n    // @return base^exponent (mod modulus)\\n    // This method is ideal for small exponents (~64 bits or less), as it is cheaper than using the pow precompile\\n    // @notice credit: credit: Aztec, Spilsbury Holdings Ltd\\n    function powSmall(\\n        uint256 base,\\n        uint256 exponent,\\n        uint256 modulus\\n    ) internal pure returns (uint256) {\\n        uint256 result = 1;\\n        uint256 input = base;\\n        uint256 count = 1;\\n\\n        assembly {\\n            let endpoint := add(exponent, 0x01)\\n            for {\\n\\n            } lt(count, endpoint) {\\n                count := add(count, count)\\n            } {\\n                if and(exponent, count) {\\n                    result := mulmod(result, input, modulus)\\n                }\\n                input := mulmod(input, input, modulus)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function g1Serialize(G1Point memory point) internal pure returns (bytes memory) {\\n        uint256 mask = 0;\\n\\n        // Set the 254-th bit to 1 for infinity\\n        // https://docs.rs/ark-serialize/0.3.0/src/ark_serialize/flags.rs.html#117\\n        if (isInfinity(point)) {\\n            mask |= 0x4000000000000000000000000000000000000000000000000000000000000000;\\n        }\\n\\n        // Set the 255-th bit to 1 for positive Y\\n        // https://docs.rs/ark-serialize/0.3.0/src/ark_serialize/flags.rs.html#118\\n        if (!isYNegative(point)) {\\n            mask = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n        }\\n\\n        return abi.encodePacked(Utils.reverseEndianness(point.x | mask));\\n    }\\n\\n    function g1Deserialize(bytes32 input) internal view returns (G1Point memory point) {\\n        uint256 mask = 0x4000000000000000000000000000000000000000000000000000000000000000;\\n        uint256 x = Utils.reverseEndianness(uint256(input));\\n        uint256 y;\\n        bool isQuadraticResidue;\\n        bool isYPositive;\\n        if (x & mask != 0) {\\n            // the 254-th bit == 1 for infinity\\n            x = 0;\\n            y = 0;\\n        } else {\\n            // Set the 255-th bit to 1 for positive Y\\n            mask = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n            isYPositive = (x & mask != 0);\\n            // mask off the first two bits of x\\n            mask = 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n            x &= mask;\\n\\n            // solve for y where E: y^2 = x^3 + 3\\n            y = mulmod(x, x, P_MOD);\\n            y = mulmod(y, x, P_MOD);\\n            y = addmod(y, 3, P_MOD);\\n            (isQuadraticResidue, y) = quadraticResidue(y);\\n\\n            require(isQuadraticResidue, \\\"deser fail: not on curve\\\");\\n\\n            if (isYPositive) {\\n                y = P_MOD - y;\\n            }\\n        }\\n\\n        point = G1Point(x, y);\\n    }\\n\\n    function quadraticResidue(uint256 x)\\n        internal\\n        view\\n        returns (bool isQuadraticResidue, uint256 a)\\n    {\\n        bool success;\\n        // e = (p+1)/4\\n        uint256 e = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52;\\n        uint256 p = P_MOD;\\n\\n        // we have p == 3 mod 4 therefore\\n        // a = x^((p+1)/4)\\n        assembly {\\n            // credit: Aztec\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), x)\\n            mstore(add(mPtr, 0x80), e)\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            a := mload(0x00)\\n        }\\n        require(success, \\\"pow precompile call failed!\\\");\\n\\n        // ensure a < p/2\\n        if (a << 1 > p) {\\n            a = p - a;\\n        }\\n\\n        // check if a^2 = x, if not x is not a quadratic residue\\n        e = mulmod(a, a, p);\\n\\n        isQuadraticResidue = (e == x);\\n    }\\n}\\n\",\"keccak256\":\"0x3607d86e6e230526d4cb8f5ae427d9ad04f7f77455f4994ee4f1c6d8d7e829ca\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/PolynomialEval.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n//\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n//\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport {BN254} from \\\"../libraries/BN254.sol\\\";\\n\\nlibrary PolynomialEval {\\n    /// @dev a Radix 2 Evaluation Domain\\n    struct EvalDomain {\\n        uint256 logSize; // log_2(self.size)\\n        uint256 size; // Size of the domain as a field element\\n        uint256 sizeInv; // Inverse of the size in the field\\n        uint256 groupGen; // A generator of the subgroup\\n        uint256 groupGenInv; // Inverse of the generator of the subgroup\\n    }\\n\\n    /// @dev stores vanishing poly, lagrange at 1, and Public input poly\\n    struct EvalData {\\n        uint256 vanishEval;\\n        uint256 lagrangeOne;\\n        uint256 piEval;\\n    }\\n\\n    /// @dev compute the EvalData for a given domain and a challenge zeta\\n    function evalDataGen(\\n        EvalDomain memory self,\\n        uint256 zeta,\\n        uint256[] memory publicInput\\n    ) internal view returns (EvalData memory evalData) {\\n        evalData.vanishEval = evaluateVanishingPoly(self, zeta);\\n        evalData.lagrangeOne = evaluateLagrangeOne(self, zeta, evalData.vanishEval);\\n        evalData.piEval = evaluatePiPoly(self, publicInput, zeta, evalData.vanishEval);\\n    }\\n\\n    /// @dev Create a new Radix2EvalDomain with `domainSize` which should be power of 2.\\n    /// @dev Will revert if domainSize is not among {2^14, 2^15, 2^16, 2^17}\\n    function newEvalDomain(uint256 domainSize) internal pure returns (EvalDomain memory) {\\n        if (domainSize == 16384) {\\n            return\\n                EvalDomain(\\n                    14,\\n                    domainSize,\\n                    0x30638CE1A7661B6337A964756AA75257C6BF4778D89789AB819CE60C19B04001,\\n                    0x2D965651CDD9E4811F4E51B80DDCA8A8B4A93EE17420AAE6ADAA01C2617C6E85,\\n                    0x281C036F06E7E9E911680D42558E6E8CF40976B0677771C0F8EEE934641C8410\\n                );\\n        } else if (domainSize == 32768) {\\n            return\\n                EvalDomain(\\n                    15,\\n                    domainSize,\\n                    0x3063edaa444bddc677fcd515f614555a777997e0a9287d1e62bf6dd004d82001,\\n                    0x2d1ba66f5941dc91017171fa69ec2bd0022a2a2d4115a009a93458fd4e26ecfb,\\n                    0x05d33766e4590b3722701b6f2fa43d0dc3f028424d384e68c92a742fb2dbc0b4\\n                );\\n        } else if (domainSize == 65536) {\\n            return\\n                EvalDomain(\\n                    16,\\n                    domainSize,\\n                    0x30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001,\\n                    0x00eeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b7,\\n                    0x0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4\\n                );\\n        } else if (domainSize == 131072) {\\n            return\\n                EvalDomain(\\n                    17,\\n                    domainSize,\\n                    0x30643640b9f82f90e83b698e5ea6179c7c05542e859533b48b9953a2f5360801,\\n                    0x1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e5,\\n                    0x244cf010c43ca87237d8b00bf9dd50c4c01c7f086bd4e8c920e75251d96f0d22\\n                );\\n        } else {\\n            revert(\\\"Poly: size must in 2^{14~17}\\\");\\n        }\\n    }\\n\\n    // This evaluates the vanishing polynomial for this domain at zeta.\\n    // For multiplicative subgroups, this polynomial is\\n    // `z(X) = X^self.size - 1`.\\n    function evaluateVanishingPoly(EvalDomain memory self, uint256 zeta)\\n        internal\\n        pure\\n        returns (uint256 res)\\n    {\\n        uint256 p = BN254.R_MOD;\\n        uint256 logSize = self.logSize;\\n\\n        assembly {\\n            switch zeta\\n            case 0 {\\n                res := sub(p, 1)\\n            }\\n            default {\\n                res := zeta\\n                for {\\n                    let i := 0\\n                } lt(i, logSize) {\\n                    i := add(i, 1)\\n                } {\\n                    res := mulmod(res, res, p)\\n                }\\n                // since zeta != 0 we know that res is not 0\\n                // so we can safely do a subtraction\\n                res := sub(res, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Evaluate the lagrange polynomial at point `zeta` given the vanishing polynomial evaluation `vanish_eval`.\\n    function evaluateLagrangeOne(\\n        EvalDomain memory self,\\n        uint256 zeta,\\n        uint256 vanishEval\\n    ) internal view returns (uint256 res) {\\n        if (vanishEval == 0) {\\n            return 0;\\n        }\\n\\n        uint256 p = BN254.R_MOD;\\n        uint256 divisor;\\n        uint256 vanishEvalMulSizeInv = self.sizeInv;\\n\\n        // =========================\\n        // lagrange_1_eval = vanish_eval / self.size / (zeta - 1)\\n        // =========================\\n        assembly {\\n            vanishEvalMulSizeInv := mulmod(vanishEval, vanishEvalMulSizeInv, p)\\n\\n            switch zeta\\n            case 0 {\\n                divisor := sub(p, 1)\\n            }\\n            default {\\n                divisor := sub(zeta, 1)\\n            }\\n        }\\n        divisor = BN254.invert(divisor);\\n        assembly {\\n            res := mulmod(vanishEvalMulSizeInv, divisor, p)\\n        }\\n    }\\n\\n    /// @dev Evaluate public input polynomial at point `zeta`.\\n    function evaluatePiPoly(\\n        EvalDomain memory self,\\n        uint256[] memory pi,\\n        uint256 zeta,\\n        uint256 vanishEval\\n    ) internal view returns (uint256 res) {\\n        if (vanishEval == 0) {\\n            return 0;\\n        }\\n\\n        uint256 p = BN254.R_MOD;\\n        uint256 length = pi.length;\\n        uint256 ithLagrange;\\n        uint256 ithDivisor;\\n        uint256 tmp;\\n        uint256 vanishEvalDivN = self.sizeInv;\\n        uint256 divisorProd;\\n        uint256[] memory localDomainElements = domainElements(self, length);\\n        uint256[] memory divisors = new uint256[](length);\\n\\n        assembly {\\n            // vanish_eval_div_n = (zeta^n-1)/n\\n            vanishEvalDivN := mulmod(vanishEvalDivN, vanishEval, p)\\n\\n            // Now we need to compute\\n            //  \\\\sum_{i=0..l} L_{i,H}(zeta) * pub_input[i]\\n            // where\\n            // - L_{i,H}(zeta)\\n            //      = Z_H(zeta) * v_i / (zeta - g^i)\\n            //      = vanish_eval_div_n * g^i / (zeta - g^i)\\n            // - v_i = g^i / n\\n            //\\n            // we want to use batch inversion method where we compute\\n            //\\n            //      divisorProd = 1 / \\\\prod (zeta - g^i)\\n            //\\n            // and then each 1 / (zeta - g^i) can be computed via (length - 1)\\n            // multiplications:\\n            //\\n            //      1 / (zeta - g^i) = divisorProd * \\\\prod_{j!=i} (zeta - g^j)\\n            //\\n            // In total this takes n(n-1) multiplications and 1 inversion,\\n            // instead of doing n inversions.\\n            divisorProd := 1\\n\\n            for {\\n                let i := 0\\n            } lt(i, length) {\\n                i := add(i, 1)\\n            } {\\n                // tmp points to g^i\\n                // first 32 bytes of reference is the length of an array\\n                tmp := mload(add(add(localDomainElements, 0x20), mul(i, 0x20)))\\n                // compute (zeta - g^i)\\n                ithDivisor := addmod(sub(p, tmp), zeta, p)\\n                // accumulate (zeta - g^i) to the divisorProd\\n                divisorProd := mulmod(divisorProd, ithDivisor, p)\\n                // store ithDivisor in the array\\n                mstore(add(add(divisors, 0x20), mul(i, 0x20)), ithDivisor)\\n            }\\n        }\\n\\n        // compute 1 / \\\\prod_{i=0}^length (zeta - g^i)\\n        divisorProd = BN254.invert(divisorProd);\\n\\n        assembly {\\n            for {\\n                let i := 0\\n            } lt(i, length) {\\n                i := add(i, 1)\\n            } {\\n                // tmp points to g^i\\n                // first 32 bytes of reference is the length of an array\\n                tmp := mload(add(add(localDomainElements, 0x20), mul(i, 0x20)))\\n                // vanish_eval_div_n * g^i\\n                ithLagrange := mulmod(vanishEvalDivN, tmp, p)\\n\\n                // now we compute vanish_eval_div_n * g^i / (zeta - g^i) via\\n                // vanish_eval_div_n * g^i * divisorProd * \\\\prod_{j!=i} (zeta - g^j)\\n                ithLagrange := mulmod(ithLagrange, divisorProd, p)\\n                for {\\n                    let j := 0\\n                } lt(j, length) {\\n                    j := add(j, 1)\\n                } {\\n                    if iszero(eq(i, j)) {\\n                        ithDivisor := mload(add(add(divisors, 0x20), mul(j, 0x20)))\\n                        ithLagrange := mulmod(ithLagrange, ithDivisor, p)\\n                    }\\n                }\\n\\n                // multiply by pub_input[i] and update res\\n                // tmp points to public input\\n                tmp := mload(add(add(pi, 0x20), mul(i, 0x20)))\\n                ithLagrange := mulmod(ithLagrange, tmp, p)\\n                res := addmod(res, ithLagrange, p)\\n            }\\n        }\\n    }\\n\\n    /// @dev Generate the domain elements for indexes 0..length\\n    /// which are essentially g^0, g^1, ..., g^{length-1}\\n    function domainElements(EvalDomain memory self, uint256 length)\\n        internal\\n        pure\\n        returns (uint256[] memory elements)\\n    {\\n        uint256 groupGen = self.groupGen;\\n        uint256 tmp = 1;\\n        uint256 p = BN254.R_MOD;\\n        elements = new uint256[](length);\\n        assembly {\\n            if not(iszero(length)) {\\n                let ptr := add(elements, 0x20)\\n                let end := add(ptr, mul(0x20, length))\\n                mstore(ptr, 1)\\n                ptr := add(ptr, 0x20)\\n                // for (; ptr < end; ptr += 32) loop through the memory of `elements`\\n                for {\\n\\n                } lt(ptr, end) {\\n                    ptr := add(ptr, 0x20)\\n                } {\\n                    tmp := mulmod(tmp, groupGen, p)\\n                    mstore(ptr, tmp)\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeb5dc3f8021d6e78aea8a33f55a699871ae93348d1815b4f64dece78b6cef086\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n//\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n//\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Utils {\\n    function reverseEndianness(uint256 input) internal pure returns (uint256 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v =\\n            ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v =\\n            ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v =\\n            ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v =\\n            ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n}\\n\",\"keccak256\":\"0x6171f0308aaf0e5379abfee2ed1aa69b81232ef35f0a5576bf7e16d9ad73ac49\",\"license\":\"GPL-3.0-or-later\"},\"contracts/verifier/PlonkVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n//\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n//\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport {BN254} from \\\"../libraries/BN254.sol\\\";\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport {PolynomialEval as Poly} from \\\"../libraries/PolynomialEval.sol\\\";\\nimport \\\"./Transcript.sol\\\";\\n\\ncontract PlonkVerifier is IPlonkVerifier {\\n    using Transcript for Transcript.TranscriptData;\\n\\n    // _COSET_K0 = 1, has no effect during multiplication, thus avoid declaring it here.\\n    uint256 private constant _COSET_K1 =\\n        0x2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a;\\n    uint256 private constant _COSET_K2 =\\n        0x1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb025;\\n    uint256 private constant _COSET_K3 =\\n        0x2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a;\\n    uint256 private constant _COSET_K4 =\\n        0x2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e881;\\n\\n    // Parsed from Aztec's Ignition CRS,\\n    // `beta_h` \\\\in G2 where \\\\beta is the trapdoor, h is G2 generator `BN254.P2()`\\n    // See parsing code: https://github.com/alxiong/crs\\n    BN254.G2Point private _betaH =\\n        BN254.G2Point({\\n            x0: 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            x1: 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0,\\n            y0: 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            y1: 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\\n        });\\n\\n    /// The number of wire types of the circuit, TurboPlonk has 5.\\n    uint256 private constant _NUM_WIRE_TYPES = 5;\\n\\n    /// @dev polynomial commitment evaluation info.\\n    struct PcsInfo {\\n        // a random combiner that was used to combine evaluations at point\\n        uint256 u; // 0x00\\n        // the point to be evaluated at\\n        uint256 evalPoint; // 0x20\\n        // the shifted point to be evaluated at\\n        uint256 nextEvalPoint; // 0x40\\n        // the polynomial evaluation value\\n        uint256 eval; // 0x60\\n        // scalars of poly comm for MSM\\n        uint256[] commScalars; // 0x80\\n        // bases of poly comm for MSM\\n        BN254.G1Point[] commBases; // 0xa0\\n        // proof of evaluations at point `eval_point`\\n        BN254.G1Point openingProof; // 0xc0\\n        // proof of evaluations at point `next_eval_point`\\n        BN254.G1Point shiftedOpeningProof; // 0xe0\\n    }\\n\\n    /// @dev Plonk IOP verifier challenges.\\n    struct Challenges {\\n        uint256 alpha; // 0x00\\n        uint256 alpha2; // 0x20\\n        uint256 alpha3; // 0x40\\n        uint256 beta; // 0x60\\n        uint256 gamma; // 0x80\\n        uint256 zeta; // 0xA0\\n        uint256 v; // 0xC0\\n        uint256 u; // 0xE0\\n    }\\n\\n    /// @dev Batch verify multiple TurboPlonk proofs.\\n    /// @param verifyingKeys An array of verifier keys\\n    /// @param publicInputs A two-dimensional array of public inputs.\\n    /// @param proofs An array of Plonk proofs\\n    /// @param extraTranscriptInitMsgs An array of bytes from\\n    /// transcript initialization messages\\n    function batchVerify(\\n        VerifyingKey[] memory verifyingKeys,\\n        uint256[][] memory publicInputs,\\n        PlonkProof[] memory proofs,\\n        bytes[] memory extraTranscriptInitMsgs\\n    ) external view returns (bool) {\\n        require(\\n            verifyingKeys.length == proofs.length &&\\n                publicInputs.length == proofs.length &&\\n                extraTranscriptInitMsgs.length == proofs.length,\\n            \\\"Plonk: invalid input param\\\"\\n        );\\n        require(proofs.length > 0, \\\"Plonk: need at least 1 proof\\\");\\n\\n        PcsInfo[] memory pcsInfos = new PcsInfo[](proofs.length);\\n        for (uint256 i = 0; i < proofs.length; i++) {\\n            // validate proofs are proper group/field elements\\n            _validateProof(proofs[i]);\\n            // validate public input are all proper scalar fields\\n            for (uint256 j = 0; j < publicInputs[i].length; j++) {\\n                BN254.validateScalarField(publicInputs[i][j]);\\n            }\\n            // prepare pcs info\\n            pcsInfos[i] = _preparePcsInfo(\\n                verifyingKeys[i],\\n                publicInputs[i],\\n                proofs[i],\\n                extraTranscriptInitMsgs[i]\\n            );\\n        }\\n\\n        return _batchVerifyOpeningProofs(pcsInfos);\\n    }\\n\\n    /// @dev Validate all group points and scalar fields. Revert if\\n    /// any are invalid.\\n    /// @param proof A Plonk proof\\n    function _validateProof(PlonkProof memory proof) internal pure {\\n        BN254.validateG1Point(proof.wire0);\\n        BN254.validateG1Point(proof.wire1);\\n        BN254.validateG1Point(proof.wire2);\\n        BN254.validateG1Point(proof.wire3);\\n        BN254.validateG1Point(proof.wire4);\\n        BN254.validateG1Point(proof.prodPerm);\\n        BN254.validateG1Point(proof.split0);\\n        BN254.validateG1Point(proof.split1);\\n        BN254.validateG1Point(proof.split2);\\n        BN254.validateG1Point(proof.split3);\\n        BN254.validateG1Point(proof.split4);\\n        BN254.validateG1Point(proof.zeta);\\n        BN254.validateScalarField(proof.wireEval0);\\n        BN254.validateScalarField(proof.wireEval1);\\n        BN254.validateScalarField(proof.wireEval2);\\n        BN254.validateScalarField(proof.wireEval3);\\n        BN254.validateScalarField(proof.wireEval4);\\n        BN254.validateScalarField(proof.sigmaEval0);\\n        BN254.validateScalarField(proof.sigmaEval1);\\n        BN254.validateScalarField(proof.sigmaEval2);\\n        BN254.validateScalarField(proof.sigmaEval3);\\n        BN254.validateScalarField(proof.prodPermZetaOmegaEval);\\n    }\\n\\n    function _preparePcsInfo(\\n        VerifyingKey memory verifyingKey,\\n        uint256[] memory publicInput,\\n        PlonkProof memory proof,\\n        bytes memory extraTranscriptInitMsg\\n    ) internal view returns (PcsInfo memory res) {\\n        require(publicInput.length == verifyingKey.numInputs, \\\"Plonk: wrong verifying key\\\");\\n\\n        Challenges memory chal = _computeChallenges(\\n            verifyingKey,\\n            publicInput,\\n            proof,\\n            extraTranscriptInitMsg\\n        );\\n\\n        Poly.EvalDomain memory domain = Poly.newEvalDomain(verifyingKey.domainSize);\\n        // pre-compute evaluation data\\n        Poly.EvalData memory evalData = Poly.evalDataGen(domain, chal.zeta, publicInput);\\n\\n        // compute opening proof in poly comm.\\n        uint256[] memory commScalars = new uint256[](30);\\n        BN254.G1Point[] memory commBases = new BN254.G1Point[](30);\\n\\n        uint256 eval = _prepareOpeningProof(\\n            verifyingKey,\\n            evalData,\\n            proof,\\n            chal,\\n            commScalars,\\n            commBases\\n        );\\n\\n        uint256 zeta = chal.zeta;\\n        uint256 omega = domain.groupGen;\\n        uint256 p = BN254.R_MOD;\\n        uint256 zetaOmega;\\n        assembly {\\n            zetaOmega := mulmod(zeta, omega, p)\\n        }\\n\\n        res = PcsInfo(\\n            chal.u,\\n            zeta,\\n            zetaOmega,\\n            eval,\\n            commScalars,\\n            commBases,\\n            proof.zeta,\\n            proof.zetaOmega\\n        );\\n    }\\n\\n    function _computeChallenges(\\n        VerifyingKey memory verifyingKey,\\n        uint256[] memory publicInput,\\n        PlonkProof memory proof,\\n        bytes memory extraTranscriptInitMsg\\n    ) internal pure returns (Challenges memory res) {\\n        Transcript.TranscriptData memory transcript;\\n        uint256 p = BN254.R_MOD;\\n\\n        transcript.appendMessage(extraTranscriptInitMsg);\\n        transcript.appendVkAndPubInput(verifyingKey, publicInput);\\n        transcript.appendGroupElement(proof.wire0);\\n        transcript.appendGroupElement(proof.wire1);\\n        transcript.appendGroupElement(proof.wire2);\\n        transcript.appendGroupElement(proof.wire3);\\n        transcript.appendGroupElement(proof.wire4);\\n\\n        // have to compute tau, but not really used anywhere\\n        // slither-disable-next-line unused-return\\n        transcript.getAndAppendChallenge();\\n        res.beta = transcript.getAndAppendChallenge();\\n        res.gamma = transcript.getAndAppendChallenge();\\n\\n        transcript.appendGroupElement(proof.prodPerm);\\n\\n        res.alpha = transcript.getAndAppendChallenge();\\n\\n        transcript.appendGroupElement(proof.split0);\\n        transcript.appendGroupElement(proof.split1);\\n        transcript.appendGroupElement(proof.split2);\\n        transcript.appendGroupElement(proof.split3);\\n        transcript.appendGroupElement(proof.split4);\\n\\n        res.zeta = transcript.getAndAppendChallenge();\\n\\n        transcript.appendProofEvaluations(proof);\\n        res.v = transcript.getAndAppendChallenge();\\n\\n        transcript.appendGroupElement(proof.zeta);\\n        transcript.appendGroupElement(proof.zetaOmega);\\n        res.u = transcript.getAndAppendChallenge();\\n\\n        assembly {\\n            let alpha := mload(res)\\n            let alpha2 := mulmod(alpha, alpha, p)\\n            let alpha3 := mulmod(alpha2, alpha, p)\\n            mstore(add(res, 0x20), alpha2)\\n            mstore(add(res, 0x40), alpha3)\\n        }\\n    }\\n\\n    /// @dev Compute the constant term of the linearization polynomial.\\n    /// ```\\n    /// r_plonk = PI - L1(x) * alpha^2 - alpha * \\\\prod_i=1..m-1 (w_i + beta * sigma_i + gamma) * (w_m + gamma) * z(xw)\\n    /// ```\\n    /// where m is the number of wire types.\\n    function _computeLinPolyConstantTerm(\\n        Challenges memory chal,\\n        PlonkProof memory proof,\\n        Poly.EvalData memory evalData\\n    ) internal pure returns (uint256 res) {\\n        uint256 p = BN254.R_MOD;\\n        uint256 lagrangeOneEval = evalData.lagrangeOne;\\n        uint256 piEval = evalData.piEval;\\n        uint256 perm = 1;\\n\\n        assembly {\\n            let beta := mload(add(chal, 0x60))\\n            let gamma := mload(add(chal, 0x80))\\n\\n            // \\\\prod_i=1..m-1 (w_i + beta * sigma_i + gamma)\\n            {\\n                let w0 := mload(add(proof, 0x1a0))\\n                let sigma0 := mload(add(proof, 0x240))\\n                perm := mulmod(perm, addmod(add(w0, gamma), mulmod(beta, sigma0, p), p), p)\\n            }\\n            {\\n                let w1 := mload(add(proof, 0x1c0))\\n                let sigma1 := mload(add(proof, 0x260))\\n                perm := mulmod(perm, addmod(add(w1, gamma), mulmod(beta, sigma1, p), p), p)\\n            }\\n            {\\n                let w2 := mload(add(proof, 0x1e0))\\n                let sigma2 := mload(add(proof, 0x280))\\n                perm := mulmod(perm, addmod(add(w2, gamma), mulmod(beta, sigma2, p), p), p)\\n            }\\n            {\\n                let w3 := mload(add(proof, 0x200))\\n                let sigma3 := mload(add(proof, 0x2a0))\\n                perm := mulmod(perm, addmod(add(w3, gamma), mulmod(beta, sigma3, p), p), p)\\n            }\\n\\n            // \\\\prod_i=1..m-1 (w_i + beta * sigma_i + gamma) * (w_m + gamma) * z(xw)\\n            {\\n                let w4 := mload(add(proof, 0x220))\\n                let permNextEval := mload(add(proof, 0x2c0))\\n                perm := mulmod(perm, mulmod(addmod(w4, gamma, p), permNextEval, p), p)\\n            }\\n\\n            let alpha := mload(chal)\\n            let alpha2 := mload(add(chal, 0x20))\\n            // PI - L1(x) * alpha^2 - alpha * \\\\prod_i=1..m-1 (w_i + beta * sigma_i + gamma) * (w_m + gamma) * z(xw)\\n            res := addmod(piEval, sub(p, mulmod(alpha2, lagrangeOneEval, p)), p)\\n            res := addmod(res, sub(p, mulmod(alpha, perm, p)), p)\\n        }\\n    }\\n\\n    /// @dev Compute components in [E]1 and [F]1 used for PolyComm opening verification\\n    /// equivalent of JF's https://github.com/EspressoSystems/jellyfish/blob/main/plonk/src/proof_system/verifier.rs#L154-L170\\n    /// caller allocates the memory fr commScalars and commBases\\n    /// requires Arrays of size 30.\\n    /// @param verifyingKey A verifier key\\n    /// @param evalData A polynomial evaluation\\n    /// @param proof A Plonk proof\\n    /// @param chal A set of challenges\\n    /// @param commScalars Common scalars\\n    /// @param commBases Common bases\\n    // The returned commitment is a generalization of\\n    // `[F]1` described in Sec 8.4, step 10 of https://eprint.iacr.org/2019/953.pdf\\n    // Returned evaluation is the scalar in `[E]1` described in Sec 8.4, step 11 of https://eprint.iacr.org/2019/953.pdf\\n    function _prepareOpeningProof(\\n        VerifyingKey memory verifyingKey,\\n        Poly.EvalData memory evalData,\\n        PlonkProof memory proof,\\n        Challenges memory chal,\\n        uint256[] memory commScalars,\\n        BN254.G1Point[] memory commBases\\n    ) internal pure returns (uint256 eval) {\\n        // compute the constant term of the linearization polynomial\\n        uint256 linPolyConstant = _computeLinPolyConstantTerm(chal, proof, evalData);\\n\\n        _preparePolyCommitments(verifyingKey, chal, evalData, proof, commScalars, commBases);\\n\\n        eval = _prepareEvaluations(linPolyConstant, proof, commScalars);\\n    }\\n\\n    /// @dev Similar to `aggregate_poly_commitments()` in Jellyfish, but we are not aggregating multiple,\\n    /// but rather preparing for `[F]1` from a single proof.\\n    /// The caller allocates the memory fr commScalars and commBases.\\n    /// Requires Arrays of size 30.\\n    function _preparePolyCommitments(\\n        VerifyingKey memory verifyingKey,\\n        Challenges memory chal,\\n        Poly.EvalData memory evalData,\\n        PlonkProof memory proof,\\n        uint256[] memory commScalars,\\n        BN254.G1Point[] memory commBases\\n    ) internal pure {\\n        _linearizationScalarsAndBases(verifyingKey, chal, evalData, proof, commBases, commScalars);\\n\\n        uint256 p = BN254.R_MOD;\\n        uint256 v = chal.v;\\n        uint256 vBase = v;\\n\\n        // Add wire witness polynomial commitments.\\n        commScalars[20] = vBase;\\n        commBases[20] = proof.wire0;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[21] = vBase;\\n        commBases[21] = proof.wire1;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[22] = vBase;\\n        commBases[22] = proof.wire2;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[23] = vBase;\\n        commBases[23] = proof.wire3;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[24] = vBase;\\n        commBases[24] = proof.wire4;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        // Add wire sigma polynomial commitments. The last sigma commitment is excluded.\\n        commScalars[25] = vBase;\\n        commBases[25] = verifyingKey.sigma0;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[26] = vBase;\\n        commBases[26] = verifyingKey.sigma1;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[27] = vBase;\\n        commBases[27] = verifyingKey.sigma2;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[28] = vBase;\\n        commBases[28] = verifyingKey.sigma3;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        // Add poly commitments to be evaluated at point `zeta * g`.\\n        commScalars[29] = chal.u;\\n        commBases[29] = proof.prodPerm;\\n    }\\n\\n    /// @dev `aggregate_evaluations()` in Jellyfish, but since we are not aggregating multiple, but rather preparing `[E]1` from a single proof.\\n    /// @dev caller allocates the memory fr commScalars\\n    /// requires Arrays of size 30.\\n    /// @param linPolyConstant A linear polynomial constant\\n    /// @param proof A Plonk proof\\n    /// @param commScalars An array of common scalars\\n    /// The returned value is the scalar in `[E]1` described in Sec 8.4, step 11 of https://eprint.iacr.org/2019/953.pdf\\n    function _prepareEvaluations(\\n        uint256 linPolyConstant,\\n        PlonkProof memory proof,\\n        uint256[] memory commScalars\\n    ) internal pure returns (uint256 eval) {\\n        uint256 p = BN254.R_MOD;\\n        assembly {\\n            eval := sub(p, linPolyConstant)\\n            for {\\n                let i := 0\\n            } lt(i, 10) {\\n                i := add(i, 1)\\n            } {\\n                // the first u256 stores the length of this array;\\n                // the next 20 elements are used to store the linearization of the scalars\\n                // the first free space starts from 21\\n                let combiner := mload(add(commScalars, mul(add(i, 21), 0x20)))\\n                let termEval := mload(add(proof, add(0x1a0, mul(i, 0x20))))\\n                eval := addmod(eval, mulmod(combiner, termEval, p), p)\\n            }\\n        }\\n    }\\n\\n    /// @dev Batchly verify multiple PCS opening proofs.\\n    /// `open_key` has been assembled from BN254.P1(), BN254.P2() and contract variable _betaH\\n    /// @param pcsInfos An array of PcsInfo\\n    /// @dev Returns true if the entire batch verifiies and false otherwise.\\n    function _batchVerifyOpeningProofs(PcsInfo[] memory pcsInfos) internal view returns (bool) {\\n        uint256 pcsLen = pcsInfos.length;\\n        uint256 p = BN254.R_MOD;\\n        // Compute a pseudorandom challenge from the instances\\n        uint256 r = 1; // for a single proof, no need to use `r` (`r=1` has no effect)\\n        if (pcsLen > 1) {\\n            Transcript.TranscriptData memory transcript;\\n            for (uint256 i = 0; i < pcsLen; i++) {\\n                transcript.appendChallenge(pcsInfos[i].u);\\n            }\\n            r = transcript.getAndAppendChallenge();\\n        }\\n\\n        BN254.G1Point memory a1;\\n        BN254.G1Point memory b1;\\n\\n        // Compute A := A0 + r * A1 + ... + r^{m-1} * Am\\n        {\\n            uint256[] memory scalars = new uint256[](2 * pcsLen);\\n            BN254.G1Point[] memory bases = new BN254.G1Point[](2 * pcsLen);\\n            uint256 rBase = 1;\\n            for (uint256 i = 0; i < pcsLen; i++) {\\n                scalars[2 * i] = rBase;\\n                bases[2 * i] = pcsInfos[i].openingProof;\\n\\n                {\\n                    // slither-disable-next-line write-after-write\\n                    uint256 tmp;\\n                    uint256 u = pcsInfos[i].u;\\n                    assembly {\\n                        tmp := mulmod(rBase, u, p)\\n                    }\\n                    scalars[2 * i + 1] = tmp;\\n                }\\n                bases[2 * i + 1] = pcsInfos[i].shiftedOpeningProof;\\n\\n                assembly {\\n                    rBase := mulmod(rBase, r, p)\\n                }\\n            }\\n            a1 = BN254.multiScalarMul(bases, scalars);\\n        }\\n\\n        // Compute B := B0 + r * B1 + ... + r^{m-1} * Bm\\n        {\\n            uint256[] memory scalars;\\n            BN254.G1Point[] memory bases;\\n            {\\n                // variable scoping to avoid \\\"Stack too deep\\\"\\n                uint256 scalarsLenPerInfo = pcsInfos[0].commScalars.length;\\n                uint256 totalScalarsLen = (2 + scalarsLenPerInfo) * pcsInfos.length + 1;\\n                scalars = new uint256[](totalScalarsLen);\\n                bases = new BN254.G1Point[](totalScalarsLen);\\n            }\\n            uint256 sumEvals = 0;\\n            uint256 idx = 0;\\n            uint256 rBase = 1;\\n            for (uint256 i = 0; i < pcsInfos.length; i++) {\\n                for (uint256 j = 0; j < pcsInfos[0].commScalars.length; j++) {\\n                    {\\n                        // scalars[idx] = (rBase * pcsInfos[i].commScalars[j]) % BN254.R_MOD;\\n                        uint256 s = pcsInfos[i].commScalars[j];\\n                        uint256 tmp;\\n                        assembly {\\n                            // slither-disable-next-line variable-scope\\n                            tmp := mulmod(rBase, s, p)\\n                        }\\n                        scalars[idx] = tmp;\\n                    }\\n                    bases[idx] = pcsInfos[i].commBases[j];\\n                    idx += 1;\\n                }\\n\\n                {\\n                    // scalars[idx] = (rBase * pcsInfos[i].evalPoint) % BN254.R_MOD;\\n                    uint256 evalPoint = pcsInfos[i].evalPoint;\\n                    uint256 tmp;\\n                    assembly {\\n                        // slither-disable-next-line variable-scope\\n                        tmp := mulmod(rBase, evalPoint, p)\\n                    }\\n                    scalars[idx] = tmp;\\n                }\\n                bases[idx] = pcsInfos[i].openingProof;\\n                idx += 1;\\n\\n                {\\n                    // scalars[idx] = (rBase * pcsInfos[i].u * pcsInfos[i].nextEvalPoint) % BN254.R_MOD;\\n                    uint256 u = pcsInfos[i].u;\\n                    uint256 nextEvalPoint = pcsInfos[i].nextEvalPoint;\\n                    uint256 tmp;\\n                    assembly {\\n                        // slither-disable-next-line variable-scope\\n                        tmp := mulmod(rBase, mulmod(u, nextEvalPoint, p), p)\\n                    }\\n                    scalars[idx] = tmp;\\n                }\\n                bases[idx] = pcsInfos[i].shiftedOpeningProof;\\n                idx += 1;\\n\\n                {\\n                    // sumEvals = (sumEvals + rBase * pcsInfos[i].eval) % BN254.R_MOD;\\n                    // rBase = (rBase * r) % BN254.R_MOD;\\n                    uint256 eval = pcsInfos[i].eval;\\n                    assembly {\\n                        sumEvals := addmod(sumEvals, mulmod(rBase, eval, p), p)\\n                        rBase := mulmod(rBase, r, p)\\n                    }\\n                }\\n            }\\n            scalars[idx] = BN254.negate(sumEvals);\\n            bases[idx] = BN254.P1();\\n            b1 = BN254.negate(BN254.multiScalarMul(bases, scalars));\\n        }\\n\\n        // Check e(A, [x]2) ?= e(B, [1]2)\\n        return BN254.pairingProd2(a1, _betaH, b1, BN254.P2());\\n    }\\n\\n    /// @dev Compute the linearization of the scalars and bases.\\n    /// The caller allocates the memory from commScalars and commBases.\\n    /// Requires arrays of size 30.\\n    /// @param verifyingKey The verifying key\\n    /// @param challenge A set of challenges\\n    /// @param evalData Polynomial evaluation data\\n    /// @param proof A Plonk proof\\n    /// @param bases An array of BN254 G1 points\\n    /// @param scalars An array of scalars\\n    function _linearizationScalarsAndBases(\\n        VerifyingKey memory verifyingKey,\\n        Challenges memory challenge,\\n        Poly.EvalData memory evalData,\\n        PlonkProof memory proof,\\n        BN254.G1Point[] memory bases,\\n        uint256[] memory scalars\\n    ) internal pure {\\n        uint256 firstScalar;\\n        uint256 secondScalar;\\n        uint256 rhs;\\n        uint256 tmp;\\n        uint256 tmp2;\\n        uint256 p = BN254.R_MOD;\\n\\n        // ============================================\\n        // Compute coefficient for the permutation product polynomial commitment.\\n        // firstScalar =\\n        //          L1(zeta) * alpha^2\\n        //          + alpha\\n        //              * (beta * zeta      + wireEval0 + gamma)\\n        //              * (beta * k1 * zeta + wireEval1 + gamma)\\n        //              * (beta * k2 * zeta + wireEval2 + gamma)\\n        //              * ...\\n        // where wireEval0, wireEval1, wireEval2, ... are in w_evals\\n        // ============================================\\n        // first base and scala:\\n        // - proof.prodPerm\\n        // - firstScalar\\n        assembly {\\n            // firstScalar = alpha^2 * L1(zeta)\\n            firstScalar := mulmod(mload(add(challenge, 0x20)), mload(add(evalData, 0x20)), p)\\n\\n            // rhs = alpha\\n            rhs := mload(challenge)\\n\\n            // tmp = beta * zeta\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(challenge, 0xA0)), p)\\n\\n            // =================================\\n            // k0 (which is 1) component\\n            // (beta * zeta + wireEval0 + gamma)\\n            // =================================\\n            tmp2 := addmod(tmp, mload(add(proof, 0x1A0)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            // =================================\\n            // k1 component\\n            // (beta * zeta * k1 + wireEval1 + gamma)\\n            // =================================\\n            tmp2 := mulmod(tmp, _COSET_K1, p)\\n            tmp2 := addmod(tmp2, mload(add(proof, 0x1C0)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            // =================================\\n            // k2 component\\n            // (beta * zeta * k2 + wireEval2 + gamma)\\n            // =================================\\n            tmp2 := mulmod(tmp, _COSET_K2, p)\\n            tmp2 := addmod(tmp2, mload(add(proof, 0x1E0)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            // =================================\\n            // k3 component\\n            // (beta * zeta * k3 + wireEval3 + gamma)\\n            // =================================\\n            tmp2 := mulmod(tmp, _COSET_K3, p)\\n            tmp2 := addmod(tmp2, mload(add(proof, 0x200)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            // =================================\\n            // k4 component\\n            // (beta * zeta * k4 + wireEval4 + gamma)\\n            // =================================\\n            tmp2 := mulmod(tmp, _COSET_K4, p)\\n            tmp2 := addmod(tmp2, mload(add(proof, 0x220)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            firstScalar := addmod(firstScalar, rhs, p)\\n        }\\n        bases[0] = proof.prodPerm;\\n        scalars[0] = firstScalar;\\n\\n        // ============================================\\n        // Compute coefficient for the last wire sigma polynomial commitment.\\n        // secondScalar = alpha * beta * z_w * [s_sigma_3]_1\\n        //              * (wireEval0 + gamma + beta * sigmaEval0)\\n        //              * (wireEval1 + gamma + beta * sigmaEval1)\\n        //              * ...\\n        // ============================================\\n        // second base and scala:\\n        // - verifyingKey.sigma4\\n        // - secondScalar\\n        assembly {\\n            // secondScalar = alpha * beta * z_w\\n            secondScalar := mulmod(mload(challenge), mload(add(challenge, 0x60)), p)\\n            secondScalar := mulmod(secondScalar, mload(add(proof, 0x2C0)), p)\\n\\n            // (wireEval0 + gamma + beta * sigmaEval0)\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(proof, 0x240)), p)\\n            tmp := addmod(tmp, mload(add(proof, 0x1A0)), p)\\n            tmp := addmod(tmp, mload(add(challenge, 0x80)), p)\\n\\n            secondScalar := mulmod(secondScalar, tmp, p)\\n\\n            // (wireEval1 + gamma + beta * sigmaEval1)\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(proof, 0x260)), p)\\n            tmp := addmod(tmp, mload(add(proof, 0x1C0)), p)\\n            tmp := addmod(tmp, mload(add(challenge, 0x80)), p)\\n\\n            secondScalar := mulmod(secondScalar, tmp, p)\\n\\n            // (wireEval2 + gamma + beta * sigmaEval2)\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(proof, 0x280)), p)\\n            tmp := addmod(tmp, mload(add(proof, 0x1E0)), p)\\n            tmp := addmod(tmp, mload(add(challenge, 0x80)), p)\\n\\n            secondScalar := mulmod(secondScalar, tmp, p)\\n\\n            // (wireEval3 + gamma + beta * sigmaEval3)\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(proof, 0x2A0)), p)\\n            tmp := addmod(tmp, mload(add(proof, 0x200)), p)\\n            tmp := addmod(tmp, mload(add(challenge, 0x80)), p)\\n\\n            secondScalar := mulmod(secondScalar, tmp, p)\\n        }\\n        bases[1] = verifyingKey.sigma4;\\n        scalars[1] = p - secondScalar;\\n\\n        // ============================================\\n        // next 13 are for selectors:\\n        //\\n        // the selectors are organized as\\n        // - q_lc\\n        // - q_mul\\n        // - q_hash\\n        // - q_o\\n        // - q_c\\n        // - q_ecc\\n        // ============================================\\n\\n        // ============\\n        // q_lc\\n        // ============\\n        // q_1...q_4\\n        scalars[2] = proof.wireEval0;\\n        scalars[3] = proof.wireEval1;\\n        scalars[4] = proof.wireEval2;\\n        scalars[5] = proof.wireEval3;\\n        bases[2] = verifyingKey.q1;\\n        bases[3] = verifyingKey.q2;\\n        bases[4] = verifyingKey.q3;\\n        bases[5] = verifyingKey.q4;\\n\\n        // ============\\n        // q_M\\n        // ============\\n        // q_M12 and q_M34\\n        // q_M12 = w_evals[0] * w_evals[1];\\n        assembly {\\n            tmp := mulmod(mload(add(proof, 0x1A0)), mload(add(proof, 0x1C0)), p)\\n        }\\n        scalars[6] = tmp;\\n        bases[6] = verifyingKey.qM12;\\n\\n        assembly {\\n            tmp := mulmod(mload(add(proof, 0x1E0)), mload(add(proof, 0x200)), p)\\n        }\\n        scalars[7] = tmp;\\n        bases[7] = verifyingKey.qM34;\\n\\n        // ============\\n        // q_H\\n        // ============\\n        // w_evals[0].pow([5]);\\n        assembly {\\n            tmp := mload(add(proof, 0x1A0))\\n            tmp2 := mulmod(tmp, tmp, p)\\n            tmp2 := mulmod(tmp2, tmp2, p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n        scalars[8] = tmp;\\n        bases[8] = verifyingKey.qH1;\\n\\n        // w_evals[1].pow([5]);\\n        assembly {\\n            tmp := mload(add(proof, 0x1C0))\\n            tmp2 := mulmod(tmp, tmp, p)\\n            tmp2 := mulmod(tmp2, tmp2, p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n        scalars[9] = tmp;\\n        bases[9] = verifyingKey.qH2;\\n\\n        // w_evals[2].pow([5]);\\n        assembly {\\n            tmp := mload(add(proof, 0x1E0))\\n            tmp2 := mulmod(tmp, tmp, p)\\n            tmp2 := mulmod(tmp2, tmp2, p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n        scalars[10] = tmp;\\n        bases[10] = verifyingKey.qH3;\\n\\n        // w_evals[3].pow([5]);\\n        assembly {\\n            tmp := mload(add(proof, 0x200))\\n            tmp2 := mulmod(tmp, tmp, p)\\n            tmp2 := mulmod(tmp2, tmp2, p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n        scalars[11] = tmp;\\n        bases[11] = verifyingKey.qH4;\\n\\n        // ============\\n        // q_o and q_c\\n        // ============\\n        // q_o\\n        scalars[12] = p - proof.wireEval4;\\n        bases[12] = verifyingKey.qO;\\n        // q_c\\n        scalars[13] = 1;\\n        bases[13] = verifyingKey.qC;\\n\\n        // ============\\n        // q_Ecc\\n        // ============\\n        // q_Ecc = w_evals[0] * w_evals[1] * w_evals[2] * w_evals[3] * w_evals[4];\\n        assembly {\\n            tmp := mulmod(mload(add(proof, 0x1A0)), mload(add(proof, 0x1C0)), p)\\n            tmp := mulmod(tmp, mload(add(proof, 0x1E0)), p)\\n            tmp := mulmod(tmp, mload(add(proof, 0x200)), p)\\n            tmp := mulmod(tmp, mload(add(proof, 0x220)), p)\\n        }\\n        scalars[14] = tmp;\\n        bases[14] = verifyingKey.qEcc;\\n\\n        // ============================================\\n        // the last 5 are for splitting quotient commitments\\n        // ============================================\\n\\n        // first one is 1-zeta^n\\n        scalars[15] = p - evalData.vanishEval;\\n        bases[15] = proof.split0;\\n        assembly {\\n            // tmp = zeta^{n+2}\\n            tmp := addmod(mload(evalData), 1, p)\\n            // todo: use pre-computed zeta^2\\n            tmp2 := mulmod(mload(add(challenge, 0xA0)), mload(add(challenge, 0xA0)), p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n\\n        // second one is (1-zeta^n) zeta^(n+2)\\n        assembly {\\n            tmp2 := mulmod(mload(add(scalars, mul(16, 0x20))), tmp, p)\\n        }\\n        scalars[16] = tmp2;\\n        bases[16] = proof.split1;\\n\\n        // third one is (1-zeta^n) zeta^2(n+2)\\n        assembly {\\n            tmp2 := mulmod(mload(add(scalars, mul(17, 0x20))), tmp, p)\\n        }\\n        scalars[17] = tmp2;\\n        bases[17] = proof.split2;\\n\\n        // forth one is (1-zeta^n) zeta^3(n+2)\\n        assembly {\\n            tmp2 := mulmod(mload(add(scalars, mul(18, 0x20))), tmp, p)\\n        }\\n        scalars[18] = tmp2;\\n        bases[18] = proof.split3;\\n\\n        // fifth one is (1-zeta^n) zeta^4(n+2)\\n        assembly {\\n            tmp2 := mulmod(mload(add(scalars, mul(19, 0x20))), tmp, p)\\n        }\\n        scalars[19] = tmp2;\\n        bases[19] = proof.split4;\\n    }\\n}\\n\",\"keccak256\":\"0x4ac51cc4f8d9489789812618cb7d7ec391eb114ef942d062a786cf6bf2e2cbc7\",\"license\":\"GPL-3.0-or-later\"},\"contracts/verifier/Transcript.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n//\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n//\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// There is currently a bug in solidity that may affect the security of the contract.\\n// An patch is available for Jellyfish https://github.com/EspressoSystems/jellyfish/pull/70\\n// Corresponding changes are to be made to the solidity code here.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"../libraries/Utils.sol\\\";\\nimport {BN254} from \\\"../libraries/BN254.sol\\\";\\nimport {IPlonkVerifier} from \\\"../interfaces/IPlonkVerifier.sol\\\";\\n\\nlibrary Transcript {\\n    struct TranscriptData {\\n        bytes transcript;\\n        bytes32[2] state;\\n    }\\n\\n    // ================================\\n    // Primitive functions\\n    // ================================\\n    function appendMessage(TranscriptData memory self, bytes memory message) internal pure {\\n        self.transcript = abi.encodePacked(self.transcript, message);\\n    }\\n\\n    function appendFieldElement(TranscriptData memory self, uint256 fieldElement) internal pure {\\n        appendMessage(self, abi.encodePacked(Utils.reverseEndianness(fieldElement)));\\n    }\\n\\n    function appendGroupElement(TranscriptData memory self, BN254.G1Point memory comm)\\n        internal\\n        pure\\n    {\\n        bytes memory commBytes = BN254.g1Serialize(comm);\\n        appendMessage(self, commBytes);\\n    }\\n\\n    // ================================\\n    // Transcript APIs\\n    // ================================\\n    function appendChallenge(TranscriptData memory self, uint256 challenge) internal pure {\\n        appendFieldElement(self, challenge);\\n    }\\n\\n    function appendCommitments(TranscriptData memory self, BN254.G1Point[] memory comms)\\n        internal\\n        pure\\n    {\\n        for (uint256 i = 0; i < comms.length; i++) {\\n            appendCommitment(self, comms[i]);\\n        }\\n    }\\n\\n    function appendCommitment(TranscriptData memory self, BN254.G1Point memory comm)\\n        internal\\n        pure\\n    {\\n        appendGroupElement(self, comm);\\n    }\\n\\n    function getAndAppendChallenge(TranscriptData memory self) internal pure returns (uint256) {\\n        bytes32 h1 = keccak256(\\n            abi.encodePacked(self.state[0], self.state[1], self.transcript, uint8(0))\\n        );\\n        bytes32 h2 = keccak256(\\n            abi.encodePacked(self.state[0], self.state[1], self.transcript, uint8(1))\\n        );\\n\\n        self.state[0] = h1;\\n        self.state[1] = h2;\\n\\n        return BN254.fromLeBytesModOrder(BytesLib.slice(abi.encodePacked(h1, h2), 0, 48));\\n    }\\n\\n    /// @dev Append the verifying key and the public inputs to the transcript.\\n    /// @param verifyingKey verifiying key\\n    /// @param publicInput a list of field elements\\n    function appendVkAndPubInput(\\n        TranscriptData memory self,\\n        IPlonkVerifier.VerifyingKey memory verifyingKey,\\n        uint256[] memory publicInput\\n    ) internal pure {\\n        uint64 sizeInBits = 254;\\n\\n        // Fr field size in bits\\n        appendMessage(\\n            self,\\n            BytesLib.slice(abi.encodePacked(Utils.reverseEndianness(sizeInBits)), 0, 8)\\n        );\\n\\n        // domain size\\n        appendMessage(\\n            self,\\n            BytesLib.slice(\\n                abi.encodePacked(Utils.reverseEndianness(verifyingKey.domainSize)),\\n                0,\\n                8\\n            )\\n        );\\n\\n        // number of inputs\\n        appendMessage(\\n            self,\\n            BytesLib.slice(abi.encodePacked(Utils.reverseEndianness(verifyingKey.numInputs)), 0, 8)\\n        );\\n\\n        // =====================\\n        // k: coset representatives\\n        // =====================\\n        // Currently, K is hardcoded, and there are 5 of them since\\n        // # wire types == 5\\n        appendFieldElement(self, 0x1); // k0 = 1\\n        appendFieldElement(\\n            self,\\n            0x2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a\\n        ); // k1\\n        appendFieldElement(\\n            self,\\n            0x1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb025\\n        ); // k2\\n        appendFieldElement(\\n            self,\\n            0x2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a\\n        ); // k3\\n        appendFieldElement(\\n            self,\\n            0x2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e881\\n        ); // k4\\n\\n        // selectors\\n        appendGroupElement(self, verifyingKey.q1);\\n        appendGroupElement(self, verifyingKey.q2);\\n        appendGroupElement(self, verifyingKey.q3);\\n        appendGroupElement(self, verifyingKey.q4);\\n        appendGroupElement(self, verifyingKey.qM12);\\n        appendGroupElement(self, verifyingKey.qM34);\\n        appendGroupElement(self, verifyingKey.qH1);\\n        appendGroupElement(self, verifyingKey.qH2);\\n        appendGroupElement(self, verifyingKey.qH3);\\n        appendGroupElement(self, verifyingKey.qH4);\\n        appendGroupElement(self, verifyingKey.qO);\\n        appendGroupElement(self, verifyingKey.qC);\\n        appendGroupElement(self, verifyingKey.qEcc);\\n\\n        // sigmas\\n        appendGroupElement(self, verifyingKey.sigma0);\\n        appendGroupElement(self, verifyingKey.sigma1);\\n        appendGroupElement(self, verifyingKey.sigma2);\\n        appendGroupElement(self, verifyingKey.sigma3);\\n        appendGroupElement(self, verifyingKey.sigma4);\\n\\n        // public inputs\\n        for (uint256 i = 0; i < publicInput.length; i++) {\\n            appendFieldElement(self, publicInput[i]);\\n        }\\n    }\\n\\n    /// @dev Append the proof to the transcript.\\n    function appendProofEvaluations(\\n        TranscriptData memory self,\\n        IPlonkVerifier.PlonkProof memory proof\\n    ) internal pure {\\n        appendFieldElement(self, proof.wireEval0);\\n        appendFieldElement(self, proof.wireEval1);\\n        appendFieldElement(self, proof.wireEval2);\\n        appendFieldElement(self, proof.wireEval3);\\n        appendFieldElement(self, proof.wireEval4);\\n\\n        appendFieldElement(self, proof.sigmaEval0);\\n        appendFieldElement(self, proof.sigmaEval1);\\n        appendFieldElement(self, proof.sigmaEval2);\\n        appendFieldElement(self, proof.sigmaEval3);\\n\\n        appendFieldElement(self, proof.prodPermZetaOmegaEval);\\n    }\\n}\\n\",\"keccak256\":\"0x76f6f4335b9bbc09e1b056864d70663c10dce8a667a0f9525bbe826f6dc06321\",\"license\":\"GPL-3.0-or-later\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x6101006040527f260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c160808190527f0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b060a08190527f04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe460c08190527f22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e5560e08190526000939093556001919091556002556003553480156100bb57600080fd5b50613a55806100cb6000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063830affd614610030575b600080fd5b61004361003e366004613629565b610057565b604051901515815260200160405180910390f35b60008251855114801561006b575082518451145b8015610078575082518251145b6100c95760405162461bcd60e51b815260206004820152601a60248201527f506c6f6e6b3a20696e76616c696420696e70757420706172616d00000000000060448201526064015b60405180910390fd5b600083511161011a5760405162461bcd60e51b815260206004820152601c60248201527f506c6f6e6b3a206e656564206174206c6561737420312070726f6f660000000060448201526064016100c0565b6000835167ffffffffffffffff8111156101365761013661315d565b60405190808252806020026020018201604052801561016f57816020015b61015c61306f565b8152602001906001900390816101545790505b50905060005b84518110156102b3576101a0858281518110610193576101936138ac565b60200260200101516102c9565b60005b8682815181106101b5576101b56138ac565b602002602001015151811015610212576102008783815181106101da576101da6138ac565b602002602001015182815181106101f3576101f36138ac565b60200260200101516103f6565b8061020a816138d8565b9150506101a3565b50610283878281518110610228576102286138ac565b6020026020010151878381518110610242576102426138ac565b602002602001015187848151811061025c5761025c6138ac565b6020026020010151878581518110610276576102766138ac565b6020026020010151610458565b828281518110610295576102956138ac565b602002602001018190525080806102ab906138d8565b915050610175565b506102bd816105df565b9150505b949350505050565b80516102d490610d0e565b6102e18160200151610d0e565b6102ee8160400151610d0e565b6102fb8160600151610d0e565b6103088160800151610d0e565b6103158160a00151610d0e565b6103228160c00151610d0e565b61032f8160e00151610d0e565b61033d816101000151610d0e565b61034b816101200151610d0e565b610359816101400151610d0e565b610367816101600151610d0e565b610375816101a001516103f6565b610383816101c001516103f6565b610391816101e001516103f6565b61039f8161020001516103f6565b6103ad8161022001516103f6565b6103bb8161024001516103f6565b6103c98161026001516103f6565b6103d78161028001516103f6565b6103e5816102a001516103f6565b6103f3816102c001516103f6565b50565b600080516020613a008339815191528110806104545760405162461bcd60e51b815260206004820152601b60248201527f426e3235343a20696e76616c6964207363616c6172206669656c64000000000060448201526064016100c0565b5050565b61046061306f565b84602001518451146104b45760405162461bcd60e51b815260206004820152601a60248201527f506c6f6e6b3a2077726f6e6720766572696679696e67206b657900000000000060448201526064016100c0565b60006104c286868686610daf565b905060006104d38760000151610f7d565b905060006104e6828460a0015189611248565b60408051601e8082526103e0820190925291925060009190602082016103c080368337505060408051601e8082526103e082019092529293506000929150602082015b604080518082019091526000808252602082015281526020019060019003908161052957905050905060006105628b858b8987876112a8565b60a0870151606087015191925090600080516020613a00833981519152600081838509604080516101008101825260e09c8d0151815260208101969096528501525050506060810191909152608081019290925260a082015261016087015160c08201526101809096015192860192909252509295945050505050565b8051600090600080516020613a00833981519152600180831115610660576106056130e9565b60005b8481101561065257610640878281518110610625576106256138ac565b602002602001015160000151836112dd90919063ffffffff16565b8061064a816138d8565b915050610608565b5061065c816112e7565b9150505b6040805180820190915260008082526020820152604080518082019091526000808252602082015260006106958660026138f1565b67ffffffffffffffff8111156106ad576106ad61315d565b6040519080825280602002602001820160405280156106d6578160200160208202803683370190505b50905060006106e68760026138f1565b67ffffffffffffffff8111156106fe576106fe61315d565b60405190808252806020026020018201604052801561074357816020015b604080518082019091526000808252602082015281526020019060019003908161071c5790505b509050600160005b8881101561088c5781846107608360026138f1565b81518110610770576107706138ac565b6020026020010181815250508a818151811061078e5761078e6138ac565b602002602001015160c00151838260026107a891906138f1565b815181106107b8576107b86138ac565b60200260200101819052506000808c83815181106107d8576107d86138ac565b602002602001015160000151905089818509915081866107f98560026138f1565b610804906001613910565b81518110610814576108146138ac565b60200260200101818152505050508a8181518110610834576108346138ac565b602002602001015160e001518382600261084e91906138f1565b610859906001613910565b81518110610869576108696138ac565b602002602001018190525087878309915080610884816138d8565b91505061074b565b506108978284611414565b94505050506060806000896000815181106108b4576108b46138ac565b60200260200101516080015151905060008a518260026108d49190613910565b6108de91906138f1565b6108e9906001613910565b90508067ffffffffffffffff8111156109045761090461315d565b60405190808252806020026020018201604052801561092d578160200160208202803683370190505b5093508067ffffffffffffffff8111156109495761094961315d565b60405190808252806020026020018201604052801561098e57816020015b60408051808201909152600080825260208201528152602001906001900390816109675790505b509250600091508190506001815b8c51811015610c385760005b8d6000815181106109bb576109bb6138ac565b60200260200101516080015151811015610aa65760008e83815181106109e3576109e36138ac565b6020026020010151608001518281518110610a0057610a006138ac565b6020026020010151905060008c828609905080898781518110610a2557610a256138ac565b60200260200101818152505050508d8281518110610a4557610a456138ac565b602002602001015160a001518181518110610a6257610a626138ac565b6020026020010151868581518110610a7c57610a7c6138ac565b6020908102919091010152610a92600185613910565b935080610a9e816138d8565b9150506109a8565b5060008d8281518110610abb57610abb6138ac565b602002602001015160200151905060008b828509905080888681518110610ae457610ae46138ac565b60200260200101818152505050508c8181518110610b0457610b046138ac565b602002602001015160c00151858481518110610b2257610b226138ac565b6020908102919091010152610b38600184613910565b925060008d8281518110610b4e57610b4e6138ac565b602002602001015160000151905060008e8381518110610b7057610b706138ac565b602002602001015160400151905060008c8d8385098609905080898781518110610b9c57610b9c6138ac565b6020026020010181815250505050508c8181518110610bbd57610bbd6138ac565b602002602001015160e00151858481518110610bdb57610bdb6138ac565b6020908102919091010152610bf1600184613910565b925060008d8281518110610c0757610c076138ac565b60200260200101516060015190508a8b828509860894508a8a84099250508080610c30906138d8565b91505061099c565b50610c4283611518565b858381518110610c5457610c546138ac565b602002602001018181525050610c8c604080518082018252600080825260209182015281518083019092526001825260029082015290565b848381518110610c9e57610c9e6138ac565b6020026020010181905250610cbb610cb68587611414565b611550565b6040805160808101825260005481526001546020820152600254918101919091526003546060820152909650610d0395508794509250859150610cfe90506115ef565b6116c0565b979650505050505050565b805160208201516000917f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4791826003818085800985090883828309148115831517198483108585101616169350505081610daa5760405162461bcd60e51b815260206004820152601760248201527f426e3235343a20696e76616c696420473120706f696e7400000000000000000060448201526064016100c0565b505050565b610df760405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b610dff6130e9565b600080516020613a00833981519152610e1882856117a2565b610e238288886117cc565b8451610e30908390611a38565b6020850151610e40908390611a38565b6040850151610e50908390611a38565b6060850151610e60908390611a38565b6080850151610e70908390611a38565b610e79826112e7565b50610e83826112e7565b6060840152610e91826112e7565b608084015260a0850151610ea6908390611a38565b610eaf826112e7565b835260c0850151610ec1908390611a38565b60e0850151610ed1908390611a38565b610100850151610ee2908390611a38565b610120850151610ef3908390611a38565b610140850151610f04908390611a38565b610f0d826112e7565b60a0840152610f1c8286611a4f565b610f25826112e7565b60c0840152610160850151610f3b908390611a38565b610180850151610f4c908390611a38565b610f55826112e7565b60e0840152825181818009828282096020860191909152604085015250919695505050505050565b610faf6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b816140000361104357506040805160a081018252600e815260208101929092527f30638ce1a7661b6337a964756aa75257c6bf4778d89789ab819ce60c19b04001908201527f2d965651cdd9e4811f4e51b80ddca8a8b4a93ee17420aae6adaa01c2617c6e8560608201527f281c036f06e7e9e911680d42558e6e8cf40976b0677771c0f8eee934641c8410608082015290565b81618000036110d757506040805160a081018252600f815260208101929092527f3063edaa444bddc677fcd515f614555a777997e0a9287d1e62bf6dd004d82001908201527f2d1ba66f5941dc91017171fa69ec2bd0022a2a2d4115a009a93458fd4e26ecfb60608201527f05d33766e4590b3722701b6f2fa43d0dc3f028424d384e68c92a742fb2dbc0b4608082015290565b81620100000361116b57506040805160a0810182526010815260208101929092527f30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001908201527eeeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b760608201527f0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4608082015290565b81620200000361120057506040805160a0810182526011815260208101929092527f30643640b9f82f90e83b698e5ea6179c7c05542e859533b48b9953a2f5360801908201527f1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e560608201527f244cf010c43ca87237d8b00bf9dd50c4c01c7f086bd4e8c920e75251d96f0d22608082015290565b60405162461bcd60e51b815260206004820152601c60248201527f506f6c793a2073697a65206d75737420696e20325e7b31347e31377d0000000060448201526064016100c0565b61126c60405180606001604052806000815260200160008152602001600081525090565b6112768484611ae5565b8082526112869085908590611b39565b6020820152805161129c90859084908690611b9f565b60408201529392505050565b6000806112b6858789611cf6565b90506112c6888689898888611de2565b6112d18187866120ee565b98975050505050505050565b610454828261213e565b6020818101518051908201518351604051600094859461130f94909390929091869101613963565b60405160208183030381529060405280519060200120905060008360200151600060028110611340576113406138ac565b6020020151846020015160016002811061135c5761135c6138ac565b60200201518560000151600160405160200161137b9493929190613963565b6040516020818303038152906040528051906020012090508184602001516000600281106113ab576113ab6138ac565b6020020181815250508084602001516001600281106113cc576113cc6138ac565b6020020181815250506102c161140f83836040516020016113f7929190918252602082015260400190565b60405160208183030381529060405260006030612171565b612299565b604080518082019091526000808252602082015282518251146114795760405162461bcd60e51b815260206004820181905260248201527f4d534d206572726f723a206c656e67746820646f6573206e6f74206d6174636860448201526064016100c0565b6114b78360008151811061148f5761148f6138ac565b6020026020010151836000815181106114aa576114aa6138ac565b6020026020010151612319565b905060015b8251811015611511576114fd826114f88684815181106114de576114de6138ac565b60200260200101518685815181106114aa576114aa6138ac565b6123bd565b915080611509816138d8565b9150506114bc565b5092915050565b6000611532600080516020613a00833981519152836139b1565b61154a90600080516020613a008339815191526139d3565b92915050565b6040805180820190915260008082526020820152815160208301511590151615611578575090565b6040518060400160405280836000015181526020017f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4784602001516115bd91906139b1565b6115e7907f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd476139d3565b905292915050565b61161a6040518060800160405280600081526020016000815260200160008152602001600081525090565b60405180608001604052807f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81526020017f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa815250905090565b60008060006040518751815260208801516020820152865160408201526020870151606082015260408701516080820152606087015160a0820152855160c0820152602086015160e08201528451610100820152602085015161012082015260408501516101408201526060850151610160820152602060006101808360085afa9150506000519150806117965760405162461bcd60e51b815260206004820152601c60248201527f426e3235343a2050616972696e6720636865636b206661696c6564210000000060448201526064016100c0565b50151595945050505050565b81516040516117b6919083906020016139ea565b60408051601f1981840301815291905290915250565b60fe61180d846118086117de84612464565b6040516020016117f091815260200190565b60405160208183030381529060405260006008612171565b6117a2565b611821846118086117de8660000151612464565b611835846118086117de8660200151612464565b61184084600161213e565b61186a847f2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a61213e565b611894847f1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb02561213e565b6118be847f2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a61213e565b6118e8847f2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e88161213e565b6118f6848460e00151611a38565b61190584846101000151611a38565b61191484846101200151611a38565b61192384846101400151611a38565b61193284846101600151611a38565b61194184846101800151611a38565b61195084846101e00151611a38565b61195f84846102000151611a38565b61196e84846102200151611a38565b61197d84846102400151611a38565b61198c84846101a00151611a38565b61199b84846101c00151611a38565b6119aa84846102600151611a38565b6119b8848460400151611a38565b6119c6848460600151611a38565b6119d4848460800151611a38565b6119e2848460a00151611a38565b6119f0848460c00151611a38565b60005b8251811015611a3157611a1f85848381518110611a1257611a126138ac565b602002602001015161213e565b80611a29816138d8565b9150506119f3565b5050505050565b6000611a43826125b0565b9050610daa83826117a2565b611a5e82826101a0015161213e565b611a6d82826101c0015161213e565b611a7c82826101e0015161213e565b611a8b8282610200015161213e565b611a9a8282610220015161213e565b611aa98282610240015161213e565b611ab88282610260015161213e565b611ac78282610280015161213e565b611ad682826102a0015161213e565b61045482826102c0015161213e565b8151600090600080516020613a0083398151915290838015611b295784935060005b82811015611b1d57838586099450600101611b07565b50600184039350611b30565b6001830393505b50505092915050565b600081600003611b4b57506000611b98565b6040840151600080516020613a0083398151915290600090828186099050858015611b7b57600187039250611b82565b6001840392505b50611b8c82612673565b91508282820993505050505b9392505050565b600081600003611bb1575060006102c1565b83516040860151600080516020613a008339815191529190600090819081908180611bdc8d88612719565b905060008767ffffffffffffffff811115611bf957611bf961315d565b604051908082528060200260200182016040528015611c22578160200160208202803683370190505b509050888b850993506001925060005b88811015611c6757602081026020840101519550898d878c030896508987850960208281028401018890529350600101611c32565b50611c7183612673565b925060005b88811015611ce45760208102602084010151955089868609975089848909975060005b89811015611cc357808214611cbb576020810260208401015197508a888a0998505b600101611c99565b506020810260208f010151955089868909975089888c089a50600101611c76565b50505050505050505050949350505050565b600080600080516020613a008339815191529050600083602001519050600084604001519050600060019050606088015160808901516101a08901516102408a0151878889838709858501088609945050506101c08901516102608a0151878889838709858501088609945050506101e08901516102808a0151878889838709858501088609945050506102008901516102a08a01518788898387098585010886099450505061022089015191506102c0890151868782898587080985099350505050875160208901518586868309870385089650508485838309860387089998505050505050505050565b611df08686868685876127b9565b60c08501518251600080516020613a0083398151915291908190819086906014908110611e1f57611e1f6138ac565b602002602001018181525050856000015184601481518110611e4357611e436138ac565b60200260200101819052508282820990508085601581518110611e6857611e686138ac565b602002602001018181525050856020015184601581518110611e8c57611e8c6138ac565b60200260200101819052508282820990508085601681518110611eb157611eb16138ac565b602002602001018181525050856040015184601681518110611ed557611ed56138ac565b60200260200101819052508282820990508085601781518110611efa57611efa6138ac565b602002602001018181525050856060015184601781518110611f1e57611f1e6138ac565b60200260200101819052508282820990508085601881518110611f4357611f436138ac565b602002602001018181525050856080015184601881518110611f6757611f676138ac565b60200260200101819052508282820990508085601981518110611f8c57611f8c6138ac565b602002602001018181525050886040015184601981518110611fb057611fb06138ac565b60200260200101819052508282820990508085601a81518110611fd557611fd56138ac565b602002602001018181525050886060015184601a81518110611ff957611ff96138ac565b60200260200101819052508282820990508085601b8151811061201e5761201e6138ac565b602002602001018181525050886080015184601b81518110612042576120426138ac565b60200260200101819052508282820990508085601c81518110612067576120676138ac565b6020026020010181815250508860a0015184601c8151811061208b5761208b6138ac565b60200260200101819052508282820990508760e0015185601d815181106120b4576120b46138ac565b6020026020010181815250508560a0015184601d815181106120d8576120d86138ac565b6020026020010181905250505050505050505050565b600080516020613a008339815191528381039060005b600a8110156121355760206015820102840151602082026101a0018601518384828409860894505050600101612104565b50509392505050565b6104548261214b83612464565b60405160200161215d91815260200190565b6040516020818303038152906040526117a2565b60608161217f81601f613910565b10156121cd5760405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f7700000000000000000000000000000000000060448201526064016100c0565b6121d78284613910565b845110156122275760405162461bcd60e51b815260206004820152601160248201527f736c6963655f6f75744f66426f756e647300000000000000000000000000000060448201526064016100c0565b6060821580156122465760405191506000825260208201604052612290565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561227f578051835260209283019201612267565b5050858452601f01601f1916604052505b50949350505050565b6000805b825181101561231357600080516020613a0083398151915261010083099150600080516020613a008339815191528382600186516122db91906139d3565b6122e591906139d3565b815181106122f5576122f56138ac565b016020015160f81c830891508061230b816138d8565b91505061229d565b50919050565b6040805180820190915260008082526020820152612335613103565b835181526020808501519082015260408101839052600060608360808460076107d05a03fa9050808061236757600080fd5b50806123b55760405162461bcd60e51b815260206004820152601960248201527f426e3235343a207363616c6172206d756c206661696c6564210000000000000060448201526064016100c0565b505092915050565b60408051808201909152600080825260208201526123d9613121565b8351815260208085015181830152835160408301528301516060808301919091526000908360c08460066107d05a03fa9050808061241657600080fd5b50806123b55760405162461bcd60e51b815260206004820152601d60248201527f426e3235343a2067726f7570206164646974696f6e206661696c65642100000060448201526064016100c0565b60008190506008817eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff16901b6008827fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff0016901c1790506010817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff16901b6010827fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c1790506020817bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16901b6020827fffffffff00000000ffffffff00000000ffffffff00000000ffffffff0000000016901c17905060408177ffffffffffffffff0000000000000000ffffffffffffffff16901b6040827fffffffffffffffff0000000000000000ffffffffffffffff000000000000000016901c179050608081901b608082901c179050919050565b8051602082015160609160009115901516156125e9577f4000000000000000000000000000000000000000000000000000000000000000175b60208301517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760019190911b1061263d57507f80000000000000000000000000000000000000000000000000000000000000005b825161264a908217612464565b60405160200161265c91815260200190565b604051602081830303815290604052915050919050565b6000806000600080516020613a00833981519152905060405160208152602080820152602060408201528460608201526002820360808201528160a08201526020600060c08360055afa9250506000519250816127125760405162461bcd60e51b815260206004820152601d60248201527f426e3235343a20706f7720707265636f6d70696c65206661696c65642100000060448201526064016100c0565b5050919050565b6060828101516001600080516020613a008339815191528467ffffffffffffffff8111156127495761274961315d565b604051908082528060200260200182016040528015612772578160200160208202803683370190505b50935084151915611b305760208401856020028101600182526020820191505b808210156127ae57828585099350838252602082019150612792565b505050505092915050565b600080600080600080600080516020613a0083398151915290508060208b015160208d01510995508a5193508060a08c015160608d0151099250806101a08a0151840891508060808c015183089150808483099350807f2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a84099150806101c08a0151830891508060808c015183089150808483099350807f1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb02584099150806101e08a0151830891508060808c015183089150808483099350807f2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a84099150806102008a0151830891508060808c015183089150808483099350807f2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e88184099150806102208a0151830891508060808c0151830891508084830993508084870895508860a0015188600081518110612930576129306138ac565b6020026020010181905250858760008151811061294f5761294f6138ac565b6020026020010181815250508060608c01518c51099450806102c08a015186099450806102408a015160608d0151099250806101a08a0151840892508060808c015184089250808386099450806102608a015160608d0151099250806101c08a0151840892508060808c015184089250808386099450806102808a015160608d0151099250806101e08a0151840892508060808c015184089250808386099450806102a08a015160608d0151099250806102008a0151840892508060808c0151840892508083860994508b60c0015188600181518110612a3157612a316138ac565b6020908102919091010152612a4685826139d3565b87600181518110612a5957612a596138ac565b602002602001018181525050886101a0015187600281518110612a7e57612a7e6138ac565b602002602001018181525050886101c0015187600381518110612aa357612aa36138ac565b602002602001018181525050886101e0015187600481518110612ac857612ac86138ac565b60200260200101818152505088610200015187600581518110612aed57612aed6138ac565b6020026020010181815250508b60e0015188600281518110612b1157612b116138ac565b60200260200101819052508b610100015188600381518110612b3557612b356138ac565b60200260200101819052508b610120015188600481518110612b5957612b596138ac565b60200260200101819052508b610140015188600581518110612b7d57612b7d6138ac565b6020026020010181905250806101c08a01516101a08b01510992508287600681518110612bac57612bac6138ac565b6020026020010181815250508b610160015188600681518110612bd157612bd16138ac565b6020026020010181905250806102008a01516101e08b01510992508287600781518110612c0057612c006138ac565b6020026020010181815250508b610180015188600781518110612c2557612c256138ac565b60200260200101819052506101a089015192508083840991508082830991508082840992508287600881518110612c5e57612c5e6138ac565b6020026020010181815250508b6101e0015188600881518110612c8357612c836138ac565b60200260200101819052506101c089015192508083840991508082830991508082840992508287600981518110612cbc57612cbc6138ac565b6020026020010181815250508b610200015188600981518110612ce157612ce16138ac565b60200260200101819052506101e089015192508083840991508082830991508082840992508287600a81518110612d1a57612d1a6138ac565b6020026020010181815250508b610220015188600a81518110612d3f57612d3f6138ac565b602002602001018190525061020089015192508083840991508082830991508082840992508287600b81518110612d7857612d786138ac565b6020026020010181815250508b610240015188600b81518110612d9d57612d9d6138ac565b602002602001018190525088610220015181612db991906139d3565b87600c81518110612dcc57612dcc6138ac565b6020026020010181815250508b6101a0015188600c81518110612df157612df16138ac565b6020026020010181905250600187600d81518110612e1157612e116138ac565b6020026020010181815250508b6101c0015188600d81518110612e3657612e366138ac565b6020026020010181905250806101c08a01516101a08b0151099250806101e08a015184099250806102008a015184099250806102208a0151840992508287600e81518110612e8657612e866138ac565b6020026020010181815250508b610260015188600e81518110612eab57612eab6138ac565b60209081029190910101528951612ec290826139d3565b87600f81518110612ed557612ed56138ac565b6020026020010181815250508860c0015188600f81518110612ef957612ef96138ac565b60200260200101819052508060018b510860a08c0151909350819080099150808284099250808360206010028901510991508187601081518110612f3f57612f3f6138ac565b6020026020010181815250508860e0015188601081518110612f6357612f636138ac565b6020026020010181905250808360206011028901510991508187601181518110612f8f57612f8f6138ac565b60200260200101818152505088610100015188601181518110612fb457612fb46138ac565b6020026020010181905250808360206012028901510991508187601281518110612fe057612fe06138ac565b60200260200101818152505088610120015188601281518110613005576130056138ac565b6020026020010181905250808360206013028901510991508187601381518110613031576130316138ac565b60200260200101818152505088610140015188601381518110613056576130566138ac565b6020026020010181905250505050505050505050505050565b6040518061010001604052806000815260200160008152602001600081526020016000815260200160608152602001606081526020016130c2604051806040016040528060008152602001600081525090565b81526020016130e4604051806040016040528060008152602001600081525090565b905290565b6040518060400160405280606081526020016130e461313f565b60405180606001604052806003906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b60405180604001604052806002906020820280368337509192915050565b634e487b7160e01b600052604160045260246000fd5b6040516102e0810167ffffffffffffffff811182821017156131975761319761315d565b60405290565b604051610280810167ffffffffffffffff811182821017156131975761319761315d565b604051601f8201601f1916810167ffffffffffffffff811182821017156131ea576131ea61315d565b604052919050565b600067ffffffffffffffff82111561320c5761320c61315d565b5060051b60200190565b60006040828403121561322857600080fd5b6040516040810181811067ffffffffffffffff8211171561324b5761324b61315d565b604052823581526020928301359281019290925250919050565b600082601f83011261327657600080fd5b8135602061328b613286836131f2565b6131c1565b828152600592831b85018201928282019190878511156132aa57600080fd5b8387015b8581101561333e57803567ffffffffffffffff8111156132ce5760008081fd5b8801603f81018a136132e05760008081fd5b8581013560406132f2613286836131f2565b82815291851b8301810191888101908d84111561330f5760008081fd5b938201935b8385101561332d57843582529389019390890190613314565b8852505050938501935084016132ae565b5090979650505050505050565b600082601f83011261335c57600080fd5b813561336a613286826131f2565b80828252602082019150610480602081850287010193508684111561338e57600080fd5b602086015b84811015613539578181890312156133ab5760008081fd5b6133b3613173565b6133bd8983613216565b815260406133cd8a828501613216565b602083015260806133e08b828601613216565b8284015260c091506133f48b838601613216565b60608401526101006134088c828701613216565b82850152610140915061341d8c838701613216565b60a08501526101806134318d828801613216565b848601526101c093506134468d858801613216565b60e086015261020061345a8e828901613216565b83870152610240925061346f8e848901613216565b6101208701526102806134848f828a01613216565b858801526102c094506134998f868a01613216565b6101608801526134ad8f6103008a01613216565b838801526103408801356101a0880152610360880135868801526103808801356101e08801526103a0880135828801526103c08801356102208801526103e08801358488015261040088013561026088015261042088013581880152505050506104408401356102a0840152610460840135818401525050808552506020840193508181019050613393565b50909695505050505050565b6000601f838184011261355757600080fd5b82356020613567613286836131f2565b82815260059290921b8501810191818101908784111561358657600080fd5b8287015b8481101561361d57803567ffffffffffffffff808211156135ab5760008081fd5b818a0191508a603f8301126135c05760008081fd5b858201356040828211156135d6576135d661315d565b6135e7828b01601f191689016131c1565b92508183528c818386010111156135fe5760008081fd5b818185018985013750600090820187015284525091830191830161358a565b50979650505050505050565b6000806000806080858703121561363f57600080fd5b843567ffffffffffffffff8082111561365757600080fd5b818701915087601f83011261366b57600080fd5b8135602061367b613286836131f2565b8281526104c0928302850182019282820191908c85111561369b57600080fd5b958301955b848710156138385780878e0312156136b757600080fd5b6136bf61319d565b8735815284880135858201526136d88e60408a01613216565b60408201526136ea8e60808a01613216565b60608201526136fc8e60c08a01613216565b608082015261370f8e6101008a01613216565b60a08201526137228e6101408a01613216565b60c08201526137358e6101808a01613216565b60e08201526137488e6101c08a01613216565b61010082015261375c8e6102008a01613216565b6101208201526102406137718f828b01613216565b6101408301526137858f6102808b01613216565b6101608301526137998f6102c08b01613216565b6101808301526137ad8f6103008b01613216565b6101a08301526137c18f6103408b01613216565b6101c08301526137d58f6103808b01613216565b6101e08301526137e98f6103c08b01613216565b6102008301526137fd8f6104008b01613216565b6102208301526138118f6104408b01613216565b908201526138238e6104808a01613216565b610260820152835295860195918301916136a0565b509850508801359250508082111561384f57600080fd5b61385b88838901613265565b9450604087013591508082111561387157600080fd5b61387d8883890161334b565b9350606087013591508082111561389357600080fd5b506138a087828801613545565b91505092959194509250565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016138ea576138ea6138c2565b5060010190565b600081600019048311821515161561390b5761390b6138c2565b500290565b60008219821115613923576139236138c2565b500190565b6000815160005b81811015613949576020818501810151868301520161392f565b81811115613958576000828601525b509290920192915050565b848152836020820152600061397b6040830185613928565b60f89390931b7fff0000000000000000000000000000000000000000000000000000000000000016835250506001019392505050565b6000826139ce57634e487b7160e01b600052601260045260246000fd5b500690565b6000828210156139e5576139e56138c2565b500390565b60006102c16139f98386613928565b8461392856fe30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001a26469706673582212207bbde0d57a098da74f02de527b4760ca35d3285227b9dca7e0f6b0dd8ebb70f964736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063830affd614610030575b600080fd5b61004361003e366004613629565b610057565b604051901515815260200160405180910390f35b60008251855114801561006b575082518451145b8015610078575082518251145b6100c95760405162461bcd60e51b815260206004820152601a60248201527f506c6f6e6b3a20696e76616c696420696e70757420706172616d00000000000060448201526064015b60405180910390fd5b600083511161011a5760405162461bcd60e51b815260206004820152601c60248201527f506c6f6e6b3a206e656564206174206c6561737420312070726f6f660000000060448201526064016100c0565b6000835167ffffffffffffffff8111156101365761013661315d565b60405190808252806020026020018201604052801561016f57816020015b61015c61306f565b8152602001906001900390816101545790505b50905060005b84518110156102b3576101a0858281518110610193576101936138ac565b60200260200101516102c9565b60005b8682815181106101b5576101b56138ac565b602002602001015151811015610212576102008783815181106101da576101da6138ac565b602002602001015182815181106101f3576101f36138ac565b60200260200101516103f6565b8061020a816138d8565b9150506101a3565b50610283878281518110610228576102286138ac565b6020026020010151878381518110610242576102426138ac565b602002602001015187848151811061025c5761025c6138ac565b6020026020010151878581518110610276576102766138ac565b6020026020010151610458565b828281518110610295576102956138ac565b602002602001018190525080806102ab906138d8565b915050610175565b506102bd816105df565b9150505b949350505050565b80516102d490610d0e565b6102e18160200151610d0e565b6102ee8160400151610d0e565b6102fb8160600151610d0e565b6103088160800151610d0e565b6103158160a00151610d0e565b6103228160c00151610d0e565b61032f8160e00151610d0e565b61033d816101000151610d0e565b61034b816101200151610d0e565b610359816101400151610d0e565b610367816101600151610d0e565b610375816101a001516103f6565b610383816101c001516103f6565b610391816101e001516103f6565b61039f8161020001516103f6565b6103ad8161022001516103f6565b6103bb8161024001516103f6565b6103c98161026001516103f6565b6103d78161028001516103f6565b6103e5816102a001516103f6565b6103f3816102c001516103f6565b50565b600080516020613a008339815191528110806104545760405162461bcd60e51b815260206004820152601b60248201527f426e3235343a20696e76616c6964207363616c6172206669656c64000000000060448201526064016100c0565b5050565b61046061306f565b84602001518451146104b45760405162461bcd60e51b815260206004820152601a60248201527f506c6f6e6b3a2077726f6e6720766572696679696e67206b657900000000000060448201526064016100c0565b60006104c286868686610daf565b905060006104d38760000151610f7d565b905060006104e6828460a0015189611248565b60408051601e8082526103e0820190925291925060009190602082016103c080368337505060408051601e8082526103e082019092529293506000929150602082015b604080518082019091526000808252602082015281526020019060019003908161052957905050905060006105628b858b8987876112a8565b60a0870151606087015191925090600080516020613a00833981519152600081838509604080516101008101825260e09c8d0151815260208101969096528501525050506060810191909152608081019290925260a082015261016087015160c08201526101809096015192860192909252509295945050505050565b8051600090600080516020613a00833981519152600180831115610660576106056130e9565b60005b8481101561065257610640878281518110610625576106256138ac565b602002602001015160000151836112dd90919063ffffffff16565b8061064a816138d8565b915050610608565b5061065c816112e7565b9150505b6040805180820190915260008082526020820152604080518082019091526000808252602082015260006106958660026138f1565b67ffffffffffffffff8111156106ad576106ad61315d565b6040519080825280602002602001820160405280156106d6578160200160208202803683370190505b50905060006106e68760026138f1565b67ffffffffffffffff8111156106fe576106fe61315d565b60405190808252806020026020018201604052801561074357816020015b604080518082019091526000808252602082015281526020019060019003908161071c5790505b509050600160005b8881101561088c5781846107608360026138f1565b81518110610770576107706138ac565b6020026020010181815250508a818151811061078e5761078e6138ac565b602002602001015160c00151838260026107a891906138f1565b815181106107b8576107b86138ac565b60200260200101819052506000808c83815181106107d8576107d86138ac565b602002602001015160000151905089818509915081866107f98560026138f1565b610804906001613910565b81518110610814576108146138ac565b60200260200101818152505050508a8181518110610834576108346138ac565b602002602001015160e001518382600261084e91906138f1565b610859906001613910565b81518110610869576108696138ac565b602002602001018190525087878309915080610884816138d8565b91505061074b565b506108978284611414565b94505050506060806000896000815181106108b4576108b46138ac565b60200260200101516080015151905060008a518260026108d49190613910565b6108de91906138f1565b6108e9906001613910565b90508067ffffffffffffffff8111156109045761090461315d565b60405190808252806020026020018201604052801561092d578160200160208202803683370190505b5093508067ffffffffffffffff8111156109495761094961315d565b60405190808252806020026020018201604052801561098e57816020015b60408051808201909152600080825260208201528152602001906001900390816109675790505b509250600091508190506001815b8c51811015610c385760005b8d6000815181106109bb576109bb6138ac565b60200260200101516080015151811015610aa65760008e83815181106109e3576109e36138ac565b6020026020010151608001518281518110610a0057610a006138ac565b6020026020010151905060008c828609905080898781518110610a2557610a256138ac565b60200260200101818152505050508d8281518110610a4557610a456138ac565b602002602001015160a001518181518110610a6257610a626138ac565b6020026020010151868581518110610a7c57610a7c6138ac565b6020908102919091010152610a92600185613910565b935080610a9e816138d8565b9150506109a8565b5060008d8281518110610abb57610abb6138ac565b602002602001015160200151905060008b828509905080888681518110610ae457610ae46138ac565b60200260200101818152505050508c8181518110610b0457610b046138ac565b602002602001015160c00151858481518110610b2257610b226138ac565b6020908102919091010152610b38600184613910565b925060008d8281518110610b4e57610b4e6138ac565b602002602001015160000151905060008e8381518110610b7057610b706138ac565b602002602001015160400151905060008c8d8385098609905080898781518110610b9c57610b9c6138ac565b6020026020010181815250505050508c8181518110610bbd57610bbd6138ac565b602002602001015160e00151858481518110610bdb57610bdb6138ac565b6020908102919091010152610bf1600184613910565b925060008d8281518110610c0757610c076138ac565b60200260200101516060015190508a8b828509860894508a8a84099250508080610c30906138d8565b91505061099c565b50610c4283611518565b858381518110610c5457610c546138ac565b602002602001018181525050610c8c604080518082018252600080825260209182015281518083019092526001825260029082015290565b848381518110610c9e57610c9e6138ac565b6020026020010181905250610cbb610cb68587611414565b611550565b6040805160808101825260005481526001546020820152600254918101919091526003546060820152909650610d0395508794509250859150610cfe90506115ef565b6116c0565b979650505050505050565b805160208201516000917f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4791826003818085800985090883828309148115831517198483108585101616169350505081610daa5760405162461bcd60e51b815260206004820152601760248201527f426e3235343a20696e76616c696420473120706f696e7400000000000000000060448201526064016100c0565b505050565b610df760405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b610dff6130e9565b600080516020613a00833981519152610e1882856117a2565b610e238288886117cc565b8451610e30908390611a38565b6020850151610e40908390611a38565b6040850151610e50908390611a38565b6060850151610e60908390611a38565b6080850151610e70908390611a38565b610e79826112e7565b50610e83826112e7565b6060840152610e91826112e7565b608084015260a0850151610ea6908390611a38565b610eaf826112e7565b835260c0850151610ec1908390611a38565b60e0850151610ed1908390611a38565b610100850151610ee2908390611a38565b610120850151610ef3908390611a38565b610140850151610f04908390611a38565b610f0d826112e7565b60a0840152610f1c8286611a4f565b610f25826112e7565b60c0840152610160850151610f3b908390611a38565b610180850151610f4c908390611a38565b610f55826112e7565b60e0840152825181818009828282096020860191909152604085015250919695505050505050565b610faf6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b816140000361104357506040805160a081018252600e815260208101929092527f30638ce1a7661b6337a964756aa75257c6bf4778d89789ab819ce60c19b04001908201527f2d965651cdd9e4811f4e51b80ddca8a8b4a93ee17420aae6adaa01c2617c6e8560608201527f281c036f06e7e9e911680d42558e6e8cf40976b0677771c0f8eee934641c8410608082015290565b81618000036110d757506040805160a081018252600f815260208101929092527f3063edaa444bddc677fcd515f614555a777997e0a9287d1e62bf6dd004d82001908201527f2d1ba66f5941dc91017171fa69ec2bd0022a2a2d4115a009a93458fd4e26ecfb60608201527f05d33766e4590b3722701b6f2fa43d0dc3f028424d384e68c92a742fb2dbc0b4608082015290565b81620100000361116b57506040805160a0810182526010815260208101929092527f30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001908201527eeeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b760608201527f0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4608082015290565b81620200000361120057506040805160a0810182526011815260208101929092527f30643640b9f82f90e83b698e5ea6179c7c05542e859533b48b9953a2f5360801908201527f1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e560608201527f244cf010c43ca87237d8b00bf9dd50c4c01c7f086bd4e8c920e75251d96f0d22608082015290565b60405162461bcd60e51b815260206004820152601c60248201527f506f6c793a2073697a65206d75737420696e20325e7b31347e31377d0000000060448201526064016100c0565b61126c60405180606001604052806000815260200160008152602001600081525090565b6112768484611ae5565b8082526112869085908590611b39565b6020820152805161129c90859084908690611b9f565b60408201529392505050565b6000806112b6858789611cf6565b90506112c6888689898888611de2565b6112d18187866120ee565b98975050505050505050565b610454828261213e565b6020818101518051908201518351604051600094859461130f94909390929091869101613963565b60405160208183030381529060405280519060200120905060008360200151600060028110611340576113406138ac565b6020020151846020015160016002811061135c5761135c6138ac565b60200201518560000151600160405160200161137b9493929190613963565b6040516020818303038152906040528051906020012090508184602001516000600281106113ab576113ab6138ac565b6020020181815250508084602001516001600281106113cc576113cc6138ac565b6020020181815250506102c161140f83836040516020016113f7929190918252602082015260400190565b60405160208183030381529060405260006030612171565b612299565b604080518082019091526000808252602082015282518251146114795760405162461bcd60e51b815260206004820181905260248201527f4d534d206572726f723a206c656e67746820646f6573206e6f74206d6174636860448201526064016100c0565b6114b78360008151811061148f5761148f6138ac565b6020026020010151836000815181106114aa576114aa6138ac565b6020026020010151612319565b905060015b8251811015611511576114fd826114f88684815181106114de576114de6138ac565b60200260200101518685815181106114aa576114aa6138ac565b6123bd565b915080611509816138d8565b9150506114bc565b5092915050565b6000611532600080516020613a00833981519152836139b1565b61154a90600080516020613a008339815191526139d3565b92915050565b6040805180820190915260008082526020820152815160208301511590151615611578575090565b6040518060400160405280836000015181526020017f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4784602001516115bd91906139b1565b6115e7907f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd476139d3565b905292915050565b61161a6040518060800160405280600081526020016000815260200160008152602001600081525090565b60405180608001604052807f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81526020017f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa815250905090565b60008060006040518751815260208801516020820152865160408201526020870151606082015260408701516080820152606087015160a0820152855160c0820152602086015160e08201528451610100820152602085015161012082015260408501516101408201526060850151610160820152602060006101808360085afa9150506000519150806117965760405162461bcd60e51b815260206004820152601c60248201527f426e3235343a2050616972696e6720636865636b206661696c6564210000000060448201526064016100c0565b50151595945050505050565b81516040516117b6919083906020016139ea565b60408051601f1981840301815291905290915250565b60fe61180d846118086117de84612464565b6040516020016117f091815260200190565b60405160208183030381529060405260006008612171565b6117a2565b611821846118086117de8660000151612464565b611835846118086117de8660200151612464565b61184084600161213e565b61186a847f2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a61213e565b611894847f1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb02561213e565b6118be847f2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a61213e565b6118e8847f2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e88161213e565b6118f6848460e00151611a38565b61190584846101000151611a38565b61191484846101200151611a38565b61192384846101400151611a38565b61193284846101600151611a38565b61194184846101800151611a38565b61195084846101e00151611a38565b61195f84846102000151611a38565b61196e84846102200151611a38565b61197d84846102400151611a38565b61198c84846101a00151611a38565b61199b84846101c00151611a38565b6119aa84846102600151611a38565b6119b8848460400151611a38565b6119c6848460600151611a38565b6119d4848460800151611a38565b6119e2848460a00151611a38565b6119f0848460c00151611a38565b60005b8251811015611a3157611a1f85848381518110611a1257611a126138ac565b602002602001015161213e565b80611a29816138d8565b9150506119f3565b5050505050565b6000611a43826125b0565b9050610daa83826117a2565b611a5e82826101a0015161213e565b611a6d82826101c0015161213e565b611a7c82826101e0015161213e565b611a8b8282610200015161213e565b611a9a8282610220015161213e565b611aa98282610240015161213e565b611ab88282610260015161213e565b611ac78282610280015161213e565b611ad682826102a0015161213e565b61045482826102c0015161213e565b8151600090600080516020613a0083398151915290838015611b295784935060005b82811015611b1d57838586099450600101611b07565b50600184039350611b30565b6001830393505b50505092915050565b600081600003611b4b57506000611b98565b6040840151600080516020613a0083398151915290600090828186099050858015611b7b57600187039250611b82565b6001840392505b50611b8c82612673565b91508282820993505050505b9392505050565b600081600003611bb1575060006102c1565b83516040860151600080516020613a008339815191529190600090819081908180611bdc8d88612719565b905060008767ffffffffffffffff811115611bf957611bf961315d565b604051908082528060200260200182016040528015611c22578160200160208202803683370190505b509050888b850993506001925060005b88811015611c6757602081026020840101519550898d878c030896508987850960208281028401018890529350600101611c32565b50611c7183612673565b925060005b88811015611ce45760208102602084010151955089868609975089848909975060005b89811015611cc357808214611cbb576020810260208401015197508a888a0998505b600101611c99565b506020810260208f010151955089868909975089888c089a50600101611c76565b50505050505050505050949350505050565b600080600080516020613a008339815191529050600083602001519050600084604001519050600060019050606088015160808901516101a08901516102408a0151878889838709858501088609945050506101c08901516102608a0151878889838709858501088609945050506101e08901516102808a0151878889838709858501088609945050506102008901516102a08a01518788898387098585010886099450505061022089015191506102c0890151868782898587080985099350505050875160208901518586868309870385089650508485838309860387089998505050505050505050565b611df08686868685876127b9565b60c08501518251600080516020613a0083398151915291908190819086906014908110611e1f57611e1f6138ac565b602002602001018181525050856000015184601481518110611e4357611e436138ac565b60200260200101819052508282820990508085601581518110611e6857611e686138ac565b602002602001018181525050856020015184601581518110611e8c57611e8c6138ac565b60200260200101819052508282820990508085601681518110611eb157611eb16138ac565b602002602001018181525050856040015184601681518110611ed557611ed56138ac565b60200260200101819052508282820990508085601781518110611efa57611efa6138ac565b602002602001018181525050856060015184601781518110611f1e57611f1e6138ac565b60200260200101819052508282820990508085601881518110611f4357611f436138ac565b602002602001018181525050856080015184601881518110611f6757611f676138ac565b60200260200101819052508282820990508085601981518110611f8c57611f8c6138ac565b602002602001018181525050886040015184601981518110611fb057611fb06138ac565b60200260200101819052508282820990508085601a81518110611fd557611fd56138ac565b602002602001018181525050886060015184601a81518110611ff957611ff96138ac565b60200260200101819052508282820990508085601b8151811061201e5761201e6138ac565b602002602001018181525050886080015184601b81518110612042576120426138ac565b60200260200101819052508282820990508085601c81518110612067576120676138ac565b6020026020010181815250508860a0015184601c8151811061208b5761208b6138ac565b60200260200101819052508282820990508760e0015185601d815181106120b4576120b46138ac565b6020026020010181815250508560a0015184601d815181106120d8576120d86138ac565b6020026020010181905250505050505050505050565b600080516020613a008339815191528381039060005b600a8110156121355760206015820102840151602082026101a0018601518384828409860894505050600101612104565b50509392505050565b6104548261214b83612464565b60405160200161215d91815260200190565b6040516020818303038152906040526117a2565b60608161217f81601f613910565b10156121cd5760405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f7700000000000000000000000000000000000060448201526064016100c0565b6121d78284613910565b845110156122275760405162461bcd60e51b815260206004820152601160248201527f736c6963655f6f75744f66426f756e647300000000000000000000000000000060448201526064016100c0565b6060821580156122465760405191506000825260208201604052612290565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561227f578051835260209283019201612267565b5050858452601f01601f1916604052505b50949350505050565b6000805b825181101561231357600080516020613a0083398151915261010083099150600080516020613a008339815191528382600186516122db91906139d3565b6122e591906139d3565b815181106122f5576122f56138ac565b016020015160f81c830891508061230b816138d8565b91505061229d565b50919050565b6040805180820190915260008082526020820152612335613103565b835181526020808501519082015260408101839052600060608360808460076107d05a03fa9050808061236757600080fd5b50806123b55760405162461bcd60e51b815260206004820152601960248201527f426e3235343a207363616c6172206d756c206661696c6564210000000000000060448201526064016100c0565b505092915050565b60408051808201909152600080825260208201526123d9613121565b8351815260208085015181830152835160408301528301516060808301919091526000908360c08460066107d05a03fa9050808061241657600080fd5b50806123b55760405162461bcd60e51b815260206004820152601d60248201527f426e3235343a2067726f7570206164646974696f6e206661696c65642100000060448201526064016100c0565b60008190506008817eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff16901b6008827fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff0016901c1790506010817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff16901b6010827fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c1790506020817bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16901b6020827fffffffff00000000ffffffff00000000ffffffff00000000ffffffff0000000016901c17905060408177ffffffffffffffff0000000000000000ffffffffffffffff16901b6040827fffffffffffffffff0000000000000000ffffffffffffffff000000000000000016901c179050608081901b608082901c179050919050565b8051602082015160609160009115901516156125e9577f4000000000000000000000000000000000000000000000000000000000000000175b60208301517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760019190911b1061263d57507f80000000000000000000000000000000000000000000000000000000000000005b825161264a908217612464565b60405160200161265c91815260200190565b604051602081830303815290604052915050919050565b6000806000600080516020613a00833981519152905060405160208152602080820152602060408201528460608201526002820360808201528160a08201526020600060c08360055afa9250506000519250816127125760405162461bcd60e51b815260206004820152601d60248201527f426e3235343a20706f7720707265636f6d70696c65206661696c65642100000060448201526064016100c0565b5050919050565b6060828101516001600080516020613a008339815191528467ffffffffffffffff8111156127495761274961315d565b604051908082528060200260200182016040528015612772578160200160208202803683370190505b50935084151915611b305760208401856020028101600182526020820191505b808210156127ae57828585099350838252602082019150612792565b505050505092915050565b600080600080600080600080516020613a0083398151915290508060208b015160208d01510995508a5193508060a08c015160608d0151099250806101a08a0151840891508060808c015183089150808483099350807f2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a84099150806101c08a0151830891508060808c015183089150808483099350807f1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb02584099150806101e08a0151830891508060808c015183089150808483099350807f2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a84099150806102008a0151830891508060808c015183089150808483099350807f2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e88184099150806102208a0151830891508060808c0151830891508084830993508084870895508860a0015188600081518110612930576129306138ac565b6020026020010181905250858760008151811061294f5761294f6138ac565b6020026020010181815250508060608c01518c51099450806102c08a015186099450806102408a015160608d0151099250806101a08a0151840892508060808c015184089250808386099450806102608a015160608d0151099250806101c08a0151840892508060808c015184089250808386099450806102808a015160608d0151099250806101e08a0151840892508060808c015184089250808386099450806102a08a015160608d0151099250806102008a0151840892508060808c0151840892508083860994508b60c0015188600181518110612a3157612a316138ac565b6020908102919091010152612a4685826139d3565b87600181518110612a5957612a596138ac565b602002602001018181525050886101a0015187600281518110612a7e57612a7e6138ac565b602002602001018181525050886101c0015187600381518110612aa357612aa36138ac565b602002602001018181525050886101e0015187600481518110612ac857612ac86138ac565b60200260200101818152505088610200015187600581518110612aed57612aed6138ac565b6020026020010181815250508b60e0015188600281518110612b1157612b116138ac565b60200260200101819052508b610100015188600381518110612b3557612b356138ac565b60200260200101819052508b610120015188600481518110612b5957612b596138ac565b60200260200101819052508b610140015188600581518110612b7d57612b7d6138ac565b6020026020010181905250806101c08a01516101a08b01510992508287600681518110612bac57612bac6138ac565b6020026020010181815250508b610160015188600681518110612bd157612bd16138ac565b6020026020010181905250806102008a01516101e08b01510992508287600781518110612c0057612c006138ac565b6020026020010181815250508b610180015188600781518110612c2557612c256138ac565b60200260200101819052506101a089015192508083840991508082830991508082840992508287600881518110612c5e57612c5e6138ac565b6020026020010181815250508b6101e0015188600881518110612c8357612c836138ac565b60200260200101819052506101c089015192508083840991508082830991508082840992508287600981518110612cbc57612cbc6138ac565b6020026020010181815250508b610200015188600981518110612ce157612ce16138ac565b60200260200101819052506101e089015192508083840991508082830991508082840992508287600a81518110612d1a57612d1a6138ac565b6020026020010181815250508b610220015188600a81518110612d3f57612d3f6138ac565b602002602001018190525061020089015192508083840991508082830991508082840992508287600b81518110612d7857612d786138ac565b6020026020010181815250508b610240015188600b81518110612d9d57612d9d6138ac565b602002602001018190525088610220015181612db991906139d3565b87600c81518110612dcc57612dcc6138ac565b6020026020010181815250508b6101a0015188600c81518110612df157612df16138ac565b6020026020010181905250600187600d81518110612e1157612e116138ac565b6020026020010181815250508b6101c0015188600d81518110612e3657612e366138ac565b6020026020010181905250806101c08a01516101a08b0151099250806101e08a015184099250806102008a015184099250806102208a0151840992508287600e81518110612e8657612e866138ac565b6020026020010181815250508b610260015188600e81518110612eab57612eab6138ac565b60209081029190910101528951612ec290826139d3565b87600f81518110612ed557612ed56138ac565b6020026020010181815250508860c0015188600f81518110612ef957612ef96138ac565b60200260200101819052508060018b510860a08c0151909350819080099150808284099250808360206010028901510991508187601081518110612f3f57612f3f6138ac565b6020026020010181815250508860e0015188601081518110612f6357612f636138ac565b6020026020010181905250808360206011028901510991508187601181518110612f8f57612f8f6138ac565b60200260200101818152505088610100015188601181518110612fb457612fb46138ac565b6020026020010181905250808360206012028901510991508187601281518110612fe057612fe06138ac565b60200260200101818152505088610120015188601281518110613005576130056138ac565b6020026020010181905250808360206013028901510991508187601381518110613031576130316138ac565b60200260200101818152505088610140015188601381518110613056576130566138ac565b6020026020010181905250505050505050505050505050565b6040518061010001604052806000815260200160008152602001600081526020016000815260200160608152602001606081526020016130c2604051806040016040528060008152602001600081525090565b81526020016130e4604051806040016040528060008152602001600081525090565b905290565b6040518060400160405280606081526020016130e461313f565b60405180606001604052806003906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b60405180604001604052806002906020820280368337509192915050565b634e487b7160e01b600052604160045260246000fd5b6040516102e0810167ffffffffffffffff811182821017156131975761319761315d565b60405290565b604051610280810167ffffffffffffffff811182821017156131975761319761315d565b604051601f8201601f1916810167ffffffffffffffff811182821017156131ea576131ea61315d565b604052919050565b600067ffffffffffffffff82111561320c5761320c61315d565b5060051b60200190565b60006040828403121561322857600080fd5b6040516040810181811067ffffffffffffffff8211171561324b5761324b61315d565b604052823581526020928301359281019290925250919050565b600082601f83011261327657600080fd5b8135602061328b613286836131f2565b6131c1565b828152600592831b85018201928282019190878511156132aa57600080fd5b8387015b8581101561333e57803567ffffffffffffffff8111156132ce5760008081fd5b8801603f81018a136132e05760008081fd5b8581013560406132f2613286836131f2565b82815291851b8301810191888101908d84111561330f5760008081fd5b938201935b8385101561332d57843582529389019390890190613314565b8852505050938501935084016132ae565b5090979650505050505050565b600082601f83011261335c57600080fd5b813561336a613286826131f2565b80828252602082019150610480602081850287010193508684111561338e57600080fd5b602086015b84811015613539578181890312156133ab5760008081fd5b6133b3613173565b6133bd8983613216565b815260406133cd8a828501613216565b602083015260806133e08b828601613216565b8284015260c091506133f48b838601613216565b60608401526101006134088c828701613216565b82850152610140915061341d8c838701613216565b60a08501526101806134318d828801613216565b848601526101c093506134468d858801613216565b60e086015261020061345a8e828901613216565b83870152610240925061346f8e848901613216565b6101208701526102806134848f828a01613216565b858801526102c094506134998f868a01613216565b6101608801526134ad8f6103008a01613216565b838801526103408801356101a0880152610360880135868801526103808801356101e08801526103a0880135828801526103c08801356102208801526103e08801358488015261040088013561026088015261042088013581880152505050506104408401356102a0840152610460840135818401525050808552506020840193508181019050613393565b50909695505050505050565b6000601f838184011261355757600080fd5b82356020613567613286836131f2565b82815260059290921b8501810191818101908784111561358657600080fd5b8287015b8481101561361d57803567ffffffffffffffff808211156135ab5760008081fd5b818a0191508a603f8301126135c05760008081fd5b858201356040828211156135d6576135d661315d565b6135e7828b01601f191689016131c1565b92508183528c818386010111156135fe5760008081fd5b818185018985013750600090820187015284525091830191830161358a565b50979650505050505050565b6000806000806080858703121561363f57600080fd5b843567ffffffffffffffff8082111561365757600080fd5b818701915087601f83011261366b57600080fd5b8135602061367b613286836131f2565b8281526104c0928302850182019282820191908c85111561369b57600080fd5b958301955b848710156138385780878e0312156136b757600080fd5b6136bf61319d565b8735815284880135858201526136d88e60408a01613216565b60408201526136ea8e60808a01613216565b60608201526136fc8e60c08a01613216565b608082015261370f8e6101008a01613216565b60a08201526137228e6101408a01613216565b60c08201526137358e6101808a01613216565b60e08201526137488e6101c08a01613216565b61010082015261375c8e6102008a01613216565b6101208201526102406137718f828b01613216565b6101408301526137858f6102808b01613216565b6101608301526137998f6102c08b01613216565b6101808301526137ad8f6103008b01613216565b6101a08301526137c18f6103408b01613216565b6101c08301526137d58f6103808b01613216565b6101e08301526137e98f6103c08b01613216565b6102008301526137fd8f6104008b01613216565b6102208301526138118f6104408b01613216565b908201526138238e6104808a01613216565b610260820152835295860195918301916136a0565b509850508801359250508082111561384f57600080fd5b61385b88838901613265565b9450604087013591508082111561387157600080fd5b61387d8883890161334b565b9350606087013591508082111561389357600080fd5b506138a087828801613545565b91505092959194509250565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016138ea576138ea6138c2565b5060010190565b600081600019048311821515161561390b5761390b6138c2565b500290565b60008219821115613923576139236138c2565b500190565b6000815160005b81811015613949576020818501810151868301520161392f565b81811115613958576000828601525b509290920192915050565b848152836020820152600061397b6040830185613928565b60f89390931b7fff0000000000000000000000000000000000000000000000000000000000000016835250506001019392505050565b6000826139ce57634e487b7160e01b600052601260045260246000fd5b500690565b6000828210156139e5576139e56138c2565b500390565b60006102c16139f98386613928565b8461392856fe30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001a26469706673582212207bbde0d57a098da74f02de527b4760ca35d3285227b9dca7e0f6b0dd8ebb70f964736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "batchVerify((uint256,uint256,(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256))[],uint256[][],((uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)[],bytes[])": {
        "details": "Batch verify multiple TurboPlonk proofs.",
        "params": {
          "extraTranscriptInitMsgs": "An array of bytes from transcript initialization messages",
          "proofs": "An array of Plonk proofs",
          "publicInputs": "A two-dimensional array of public inputs.",
          "verifyingKeys": "An array of verifier keys"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11911,
        "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
        "label": "_betaH",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(G2Point)6183_storage"
      }
    ],
    "types": {
      "t_struct(G2Point)6183_storage": {
        "encoding": "inplace",
        "label": "struct BN254.G2Point",
        "members": [
          {
            "astId": 6176,
            "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
            "label": "x0",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 6178,
            "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
            "label": "x1",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6180,
            "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
            "label": "y0",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 6182,
            "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
            "label": "y1",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}