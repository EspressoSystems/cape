{
  "address": "0x4a2cA664e080d5d513EceFDf6b62386A6C5140f6",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "domainSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "numInputs",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma0",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "sigma4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "q1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "q2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "q3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "q4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qM12",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qM34",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qO",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qC",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qH1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qH2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qH3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qH4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "qEcc",
              "type": "tuple"
            }
          ],
          "internalType": "struct IPlonkVerifier.VerifyingKey[]",
          "name": "verifyingKeys",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256[][]",
          "name": "publicInputs",
          "type": "uint256[][]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire0",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "wire4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "prodPerm",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split0",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split3",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "split4",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "zeta",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BN254.G1Point",
              "name": "zetaOmega",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "wireEval0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wireEval1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wireEval2",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wireEval3",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wireEval4",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigmaEval0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigmaEval1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigmaEval2",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigmaEval3",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prodPermZetaOmegaEval",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPlonkVerifier.PlonkProof[]",
          "name": "proofs",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes[]",
          "name": "extraTranscriptInitMsgs",
          "type": "bytes[]"
        }
      ],
      "name": "batchVerify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb5b13e8b5206b2f4a20cefbfdc76b81ca095ef775d5d2b76f95674489c08df7e",
  "receipt": {
    "to": null,
    "from": "0xb19A0B7Cf8BC81492841537b43d49dEdA35DcE4F",
    "contractAddress": "0x4a2cA664e080d5d513EceFDf6b62386A6C5140f6",
    "transactionIndex": 11,
    "gasUsed": "3296846",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1c9f59f245e949ccb4ad5cd085cf11a8f5049334c9d76a655c2ea2eb2df45a9c",
    "transactionHash": "0xb5b13e8b5206b2f4a20cefbfdc76b81ca095ef775d5d2b76f95674489c08df7e",
    "logs": [],
    "blockNumber": 6670514,
    "cumulativeGasUsed": "4780515",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "4562b65aed9d47b1fb3c1971213274b0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"domainSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numInputs\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"sigma4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"q1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"q2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"q3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"q4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qM12\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qM34\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qO\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qC\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qH1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qH2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qH3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qH4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"qEcc\",\"type\":\"tuple\"}],\"internalType\":\"struct IPlonkVerifier.VerifyingKey[]\",\"name\":\"verifyingKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"publicInputs\",\"type\":\"uint256[][]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"wire4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"prodPerm\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"split4\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"zeta\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct BN254.G1Point\",\"name\":\"zetaOmega\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"wireEval0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wireEval1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wireEval2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wireEval3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wireEval4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaEval0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaEval1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaEval2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaEval3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prodPermZetaOmegaEval\",\"type\":\"uint256\"}],\"internalType\":\"struct IPlonkVerifier.PlonkProof[]\",\"name\":\"proofs\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"extraTranscriptInitMsgs\",\"type\":\"bytes[]\"}],\"name\":\"batchVerify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"batchVerify((uint256,uint256,(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256))[],uint256[][],((uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)[],bytes[])\":{\"details\":\"Batch verify multiple TurboPlonk proofs.\",\"params\":{\"extraTranscriptInitMsgs\":\"An array of bytes from transcript initialization messages\",\"proofs\":\"An array of Plonk proofs\",\"publicInputs\":\"A two-dimensional array of public inputs.\",\"verifyingKeys\":\"An array of verifier keys\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/verifier/PlonkVerifier.sol\":\"PlonkVerifier\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IPlonkVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/BN254.sol\\\";\\n\\ninterface IPlonkVerifier {\\n    // Flatten out TurboPlonk proof\\n    struct PlonkProof {\\n        // the first 5 are 4 inputs and 1 output wire poly commmitments\\n        // i.e., batch_proof.wires_poly_comms_vec.iter()\\n        // wire0 is 32 bytes which is a pointer to BN254.G1Point\\n        BN254.G1Point wire0; // 0x00\\n        BN254.G1Point wire1; // 0x20\\n        BN254.G1Point wire2; // 0x40\\n        BN254.G1Point wire3; // 0x60\\n        BN254.G1Point wire4; // 0x80\\n        // the next one is the  product permutation poly commitment\\n        // i.e., batch_proof.prod_perm_poly_comms_vec.iter()\\n        BN254.G1Point prodPerm; // 0xA0\\n        // the next 5 are split quotient poly commmitments\\n        // i.e., batch_proof.split_quot_poly_comms\\n        BN254.G1Point split0; // 0xC0\\n        BN254.G1Point split1; // 0xE0\\n        BN254.G1Point split2; // 0x100\\n        BN254.G1Point split3; // 0x120\\n        BN254.G1Point split4; // 0x140\\n        // witness poly com for aggregated opening at `zeta`\\n        // i.e., batch_proof.opening_proof\\n        BN254.G1Point zeta; // 0x160\\n        // witness poly com for shifted opening at `zeta * \\\\omega`\\n        // i.e., batch_proof.shifted_opening_proof\\n        BN254.G1Point zetaOmega; // 0x180\\n        // wire poly eval at `zeta`\\n        uint256 wireEval0; // 0x1A0\\n        uint256 wireEval1; // 0x1C0\\n        uint256 wireEval2; // 0x1E0\\n        uint256 wireEval3; // 0x200\\n        uint256 wireEval4; // 0x220\\n        // extended permutation (sigma) poly eval at `zeta`\\n        // last (sigmaEval4) is saved by Maller Optimization\\n        uint256 sigmaEval0; // 0x240\\n        uint256 sigmaEval1; // 0x260\\n        uint256 sigmaEval2; // 0x280\\n        uint256 sigmaEval3; // 0x2A0\\n        // product permutation poly eval at `zeta * \\\\omega`\\n        uint256 prodPermZetaOmegaEval; // 0x2C0\\n    }\\n\\n    // The verifying key for Plonk proofs.\\n    struct VerifyingKey {\\n        uint256 domainSize; // 0x00\\n        uint256 numInputs; // 0x20\\n        // commitment to extended perm (sigma) poly\\n        BN254.G1Point sigma0; // 0x40\\n        BN254.G1Point sigma1; // 0x60\\n        BN254.G1Point sigma2; // 0x80\\n        BN254.G1Point sigma3; // 0xA0\\n        BN254.G1Point sigma4; // 0xC0\\n        // commitment to selector poly\\n        // first 4 are linear combination selector\\n        BN254.G1Point q1; // 0xE0\\n        BN254.G1Point q2; // 0x100\\n        BN254.G1Point q3; // 0x120\\n        BN254.G1Point q4; // 0x140\\n        // multiplication selector for 1st, 2nd wire\\n        BN254.G1Point qM12; // 0x160\\n        // multiplication selector for 3rd, 4th wire\\n        BN254.G1Point qM34; // 0x180\\n        // output selector\\n        BN254.G1Point qO; // 0x1A0\\n        // constant term selector\\n        BN254.G1Point qC; // 0x1C0\\n        // rescue selector qH1 * w_ai^5\\n        BN254.G1Point qH1; // 0x1E0\\n        // rescue selector qH2 * w_bi^5\\n        BN254.G1Point qH2; // 0x200\\n        // rescue selector qH3 * w_ci^5\\n        BN254.G1Point qH3; // 0x220\\n        // rescue selector qH4 * w_di^5\\n        BN254.G1Point qH4; // 0x240\\n        // elliptic curve selector\\n        BN254.G1Point qEcc; // 0x260\\n    }\\n\\n    /// @dev Batch verify multiple TurboPlonk proofs.\\n    /// @param verifyingKeys An array of verifying keys\\n    /// @param publicInputs A two-dimensional array of public inputs.\\n    /// @param proofs An array of Plonk proofs\\n    /// @param extraTranscriptInitMsgs An array of bytes from\\n    /// transcript initialization messages\\n    /// @return _ A boolean that is true for successful verification, false otherwise\\n    function batchVerify(\\n        VerifyingKey[] memory verifyingKeys,\\n        uint256[][] memory publicInputs,\\n        PlonkProof[] memory proofs,\\n        bytes[] memory extraTranscriptInitMsgs\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x00fe49efd24714544a8bec75e0a179a07f80752b72e4840a894e574b663baa3b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/BN254.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// Based on:\\n// - Christian Reitwiessner: https://gist.githubusercontent.com/chriseth/f9be9d9391efc5beb9704255a8e2989d/raw/4d0fb90847df1d4e04d507019031888df8372239/snarktest.solidity\\n// - Aztec: https://github.com/AztecProtocol/aztec-2-bug-bounty\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Utils.sol\\\";\\n\\n/// @notice Barreto-Naehrig curve over a 254 bit prime field\\nlibrary BN254 {\\n    // use notation from https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/\\n    //\\n    // Elliptic curve is defined over a prime field GF(p), with embedding degree k.\\n    // Short Weierstrass (SW form) is, for a, b \\\\in GF(p^n) for some natural number n > 0:\\n    //   E: y^2 = x^3 + a * x + b\\n    //\\n    // Pairing is defined over cyclic subgroups G1, G2, both of which are of order r.\\n    // G1 is a subgroup of E(GF(p)), G2 is a subgroup of E(GF(p^k)).\\n    //\\n    // BN family are parameterized curves with well-chosen t,\\n    //   p = 36 * t^4 + 36 * t^3 + 24 * t^2 + 6 * t + 1\\n    //   r = 36 * t^4 + 36 * t^3 + 18 * t^2 + 6 * t + 1\\n    // for some integer t.\\n    // E has the equation:\\n    //   E: y^2 = x^3 + b\\n    // where b is a primitive element of multiplicative group (GF(p))^* of order (p-1).\\n    // A pairing e is defined by taking G1 as a subgroup of E(GF(p)) of order r,\\n    // G2 as a subgroup of E'(GF(p^2)),\\n    // and G_T as a subgroup of a multiplicative group (GF(p^12))^* of order r.\\n    //\\n    // BN254 is defined over a 254-bit prime order p, embedding degree k = 12.\\n    uint256 public constant P_MOD =\\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 public constant R_MOD =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fp2 = x0 * z + x1\\n    struct G2Point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    /// @return the generator of G1\\n    // solhint-disable-next-line func-name-mixedcase\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    /// @return the generator of G2\\n    // solhint-disable-next-line func-name-mixedcase\\n    function P2() internal pure returns (G2Point memory) {\\n        return\\n            G2Point({\\n                x0: 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                x1: 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,\\n                y0: 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                y1: 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n            });\\n    }\\n\\n    /// @dev check if a G1 point is Infinity\\n    /// @notice precompile bn256Add at address(6) takes (0, 0) as Point of Infinity,\\n    /// some crypto libraries (such as arkwork) uses a boolean flag to mark PoI, and\\n    /// just use (0, 1) as affine coordinates (not on curve) to represents PoI.\\n    function isInfinity(G1Point memory point) internal pure returns (bool result) {\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n            result := and(iszero(x), iszero(y))\\n        }\\n    }\\n\\n    /// @return r the negation of p, i.e. p.add(p.negate()) should be zero.\\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\\n        if (isInfinity(p)) {\\n            return p;\\n        }\\n        return G1Point(p.x, P_MOD - (p.y % P_MOD));\\n    }\\n\\n    /// @return res = -fr the negation of scalar field element.\\n    function negate(uint256 fr) internal pure returns (uint256 res) {\\n        return R_MOD - (fr % R_MOD);\\n    }\\n\\n    /// @return r the sum of two points of G1\\n    function add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n        uint256[4] memory input;\\n        input[0] = p1.x;\\n        input[1] = p1.y;\\n        input[2] = p2.x;\\n        input[3] = p2.y;\\n        bool success;\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"Bn254: group addition failed!\\\");\\n    }\\n\\n    /// @return r the product of a point on G1 and a scalar, i.e.\\n    /// p == p.mul(1) and p.add(p) == p.mul(2) for all points p.\\n    function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\\n        uint256[3] memory input;\\n        input[0] = p.x;\\n        input[1] = p.y;\\n        input[2] = s;\\n        bool success;\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"Bn254: scalar mul failed!\\\");\\n    }\\n\\n    /// @dev Multi-scalar Mulitiplication (MSM)\\n    /// @return r = \\\\Prod{B_i^s_i} where {s_i} are `scalars` and {B_i} are `bases`\\n    function multiScalarMul(G1Point[] memory bases, uint256[] memory scalars)\\n        internal\\n        view\\n        returns (G1Point memory r)\\n    {\\n        require(scalars.length == bases.length, \\\"MSM error: length does not match\\\");\\n\\n        r = scalarMul(bases[0], scalars[0]);\\n        for (uint256 i = 1; i < scalars.length; i++) {\\n            r = add(r, scalarMul(bases[i], scalars[i]));\\n        }\\n    }\\n\\n    /// @dev Compute f^-1 for f \\\\in Fr scalar field\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function invert(uint256 fr) internal view returns (uint256 output) {\\n        bool success;\\n        uint256 p = R_MOD;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), fr)\\n            mstore(add(mPtr, 0x80), sub(p, 2))\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            output := mload(0x00)\\n        }\\n        require(success, \\\"Bn254: pow precompile failed!\\\");\\n    }\\n\\n    /**\\n     * validate the following:\\n     *   x != 0\\n     *   y != 0\\n     *   x < p\\n     *   y < p\\n     *   y^2 = x^3 + 3 mod p\\n     */\\n    /// @dev validate G1 point and check if it is on curve\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function validateG1Point(G1Point memory point) internal pure {\\n        bool isWellFormed;\\n        uint256 p = P_MOD;\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n\\n            isWellFormed := and(\\n                and(and(lt(x, p), lt(y, p)), not(or(iszero(x), iszero(y)))),\\n                eq(mulmod(y, y, p), addmod(mulmod(x, mulmod(x, x, p), p), 3, p))\\n            )\\n        }\\n        require(isWellFormed, \\\"Bn254: invalid G1 point\\\");\\n    }\\n\\n    /// @dev Validate scalar field, revert if invalid (namely if fr > r_mod).\\n    /// @notice Writing this inline instead of calling it might save gas.\\n    function validateScalarField(uint256 fr) internal pure {\\n        bool isValid;\\n        assembly {\\n            isValid := lt(fr, R_MOD)\\n        }\\n        require(isValid, \\\"Bn254: invalid scalar field\\\");\\n    }\\n\\n    /// @dev Evaluate the following pairing product:\\n    /// @dev e(a1, a2).e(-b1, b2) == 1\\n    /// @dev caller needs to ensure that a1, a2, b1 and b2 are within proper group\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        uint256 out;\\n        bool success;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, mload(a1))\\n            mstore(add(mPtr, 0x20), mload(add(a1, 0x20)))\\n            mstore(add(mPtr, 0x40), mload(a2))\\n            mstore(add(mPtr, 0x60), mload(add(a2, 0x20)))\\n            mstore(add(mPtr, 0x80), mload(add(a2, 0x40)))\\n            mstore(add(mPtr, 0xa0), mload(add(a2, 0x60)))\\n\\n            mstore(add(mPtr, 0xc0), mload(b1))\\n            mstore(add(mPtr, 0xe0), mload(add(b1, 0x20)))\\n            mstore(add(mPtr, 0x100), mload(b2))\\n            mstore(add(mPtr, 0x120), mload(add(b2, 0x20)))\\n            mstore(add(mPtr, 0x140), mload(add(b2, 0x40)))\\n            mstore(add(mPtr, 0x160), mload(add(b2, 0x60)))\\n            success := staticcall(gas(), 8, mPtr, 0x180, 0x00, 0x20)\\n            out := mload(0x00)\\n        }\\n        require(success, \\\"Bn254: Pairing check failed!\\\");\\n        return (out != 0);\\n    }\\n\\n    function fromLeBytesModOrder(bytes memory leBytes) internal pure returns (uint256 ret) {\\n        for (uint256 i = 0; i < leBytes.length; i++) {\\n            ret = mulmod(ret, 256, R_MOD);\\n            ret = addmod(ret, uint256(uint8(leBytes[leBytes.length - 1 - i])), R_MOD);\\n        }\\n    }\\n\\n    /// @dev Check if y-coordinate of G1 point is negative.\\n    function isYNegative(G1Point memory point) internal pure returns (bool) {\\n        return (point.y << 1) < P_MOD;\\n    }\\n\\n    // @dev Perform a modular exponentiation.\\n    // @return base^exponent (mod modulus)\\n    // This method is ideal for small exponents (~64 bits or less), as it is cheaper than using the pow precompile\\n    // @notice credit: credit: Aztec, Spilsbury Holdings Ltd\\n    function powSmall(\\n        uint256 base,\\n        uint256 exponent,\\n        uint256 modulus\\n    ) internal pure returns (uint256) {\\n        uint256 result = 1;\\n        uint256 input = base;\\n        uint256 count = 1;\\n\\n        assembly {\\n            let endpoint := add(exponent, 0x01)\\n            for {\\n\\n            } lt(count, endpoint) {\\n                count := add(count, count)\\n            } {\\n                if and(exponent, count) {\\n                    result := mulmod(result, input, modulus)\\n                }\\n                input := mulmod(input, input, modulus)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function g1Serialize(G1Point memory point) internal pure returns (bytes memory) {\\n        uint256 mask;\\n\\n        // Set the 254-th bit to 1 for infinity\\n        // https://docs.rs/ark-serialize/0.3.0/src/ark_serialize/flags.rs.html#117\\n        if (isInfinity(point)) {\\n            mask |= 0x4000000000000000000000000000000000000000000000000000000000000000;\\n        }\\n\\n        // Set the 255-th bit to 1 for positive Y\\n        // https://docs.rs/ark-serialize/0.3.0/src/ark_serialize/flags.rs.html#118\\n        if (!isYNegative(point)) {\\n            mask = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n        }\\n\\n        return abi.encodePacked(Utils.reverseEndianness(point.x | mask));\\n    }\\n\\n    function g1Deserialize(bytes32 input) internal view returns (G1Point memory point) {\\n        uint256 mask = 0x4000000000000000000000000000000000000000000000000000000000000000;\\n        uint256 x = Utils.reverseEndianness(uint256(input));\\n        uint256 y;\\n        bool isQuadraticResidue;\\n        bool isYPositive;\\n        if (x & mask != 0) {\\n            // the 254-th bit == 1 for infinity\\n            x = 0;\\n            y = 0;\\n        } else {\\n            // Set the 255-th bit to 1 for positive Y\\n            mask = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n            isYPositive = (x & mask != 0);\\n            // mask off the first two bits of x\\n            mask = 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n            x &= mask;\\n\\n            // solve for y where E: y^2 = x^3 + 3\\n            y = mulmod(x, x, P_MOD);\\n            y = mulmod(y, x, P_MOD);\\n            y = addmod(y, 3, P_MOD);\\n            (isQuadraticResidue, y) = quadraticResidue(y);\\n\\n            require(isQuadraticResidue, \\\"deser fail: not on curve\\\");\\n\\n            if (isYPositive) {\\n                y = P_MOD - y;\\n            }\\n        }\\n\\n        point = G1Point(x, y);\\n    }\\n\\n    function quadraticResidue(uint256 x)\\n        internal\\n        view\\n        returns (bool isQuadraticResidue, uint256 a)\\n    {\\n        bool success;\\n        // e = (p+1)/4\\n        uint256 e = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52;\\n        uint256 p = P_MOD;\\n\\n        // we have p == 3 mod 4 therefore\\n        // a = x^((p+1)/4)\\n        assembly {\\n            // credit: Aztec\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), x)\\n            mstore(add(mPtr, 0x80), e)\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            a := mload(0x00)\\n        }\\n        require(success, \\\"pow precompile call failed!\\\");\\n\\n        // ensure a < p/2\\n        if (a << 1 > p) {\\n            a = p - a;\\n        }\\n\\n        // check if a^2 = x, if not x is not a quadratic residue\\n        e = mulmod(a, a, p);\\n\\n        isQuadraticResidue = (e == x);\\n    }\\n}\\n\",\"keccak256\":\"0x159e456383bb5a73c075e8e5fcb135b188636e58735e31a9dfee25816abc73c8\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/PolynomialEval.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport {BN254} from \\\"../libraries/BN254.sol\\\";\\n\\nlibrary PolynomialEval {\\n    /// @dev a Radix 2 Evaluation Domain\\n    struct EvalDomain {\\n        uint256 logSize; // log_2(self.size)\\n        uint256 size; // Size of the domain as a field element\\n        uint256 sizeInv; // Inverse of the size in the field\\n        uint256 groupGen; // A generator of the subgroup\\n        uint256 groupGenInv; // Inverse of the generator of the subgroup\\n    }\\n\\n    /// @dev stores vanishing poly, lagrange at 1, and Public input poly\\n    struct EvalData {\\n        uint256 vanishEval;\\n        uint256 lagrangeOne;\\n        uint256 piEval;\\n    }\\n\\n    /// @dev compute the EvalData for a given domain and a challenge zeta\\n    function evalDataGen(\\n        EvalDomain memory self,\\n        uint256 zeta,\\n        uint256[] memory publicInput\\n    ) internal view returns (EvalData memory evalData) {\\n        evalData.vanishEval = evaluateVanishingPoly(self, zeta);\\n        evalData.lagrangeOne = evaluateLagrangeOne(self, zeta, evalData.vanishEval);\\n        evalData.piEval = evaluatePiPoly(self, publicInput, zeta, evalData.vanishEval);\\n    }\\n\\n    /// @dev Create a new Radix2EvalDomain with `domainSize` which should be power of 2.\\n    /// @dev Will revert if domainSize is not among {2^14, 2^15, 2^16, 2^17}\\n    function newEvalDomain(uint256 domainSize) internal pure returns (EvalDomain memory) {\\n        if (domainSize == 16384) {\\n            return\\n                EvalDomain(\\n                    14,\\n                    domainSize,\\n                    0x30638CE1A7661B6337A964756AA75257C6BF4778D89789AB819CE60C19B04001,\\n                    0x2D965651CDD9E4811F4E51B80DDCA8A8B4A93EE17420AAE6ADAA01C2617C6E85,\\n                    0x281C036F06E7E9E911680D42558E6E8CF40976B0677771C0F8EEE934641C8410\\n                );\\n        } else if (domainSize == 32768) {\\n            return\\n                EvalDomain(\\n                    15,\\n                    domainSize,\\n                    0x3063edaa444bddc677fcd515f614555a777997e0a9287d1e62bf6dd004d82001,\\n                    0x2d1ba66f5941dc91017171fa69ec2bd0022a2a2d4115a009a93458fd4e26ecfb,\\n                    0x05d33766e4590b3722701b6f2fa43d0dc3f028424d384e68c92a742fb2dbc0b4\\n                );\\n        } else if (domainSize == 65536) {\\n            return\\n                EvalDomain(\\n                    16,\\n                    domainSize,\\n                    0x30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001,\\n                    0x00eeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b7,\\n                    0x0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4\\n                );\\n        } else if (domainSize == 131072) {\\n            return\\n                EvalDomain(\\n                    17,\\n                    domainSize,\\n                    0x30643640b9f82f90e83b698e5ea6179c7c05542e859533b48b9953a2f5360801,\\n                    0x1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e5,\\n                    0x244cf010c43ca87237d8b00bf9dd50c4c01c7f086bd4e8c920e75251d96f0d22\\n                );\\n        } else {\\n            revert(\\\"Poly: size must in 2^{14~17}\\\");\\n        }\\n    }\\n\\n    // This evaluates the vanishing polynomial for this domain at zeta.\\n    // For multiplicative subgroups, this polynomial is\\n    // `z(X) = X^self.size - 1`.\\n    function evaluateVanishingPoly(EvalDomain memory self, uint256 zeta)\\n        internal\\n        pure\\n        returns (uint256 res)\\n    {\\n        uint256 p = BN254.R_MOD;\\n        uint256 logSize = self.logSize;\\n\\n        assembly {\\n            switch zeta\\n            case 0 {\\n                res := sub(p, 1)\\n            }\\n            default {\\n                res := zeta\\n                for {\\n                    let i := 0\\n                } lt(i, logSize) {\\n                    i := add(i, 1)\\n                } {\\n                    res := mulmod(res, res, p)\\n                }\\n                // since zeta != 0 we know that res is not 0\\n                // so we can safely do a subtraction\\n                res := sub(res, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Evaluate the lagrange polynomial at point `zeta` given the vanishing polynomial evaluation `vanish_eval`.\\n    function evaluateLagrangeOne(\\n        EvalDomain memory self,\\n        uint256 zeta,\\n        uint256 vanishEval\\n    ) internal view returns (uint256 res) {\\n        if (vanishEval == 0) {\\n            return 0;\\n        }\\n\\n        uint256 p = BN254.R_MOD;\\n        uint256 divisor;\\n        uint256 vanishEvalMulSizeInv = self.sizeInv;\\n\\n        // =========================\\n        // lagrange_1_eval = vanish_eval / self.size / (zeta - 1)\\n        // =========================\\n        assembly {\\n            vanishEvalMulSizeInv := mulmod(vanishEval, vanishEvalMulSizeInv, p)\\n\\n            switch zeta\\n            case 0 {\\n                divisor := sub(p, 1)\\n            }\\n            default {\\n                divisor := sub(zeta, 1)\\n            }\\n        }\\n        divisor = BN254.invert(divisor);\\n        assembly {\\n            res := mulmod(vanishEvalMulSizeInv, divisor, p)\\n        }\\n    }\\n\\n    /// @dev Evaluate public input polynomial at point `zeta`.\\n    function evaluatePiPoly(\\n        EvalDomain memory self,\\n        uint256[] memory pi,\\n        uint256 zeta,\\n        uint256 vanishEval\\n    ) internal view returns (uint256 res) {\\n        if (vanishEval == 0) {\\n            return 0;\\n        }\\n\\n        uint256 p = BN254.R_MOD;\\n        uint256 length = pi.length;\\n        uint256 ithLagrange;\\n        uint256 ithDivisor;\\n        uint256 tmp;\\n        uint256 vanishEvalDivN = self.sizeInv;\\n        uint256 divisorProd;\\n        uint256[] memory localDomainElements = domainElements(self, length);\\n        uint256[] memory divisors = new uint256[](length);\\n\\n        assembly {\\n            // vanish_eval_div_n = (zeta^n-1)/n\\n            vanishEvalDivN := mulmod(vanishEvalDivN, vanishEval, p)\\n\\n            // Now we need to compute\\n            //  \\\\sum_{i=0..l} L_{i,H}(zeta) * pub_input[i]\\n            // where\\n            // - L_{i,H}(zeta)\\n            //      = Z_H(zeta) * v_i / (zeta - g^i)\\n            //      = vanish_eval_div_n * g^i / (zeta - g^i)\\n            // - v_i = g^i / n\\n            //\\n            // we want to use batch inversion method where we compute\\n            //\\n            //      divisorProd = 1 / \\\\prod (zeta - g^i)\\n            //\\n            // and then each 1 / (zeta - g^i) can be computed via (length - 1)\\n            // multiplications:\\n            //\\n            //      1 / (zeta - g^i) = divisorProd * \\\\prod_{j!=i} (zeta - g^j)\\n            //\\n            // In total this takes n(n-1) multiplications and 1 inversion,\\n            // instead of doing n inversions.\\n            divisorProd := 1\\n\\n            for {\\n                let i := 0\\n            } lt(i, length) {\\n                i := add(i, 1)\\n            } {\\n                // tmp points to g^i\\n                // first 32 bytes of reference is the length of an array\\n                tmp := mload(add(add(localDomainElements, 0x20), mul(i, 0x20)))\\n                // compute (zeta - g^i)\\n                ithDivisor := addmod(sub(p, tmp), zeta, p)\\n                // accumulate (zeta - g^i) to the divisorProd\\n                divisorProd := mulmod(divisorProd, ithDivisor, p)\\n                // store ithDivisor in the array\\n                mstore(add(add(divisors, 0x20), mul(i, 0x20)), ithDivisor)\\n            }\\n        }\\n\\n        // compute 1 / \\\\prod_{i=0}^length (zeta - g^i)\\n        divisorProd = BN254.invert(divisorProd);\\n\\n        assembly {\\n            for {\\n                let i := 0\\n            } lt(i, length) {\\n                i := add(i, 1)\\n            } {\\n                // tmp points to g^i\\n                // first 32 bytes of reference is the length of an array\\n                tmp := mload(add(add(localDomainElements, 0x20), mul(i, 0x20)))\\n                // vanish_eval_div_n * g^i\\n                ithLagrange := mulmod(vanishEvalDivN, tmp, p)\\n\\n                // now we compute vanish_eval_div_n * g^i / (zeta - g^i) via\\n                // vanish_eval_div_n * g^i * divisorProd * \\\\prod_{j!=i} (zeta - g^j)\\n                ithLagrange := mulmod(ithLagrange, divisorProd, p)\\n                for {\\n                    let j := 0\\n                } lt(j, length) {\\n                    j := add(j, 1)\\n                } {\\n                    if iszero(eq(i, j)) {\\n                        ithDivisor := mload(add(add(divisors, 0x20), mul(j, 0x20)))\\n                        ithLagrange := mulmod(ithLagrange, ithDivisor, p)\\n                    }\\n                }\\n\\n                // multiply by pub_input[i] and update res\\n                // tmp points to public input\\n                tmp := mload(add(add(pi, 0x20), mul(i, 0x20)))\\n                ithLagrange := mulmod(ithLagrange, tmp, p)\\n                res := addmod(res, ithLagrange, p)\\n            }\\n        }\\n    }\\n\\n    /// @dev Generate the domain elements for indexes 0..length\\n    /// which are essentially g^0, g^1, ..., g^{length-1}\\n    function domainElements(EvalDomain memory self, uint256 length)\\n        internal\\n        pure\\n        returns (uint256[] memory elements)\\n    {\\n        uint256 groupGen = self.groupGen;\\n        uint256 tmp = 1;\\n        uint256 p = BN254.R_MOD;\\n        elements = new uint256[](length);\\n        assembly {\\n            if not(iszero(length)) {\\n                let ptr := add(elements, 0x20)\\n                let end := add(ptr, mul(0x20, length))\\n                mstore(ptr, 1)\\n                ptr := add(ptr, 0x20)\\n                // for (; ptr < end; ptr += 32) loop through the memory of `elements`\\n                for {\\n\\n                } lt(ptr, end) {\\n                    ptr := add(ptr, 0x20)\\n                } {\\n                    tmp := mulmod(tmp, groupGen, p)\\n                    mstore(ptr, tmp)\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1d7c995706f0a96781030936c20c600387ddd54c86be85e50c2bdc178d9a407f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Utils {\\n    function reverseEndianness(uint256 input) internal pure returns (uint256 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v =\\n            ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v =\\n            ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v =\\n            ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v =\\n            ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n}\\n\",\"keccak256\":\"0x5147ed6d551626c1c17afc4cf65a8770bd55e47821572264b93b29f165bc0869\",\"license\":\"GPL-3.0-or-later\"},\"contracts/verifier/PlonkVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport {BN254} from \\\"../libraries/BN254.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport {PolynomialEval as Poly} from \\\"../libraries/PolynomialEval.sol\\\";\\nimport \\\"./Transcript.sol\\\";\\n\\ncontract PlonkVerifier is IPlonkVerifier {\\n    using Transcript for Transcript.TranscriptData;\\n\\n    // _COSET_K0 = 1, has no effect during multiplication, thus avoid declaring it here.\\n    uint256 private constant _COSET_K1 =\\n        0x2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a;\\n    uint256 private constant _COSET_K2 =\\n        0x1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb025;\\n    uint256 private constant _COSET_K3 =\\n        0x2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a;\\n    uint256 private constant _COSET_K4 =\\n        0x2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e881;\\n\\n    // Parsed from Aztec's Ignition CRS,\\n    // `beta_h` \\\\in G2 where \\\\beta is the trapdoor, h is G2 generator `BN254.P2()`\\n    // See parsing code: https://github.com/alxiong/crs\\n    BN254.G2Point private _betaH =\\n        BN254.G2Point({\\n            x0: 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            x1: 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0,\\n            y0: 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            y1: 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\\n        });\\n\\n    /// The number of wire types of the circuit, TurboPlonk has 5.\\n    uint256 private constant _NUM_WIRE_TYPES = 5;\\n\\n    /// @dev polynomial commitment evaluation info.\\n    struct PcsInfo {\\n        // a random combiner that was used to combine evaluations at point\\n        uint256 u; // 0x00\\n        // the point to be evaluated at\\n        uint256 evalPoint; // 0x20\\n        // the shifted point to be evaluated at\\n        uint256 nextEvalPoint; // 0x40\\n        // the polynomial evaluation value\\n        uint256 eval; // 0x60\\n        // scalars of poly comm for MSM\\n        uint256[] commScalars; // 0x80\\n        // bases of poly comm for MSM\\n        BN254.G1Point[] commBases; // 0xa0\\n        // proof of evaluations at point `eval_point`\\n        BN254.G1Point openingProof; // 0xc0\\n        // proof of evaluations at point `next_eval_point`\\n        BN254.G1Point shiftedOpeningProof; // 0xe0\\n    }\\n\\n    /// @dev Plonk IOP verifier challenges.\\n    struct Challenges {\\n        uint256 alpha; // 0x00\\n        uint256 alpha2; // 0x20\\n        uint256 alpha3; // 0x40\\n        uint256 beta; // 0x60\\n        uint256 gamma; // 0x80\\n        uint256 zeta; // 0xA0\\n        uint256 v; // 0xC0\\n        uint256 u; // 0xE0\\n    }\\n\\n    /// @dev Batch verify multiple TurboPlonk proofs.\\n    /// @param verifyingKeys An array of verifier keys\\n    /// @param publicInputs A two-dimensional array of public inputs.\\n    /// @param proofs An array of Plonk proofs\\n    /// @param extraTranscriptInitMsgs An array of bytes from\\n    /// transcript initialization messages\\n    function batchVerify(\\n        VerifyingKey[] memory verifyingKeys,\\n        uint256[][] memory publicInputs,\\n        PlonkProof[] memory proofs,\\n        bytes[] memory extraTranscriptInitMsgs\\n    ) external view returns (bool) {\\n        require(\\n            verifyingKeys.length == proofs.length &&\\n                publicInputs.length == proofs.length &&\\n                extraTranscriptInitMsgs.length == proofs.length,\\n            \\\"Plonk: invalid input param\\\"\\n        );\\n        require(proofs.length > 0, \\\"Plonk: need at least 1 proof\\\");\\n\\n        PcsInfo[] memory pcsInfos = new PcsInfo[](proofs.length);\\n        for (uint256 i = 0; i < proofs.length; i++) {\\n            // validate proofs are proper group/field elements\\n            _validateProof(proofs[i]);\\n            // validate public input are all proper scalar fields\\n            for (uint256 j = 0; j < publicInputs[i].length; j++) {\\n                BN254.validateScalarField(publicInputs[i][j]);\\n            }\\n            // prepare pcs info\\n            pcsInfos[i] = _preparePcsInfo(\\n                verifyingKeys[i],\\n                publicInputs[i],\\n                proofs[i],\\n                extraTranscriptInitMsgs[i]\\n            );\\n        }\\n\\n        return _batchVerifyOpeningProofs(pcsInfos);\\n    }\\n\\n    /// @dev Validate all group points and scalar fields. Revert if\\n    /// any are invalid.\\n    /// @param proof A Plonk proof\\n    function _validateProof(PlonkProof memory proof) internal pure {\\n        BN254.validateG1Point(proof.wire0);\\n        BN254.validateG1Point(proof.wire1);\\n        BN254.validateG1Point(proof.wire2);\\n        BN254.validateG1Point(proof.wire3);\\n        BN254.validateG1Point(proof.wire4);\\n        BN254.validateG1Point(proof.prodPerm);\\n        BN254.validateG1Point(proof.split0);\\n        BN254.validateG1Point(proof.split1);\\n        BN254.validateG1Point(proof.split2);\\n        BN254.validateG1Point(proof.split3);\\n        BN254.validateG1Point(proof.split4);\\n        BN254.validateG1Point(proof.zeta);\\n        BN254.validateScalarField(proof.wireEval0);\\n        BN254.validateScalarField(proof.wireEval1);\\n        BN254.validateScalarField(proof.wireEval2);\\n        BN254.validateScalarField(proof.wireEval3);\\n        BN254.validateScalarField(proof.wireEval4);\\n        BN254.validateScalarField(proof.sigmaEval0);\\n        BN254.validateScalarField(proof.sigmaEval1);\\n        BN254.validateScalarField(proof.sigmaEval2);\\n        BN254.validateScalarField(proof.sigmaEval3);\\n        BN254.validateScalarField(proof.prodPermZetaOmegaEval);\\n    }\\n\\n    function _preparePcsInfo(\\n        VerifyingKey memory verifyingKey,\\n        uint256[] memory publicInput,\\n        PlonkProof memory proof,\\n        bytes memory extraTranscriptInitMsg\\n    ) internal view returns (PcsInfo memory res) {\\n        require(publicInput.length == verifyingKey.numInputs, \\\"Plonk: wrong verifying key\\\");\\n\\n        Challenges memory chal = _computeChallenges(\\n            verifyingKey,\\n            publicInput,\\n            proof,\\n            extraTranscriptInitMsg\\n        );\\n\\n        Poly.EvalDomain memory domain = Poly.newEvalDomain(verifyingKey.domainSize);\\n        // pre-compute evaluation data\\n        Poly.EvalData memory evalData = Poly.evalDataGen(domain, chal.zeta, publicInput);\\n\\n        // compute opening proof in poly comm.\\n        uint256[] memory commScalars = new uint256[](30);\\n        BN254.G1Point[] memory commBases = new BN254.G1Point[](30);\\n\\n        uint256 eval = _prepareOpeningProof(\\n            verifyingKey,\\n            evalData,\\n            proof,\\n            chal,\\n            commScalars,\\n            commBases\\n        );\\n\\n        uint256 zeta = chal.zeta;\\n        uint256 omega = domain.groupGen;\\n        uint256 p = BN254.R_MOD;\\n        uint256 zetaOmega;\\n        assembly {\\n            zetaOmega := mulmod(zeta, omega, p)\\n        }\\n\\n        res = PcsInfo(\\n            chal.u,\\n            zeta,\\n            zetaOmega,\\n            eval,\\n            commScalars,\\n            commBases,\\n            proof.zeta,\\n            proof.zetaOmega\\n        );\\n    }\\n\\n    function _computeChallenges(\\n        VerifyingKey memory verifyingKey,\\n        uint256[] memory publicInput,\\n        PlonkProof memory proof,\\n        bytes memory extraTranscriptInitMsg\\n    ) internal pure returns (Challenges memory res) {\\n        Transcript.TranscriptData memory transcript;\\n        uint256 p = BN254.R_MOD;\\n\\n        transcript.appendMessage(extraTranscriptInitMsg);\\n        transcript.appendVkAndPubInput(verifyingKey, publicInput);\\n        transcript.appendGroupElement(proof.wire0);\\n        transcript.appendGroupElement(proof.wire1);\\n        transcript.appendGroupElement(proof.wire2);\\n        transcript.appendGroupElement(proof.wire3);\\n        transcript.appendGroupElement(proof.wire4);\\n\\n        // have to compute tau, but not really used anywhere\\n        transcript.getAndAppendChallenge();\\n        res.beta = transcript.getAndAppendChallenge();\\n        res.gamma = transcript.getAndAppendChallenge();\\n\\n        transcript.appendGroupElement(proof.prodPerm);\\n\\n        res.alpha = transcript.getAndAppendChallenge();\\n\\n        transcript.appendGroupElement(proof.split0);\\n        transcript.appendGroupElement(proof.split1);\\n        transcript.appendGroupElement(proof.split2);\\n        transcript.appendGroupElement(proof.split3);\\n        transcript.appendGroupElement(proof.split4);\\n\\n        res.zeta = transcript.getAndAppendChallenge();\\n\\n        transcript.appendProofEvaluations(proof);\\n        res.v = transcript.getAndAppendChallenge();\\n\\n        transcript.appendGroupElement(proof.zeta);\\n        transcript.appendGroupElement(proof.zetaOmega);\\n        res.u = transcript.getAndAppendChallenge();\\n\\n        assembly {\\n            let alpha := mload(res)\\n            let alpha2 := mulmod(alpha, alpha, p)\\n            let alpha3 := mulmod(alpha2, alpha, p)\\n            mstore(add(res, 0x20), alpha2)\\n            mstore(add(res, 0x40), alpha3)\\n        }\\n    }\\n\\n    /// @dev Compute the constant term of the linearization polynomial.\\n    /// ```\\n    /// r_plonk = PI - L1(x) * alpha^2 - alpha * \\\\prod_i=1..m-1 (w_i + beta * sigma_i + gamma) * (w_m + gamma) * z(xw)\\n    /// ```\\n    /// where m is the number of wire types.\\n    function _computeLinPolyConstantTerm(\\n        Challenges memory chal,\\n        PlonkProof memory proof,\\n        Poly.EvalData memory evalData\\n    ) internal pure returns (uint256 res) {\\n        uint256 p = BN254.R_MOD;\\n        uint256 lagrangeOneEval = evalData.lagrangeOne;\\n        uint256 piEval = evalData.piEval;\\n        uint256 perm = 1;\\n\\n        assembly {\\n            let beta := mload(add(chal, 0x60))\\n            let gamma := mload(add(chal, 0x80))\\n\\n            // \\\\prod_i=1..m-1 (w_i + beta * sigma_i + gamma)\\n            {\\n                let w0 := mload(add(proof, 0x1a0))\\n                let sigma0 := mload(add(proof, 0x240))\\n                perm := mulmod(perm, addmod(add(w0, gamma), mulmod(beta, sigma0, p), p), p)\\n            }\\n            {\\n                let w1 := mload(add(proof, 0x1c0))\\n                let sigma1 := mload(add(proof, 0x260))\\n                perm := mulmod(perm, addmod(add(w1, gamma), mulmod(beta, sigma1, p), p), p)\\n            }\\n            {\\n                let w2 := mload(add(proof, 0x1e0))\\n                let sigma2 := mload(add(proof, 0x280))\\n                perm := mulmod(perm, addmod(add(w2, gamma), mulmod(beta, sigma2, p), p), p)\\n            }\\n            {\\n                let w3 := mload(add(proof, 0x200))\\n                let sigma3 := mload(add(proof, 0x2a0))\\n                perm := mulmod(perm, addmod(add(w3, gamma), mulmod(beta, sigma3, p), p), p)\\n            }\\n\\n            // \\\\prod_i=1..m-1 (w_i + beta * sigma_i + gamma) * (w_m + gamma) * z(xw)\\n            {\\n                let w4 := mload(add(proof, 0x220))\\n                let permNextEval := mload(add(proof, 0x2c0))\\n                perm := mulmod(perm, mulmod(addmod(w4, gamma, p), permNextEval, p), p)\\n            }\\n\\n            let alpha := mload(chal)\\n            let alpha2 := mload(add(chal, 0x20))\\n            // PI - L1(x) * alpha^2 - alpha * \\\\prod_i=1..m-1 (w_i + beta * sigma_i + gamma) * (w_m + gamma) * z(xw)\\n            res := addmod(piEval, sub(p, mulmod(alpha2, lagrangeOneEval, p)), p)\\n            res := addmod(res, sub(p, mulmod(alpha, perm, p)), p)\\n        }\\n    }\\n\\n    /// @dev Compute components in [E]1 and [F]1 used for PolyComm opening verification\\n    /// equivalent of JF's https://github.com/EspressoSystems/jellyfish/blob/main/plonk/src/proof_system/verifier.rs#L154-L170\\n    /// caller allocates the memory fr commScalars and commBases\\n    /// requires Arrays of size 30.\\n    /// @param verifyingKey A verifier key\\n    /// @param evalData A polynomial evaluation\\n    /// @param proof A Plonk proof\\n    /// @param chal A set of challenges\\n    /// @param commScalars Common scalars\\n    /// @param commBases Common bases\\n    // The returned commitment is a generalization of\\n    // `[F]1` described in Sec 8.4, step 10 of https://eprint.iacr.org/2019/953.pdf\\n    // Returned evaluation is the scalar in `[E]1` described in Sec 8.4, step 11 of https://eprint.iacr.org/2019/953.pdf\\n    function _prepareOpeningProof(\\n        VerifyingKey memory verifyingKey,\\n        Poly.EvalData memory evalData,\\n        PlonkProof memory proof,\\n        Challenges memory chal,\\n        uint256[] memory commScalars,\\n        BN254.G1Point[] memory commBases\\n    ) internal pure returns (uint256 eval) {\\n        // compute the constant term of the linearization polynomial\\n        uint256 linPolyConstant = _computeLinPolyConstantTerm(chal, proof, evalData);\\n\\n        _preparePolyCommitments(verifyingKey, chal, evalData, proof, commScalars, commBases);\\n\\n        eval = _prepareEvaluations(linPolyConstant, proof, commScalars);\\n    }\\n\\n    /// @dev Similar to `aggregate_poly_commitments()` in Jellyfish, but we are not aggregating multiple,\\n    /// but rather preparing for `[F]1` from a single proof.\\n    /// The caller allocates the memory fr commScalars and commBases.\\n    /// Requires Arrays of size 30.\\n    function _preparePolyCommitments(\\n        VerifyingKey memory verifyingKey,\\n        Challenges memory chal,\\n        Poly.EvalData memory evalData,\\n        PlonkProof memory proof,\\n        uint256[] memory commScalars,\\n        BN254.G1Point[] memory commBases\\n    ) internal pure {\\n        _linearizationScalarsAndBases(verifyingKey, chal, evalData, proof, commBases, commScalars);\\n\\n        uint256 p = BN254.R_MOD;\\n        uint256 v = chal.v;\\n        uint256 vBase = v;\\n\\n        // Add wire witness polynomial commitments.\\n        commScalars[20] = vBase;\\n        commBases[20] = proof.wire0;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[21] = vBase;\\n        commBases[21] = proof.wire1;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[22] = vBase;\\n        commBases[22] = proof.wire2;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[23] = vBase;\\n        commBases[23] = proof.wire3;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[24] = vBase;\\n        commBases[24] = proof.wire4;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        // Add wire sigma polynomial commitments. The last sigma commitment is excluded.\\n        commScalars[25] = vBase;\\n        commBases[25] = verifyingKey.sigma0;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[26] = vBase;\\n        commBases[26] = verifyingKey.sigma1;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[27] = vBase;\\n        commBases[27] = verifyingKey.sigma2;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        commScalars[28] = vBase;\\n        commBases[28] = verifyingKey.sigma3;\\n        assembly {\\n            vBase := mulmod(vBase, v, p)\\n        }\\n\\n        // Add poly commitments to be evaluated at point `zeta * g`.\\n        commScalars[29] = chal.u;\\n        commBases[29] = proof.prodPerm;\\n    }\\n\\n    /// @dev `aggregate_evaluations()` in Jellyfish, but since we are not aggregating multiple, but rather preparing `[E]1` from a single proof.\\n    /// @dev caller allocates the memory fr commScalars\\n    /// requires Arrays of size 30.\\n    /// @param linPolyConstant A linear polynomial constant\\n    /// @param proof A Plonk proof\\n    /// @param commScalars An array of common scalars\\n    /// The returned value is the scalar in `[E]1` described in Sec 8.4, step 11 of https://eprint.iacr.org/2019/953.pdf\\n    function _prepareEvaluations(\\n        uint256 linPolyConstant,\\n        PlonkProof memory proof,\\n        uint256[] memory commScalars\\n    ) internal pure returns (uint256 eval) {\\n        uint256 p = BN254.R_MOD;\\n        assembly {\\n            eval := sub(p, linPolyConstant)\\n            for {\\n                let i := 0\\n            } lt(i, 10) {\\n                i := add(i, 1)\\n            } {\\n                // the first u256 stores the length of this array;\\n                // the next 20 elements are used to store the linearization of the scalars\\n                // the first free space starts from 21\\n                let combiner := mload(add(commScalars, mul(add(i, 21), 0x20)))\\n                let termEval := mload(add(proof, add(0x1a0, mul(i, 0x20))))\\n                eval := addmod(eval, mulmod(combiner, termEval, p), p)\\n            }\\n        }\\n    }\\n\\n    /// @dev Batchly verify multiple PCS opening proofs.\\n    /// `open_key` has been assembled from BN254.P1(), BN254.P2() and contract variable _betaH\\n    /// @param pcsInfos An array of PcsInfo\\n    /// @dev Returns true if the entire batch verifiies and false otherwise.\\n    function _batchVerifyOpeningProofs(PcsInfo[] memory pcsInfos) internal view returns (bool) {\\n        uint256 pcsLen = pcsInfos.length;\\n        uint256 p = BN254.R_MOD;\\n        // Compute a pseudorandom challenge from the instances\\n        uint256 r = 1; // for a single proof, no need to use `r` (`r=1` has no effect)\\n        if (pcsLen > 1) {\\n            Transcript.TranscriptData memory transcript;\\n            for (uint256 i = 0; i < pcsLen; i++) {\\n                transcript.appendChallenge(pcsInfos[i].u);\\n            }\\n            r = transcript.getAndAppendChallenge();\\n        }\\n\\n        BN254.G1Point memory a1;\\n        BN254.G1Point memory b1;\\n\\n        // Compute A := A0 + r * A1 + ... + r^{m-1} * Am\\n        {\\n            uint256[] memory scalars = new uint256[](2 * pcsLen);\\n            BN254.G1Point[] memory bases = new BN254.G1Point[](2 * pcsLen);\\n            uint256 rBase = 1;\\n            for (uint256 i = 0; i < pcsLen; i++) {\\n                scalars[2 * i] = rBase;\\n                bases[2 * i] = pcsInfos[i].openingProof;\\n\\n                {\\n                    uint256 tmp;\\n                    uint256 u = pcsInfos[i].u;\\n                    assembly {\\n                        tmp := mulmod(rBase, u, p)\\n                    }\\n                    scalars[2 * i + 1] = tmp;\\n                }\\n                bases[2 * i + 1] = pcsInfos[i].shiftedOpeningProof;\\n\\n                assembly {\\n                    rBase := mulmod(rBase, r, p)\\n                }\\n            }\\n            a1 = BN254.multiScalarMul(bases, scalars);\\n        }\\n\\n        // Compute B := B0 + r * B1 + ... + r^{m-1} * Bm\\n        {\\n            uint256[] memory scalars;\\n            BN254.G1Point[] memory bases;\\n            {\\n                // variable scoping to avoid \\\"Stack too deep\\\"\\n                uint256 scalarsLenPerInfo = pcsInfos[0].commScalars.length;\\n                uint256 totalScalarsLen = (2 + scalarsLenPerInfo) * pcsInfos.length + 1;\\n                scalars = new uint256[](totalScalarsLen);\\n                bases = new BN254.G1Point[](totalScalarsLen);\\n            }\\n            uint256 sumEvals = 0;\\n            uint256 idx = 0;\\n            uint256 rBase = 1;\\n            for (uint256 i = 0; i < pcsInfos.length; i++) {\\n                for (uint256 j = 0; j < pcsInfos[0].commScalars.length; j++) {\\n                    {\\n                        // scalars[idx] = (rBase * pcsInfos[i].commScalars[j]) % BN254.R_MOD;\\n                        uint256 s = pcsInfos[i].commScalars[j];\\n                        uint256 tmp;\\n                        assembly {\\n                            tmp := mulmod(rBase, s, p)\\n                        }\\n                        scalars[idx] = tmp;\\n                    }\\n                    bases[idx] = pcsInfos[i].commBases[j];\\n                    idx += 1;\\n                }\\n\\n                {\\n                    // scalars[idx] = (rBase * pcsInfos[i].evalPoint) % BN254.R_MOD;\\n                    uint256 evalPoint = pcsInfos[i].evalPoint;\\n                    uint256 tmp;\\n                    assembly {\\n                        tmp := mulmod(rBase, evalPoint, p)\\n                    }\\n                    scalars[idx] = tmp;\\n                }\\n                bases[idx] = pcsInfos[i].openingProof;\\n                idx += 1;\\n\\n                {\\n                    // scalars[idx] = (rBase * pcsInfos[i].u * pcsInfos[i].nextEvalPoint) % BN254.R_MOD;\\n                    uint256 u = pcsInfos[i].u;\\n                    uint256 nextEvalPoint = pcsInfos[i].nextEvalPoint;\\n                    uint256 tmp;\\n                    assembly {\\n                        tmp := mulmod(rBase, mulmod(u, nextEvalPoint, p), p)\\n                    }\\n                    scalars[idx] = tmp;\\n                }\\n                bases[idx] = pcsInfos[i].shiftedOpeningProof;\\n                idx += 1;\\n\\n                {\\n                    // sumEvals = (sumEvals + rBase * pcsInfos[i].eval) % BN254.R_MOD;\\n                    // rBase = (rBase * r) % BN254.R_MOD;\\n                    uint256 eval = pcsInfos[i].eval;\\n                    assembly {\\n                        sumEvals := addmod(sumEvals, mulmod(rBase, eval, p), p)\\n                        rBase := mulmod(rBase, r, p)\\n                    }\\n                }\\n            }\\n            scalars[idx] = BN254.negate(sumEvals);\\n            bases[idx] = BN254.P1();\\n            b1 = BN254.negate(BN254.multiScalarMul(bases, scalars));\\n        }\\n\\n        // Check e(A, [x]2) ?= e(B, [1]2)\\n        return BN254.pairingProd2(a1, _betaH, b1, BN254.P2());\\n    }\\n\\n    /// @dev Compute the linearization of the scalars and bases.\\n    /// The caller allocates the memory from commScalars and commBases.\\n    /// Requires arrays of size 30.\\n    /// @param verifyingKey The verifying key\\n    /// @param challenge A set of challenges\\n    /// @param evalData Polynomial evaluation data\\n    /// @param proof A Plonk proof\\n    /// @param bases An array of BN254 G1 points\\n    /// @param scalars An array of scalars\\n    function _linearizationScalarsAndBases(\\n        VerifyingKey memory verifyingKey,\\n        Challenges memory challenge,\\n        Poly.EvalData memory evalData,\\n        PlonkProof memory proof,\\n        BN254.G1Point[] memory bases,\\n        uint256[] memory scalars\\n    ) internal pure {\\n        uint256 firstScalar;\\n        uint256 secondScalar;\\n        uint256 rhs;\\n        uint256 tmp;\\n        uint256 tmp2;\\n        uint256 p = BN254.R_MOD;\\n\\n        // ============================================\\n        // Compute coefficient for the permutation product polynomial commitment.\\n        // firstScalar =\\n        //          L1(zeta) * alpha^2\\n        //          + alpha\\n        //              * (beta * zeta      + wireEval0 + gamma)\\n        //              * (beta * k1 * zeta + wireEval1 + gamma)\\n        //              * (beta * k2 * zeta + wireEval2 + gamma)\\n        //              * ...\\n        // where wireEval0, wireEval1, wireEval2, ... are in w_evals\\n        // ============================================\\n        // first base and scala:\\n        // - proof.prodPerm\\n        // - firstScalar\\n        assembly {\\n            // firstScalar = alpha^2 * L1(zeta)\\n            firstScalar := mulmod(mload(add(challenge, 0x20)), mload(add(evalData, 0x20)), p)\\n\\n            // rhs = alpha\\n            rhs := mload(challenge)\\n\\n            // tmp = beta * zeta\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(challenge, 0xA0)), p)\\n\\n            // =================================\\n            // k0 (which is 1) component\\n            // (beta * zeta + wireEval0 + gamma)\\n            // =================================\\n            tmp2 := addmod(tmp, mload(add(proof, 0x1A0)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            // =================================\\n            // k1 component\\n            // (beta * zeta * k1 + wireEval1 + gamma)\\n            // =================================\\n            tmp2 := mulmod(tmp, _COSET_K1, p)\\n            tmp2 := addmod(tmp2, mload(add(proof, 0x1C0)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            // =================================\\n            // k2 component\\n            // (beta * zeta * k2 + wireEval2 + gamma)\\n            // =================================\\n            tmp2 := mulmod(tmp, _COSET_K2, p)\\n            tmp2 := addmod(tmp2, mload(add(proof, 0x1E0)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            // =================================\\n            // k3 component\\n            // (beta * zeta * k3 + wireEval3 + gamma)\\n            // =================================\\n            tmp2 := mulmod(tmp, _COSET_K3, p)\\n            tmp2 := addmod(tmp2, mload(add(proof, 0x200)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            // =================================\\n            // k4 component\\n            // (beta * zeta * k4 + wireEval4 + gamma)\\n            // =================================\\n            tmp2 := mulmod(tmp, _COSET_K4, p)\\n            tmp2 := addmod(tmp2, mload(add(proof, 0x220)), p)\\n            tmp2 := addmod(tmp2, mload(add(challenge, 0x80)), p)\\n            rhs := mulmod(tmp2, rhs, p)\\n\\n            firstScalar := addmod(firstScalar, rhs, p)\\n        }\\n        bases[0] = proof.prodPerm;\\n        scalars[0] = firstScalar;\\n\\n        // ============================================\\n        // Compute coefficient for the last wire sigma polynomial commitment.\\n        // secondScalar = alpha * beta * z_w * [s_sigma_3]_1\\n        //              * (wireEval0 + gamma + beta * sigmaEval0)\\n        //              * (wireEval1 + gamma + beta * sigmaEval1)\\n        //              * ...\\n        // ============================================\\n        // second base and scala:\\n        // - verifyingKey.sigma4\\n        // - secondScalar\\n        assembly {\\n            // secondScalar = alpha * beta * z_w\\n            secondScalar := mulmod(mload(challenge), mload(add(challenge, 0x60)), p)\\n            secondScalar := mulmod(secondScalar, mload(add(proof, 0x2C0)), p)\\n\\n            // (wireEval0 + gamma + beta * sigmaEval0)\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(proof, 0x240)), p)\\n            tmp := addmod(tmp, mload(add(proof, 0x1A0)), p)\\n            tmp := addmod(tmp, mload(add(challenge, 0x80)), p)\\n\\n            secondScalar := mulmod(secondScalar, tmp, p)\\n\\n            // (wireEval1 + gamma + beta * sigmaEval1)\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(proof, 0x260)), p)\\n            tmp := addmod(tmp, mload(add(proof, 0x1C0)), p)\\n            tmp := addmod(tmp, mload(add(challenge, 0x80)), p)\\n\\n            secondScalar := mulmod(secondScalar, tmp, p)\\n\\n            // (wireEval2 + gamma + beta * sigmaEval2)\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(proof, 0x280)), p)\\n            tmp := addmod(tmp, mload(add(proof, 0x1E0)), p)\\n            tmp := addmod(tmp, mload(add(challenge, 0x80)), p)\\n\\n            secondScalar := mulmod(secondScalar, tmp, p)\\n\\n            // (wireEval3 + gamma + beta * sigmaEval3)\\n            tmp := mulmod(mload(add(challenge, 0x60)), mload(add(proof, 0x2A0)), p)\\n            tmp := addmod(tmp, mload(add(proof, 0x200)), p)\\n            tmp := addmod(tmp, mload(add(challenge, 0x80)), p)\\n\\n            secondScalar := mulmod(secondScalar, tmp, p)\\n        }\\n        bases[1] = verifyingKey.sigma4;\\n        scalars[1] = p - secondScalar;\\n\\n        // ============================================\\n        // next 13 are for selectors:\\n        //\\n        // the selectors are organized as\\n        // - q_lc\\n        // - q_mul\\n        // - q_hash\\n        // - q_o\\n        // - q_c\\n        // - q_ecc\\n        // ============================================\\n\\n        // ============\\n        // q_lc\\n        // ============\\n        // q_1...q_4\\n        scalars[2] = proof.wireEval0;\\n        scalars[3] = proof.wireEval1;\\n        scalars[4] = proof.wireEval2;\\n        scalars[5] = proof.wireEval3;\\n        bases[2] = verifyingKey.q1;\\n        bases[3] = verifyingKey.q2;\\n        bases[4] = verifyingKey.q3;\\n        bases[5] = verifyingKey.q4;\\n\\n        // ============\\n        // q_M\\n        // ============\\n        // q_M12 and q_M34\\n        // q_M12 = w_evals[0] * w_evals[1];\\n        assembly {\\n            tmp := mulmod(mload(add(proof, 0x1A0)), mload(add(proof, 0x1C0)), p)\\n        }\\n        scalars[6] = tmp;\\n        bases[6] = verifyingKey.qM12;\\n\\n        assembly {\\n            tmp := mulmod(mload(add(proof, 0x1E0)), mload(add(proof, 0x200)), p)\\n        }\\n        scalars[7] = tmp;\\n        bases[7] = verifyingKey.qM34;\\n\\n        // ============\\n        // q_H\\n        // ============\\n        // w_evals[0].pow([5]);\\n        assembly {\\n            tmp := mload(add(proof, 0x1A0))\\n            tmp2 := mulmod(tmp, tmp, p)\\n            tmp2 := mulmod(tmp2, tmp2, p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n        scalars[8] = tmp;\\n        bases[8] = verifyingKey.qH1;\\n\\n        // w_evals[1].pow([5]);\\n        assembly {\\n            tmp := mload(add(proof, 0x1C0))\\n            tmp2 := mulmod(tmp, tmp, p)\\n            tmp2 := mulmod(tmp2, tmp2, p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n        scalars[9] = tmp;\\n        bases[9] = verifyingKey.qH2;\\n\\n        // w_evals[2].pow([5]);\\n        assembly {\\n            tmp := mload(add(proof, 0x1E0))\\n            tmp2 := mulmod(tmp, tmp, p)\\n            tmp2 := mulmod(tmp2, tmp2, p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n        scalars[10] = tmp;\\n        bases[10] = verifyingKey.qH3;\\n\\n        // w_evals[3].pow([5]);\\n        assembly {\\n            tmp := mload(add(proof, 0x200))\\n            tmp2 := mulmod(tmp, tmp, p)\\n            tmp2 := mulmod(tmp2, tmp2, p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n        scalars[11] = tmp;\\n        bases[11] = verifyingKey.qH4;\\n\\n        // ============\\n        // q_o and q_c\\n        // ============\\n        // q_o\\n        scalars[12] = p - proof.wireEval4;\\n        bases[12] = verifyingKey.qO;\\n        // q_c\\n        scalars[13] = 1;\\n        bases[13] = verifyingKey.qC;\\n\\n        // ============\\n        // q_Ecc\\n        // ============\\n        // q_Ecc = w_evals[0] * w_evals[1] * w_evals[2] * w_evals[3] * w_evals[4];\\n        assembly {\\n            tmp := mulmod(mload(add(proof, 0x1A0)), mload(add(proof, 0x1C0)), p)\\n            tmp := mulmod(tmp, mload(add(proof, 0x1E0)), p)\\n            tmp := mulmod(tmp, mload(add(proof, 0x200)), p)\\n            tmp := mulmod(tmp, mload(add(proof, 0x220)), p)\\n        }\\n        scalars[14] = tmp;\\n        bases[14] = verifyingKey.qEcc;\\n\\n        // ============================================\\n        // the last 5 are for splitting quotient commitments\\n        // ============================================\\n\\n        // first one is 1-zeta^n\\n        scalars[15] = p - evalData.vanishEval;\\n        bases[15] = proof.split0;\\n        assembly {\\n            // tmp = zeta^{n+2}\\n            tmp := addmod(mload(evalData), 1, p)\\n            // todo: use pre-computed zeta^2\\n            tmp2 := mulmod(mload(add(challenge, 0xA0)), mload(add(challenge, 0xA0)), p)\\n            tmp := mulmod(tmp, tmp2, p)\\n        }\\n\\n        // second one is (1-zeta^n) zeta^(n+2)\\n        assembly {\\n            tmp2 := mulmod(mload(add(scalars, mul(16, 0x20))), tmp, p)\\n        }\\n        scalars[16] = tmp2;\\n        bases[16] = proof.split1;\\n\\n        // third one is (1-zeta^n) zeta^2(n+2)\\n        assembly {\\n            tmp2 := mulmod(mload(add(scalars, mul(17, 0x20))), tmp, p)\\n        }\\n        scalars[17] = tmp2;\\n        bases[17] = proof.split2;\\n\\n        // forth one is (1-zeta^n) zeta^3(n+2)\\n        assembly {\\n            tmp2 := mulmod(mload(add(scalars, mul(18, 0x20))), tmp, p)\\n        }\\n        scalars[18] = tmp2;\\n        bases[18] = proof.split3;\\n\\n        // fifth one is (1-zeta^n) zeta^4(n+2)\\n        assembly {\\n            tmp2 := mulmod(mload(add(scalars, mul(19, 0x20))), tmp, p)\\n        }\\n        scalars[19] = tmp2;\\n        bases[19] = proof.split4;\\n    }\\n}\\n\",\"keccak256\":\"0xefd7cd9c083d1046ffd2f793fa646c9834465b146433c0c4db0de8a0f764fedc\",\"license\":\"GPL-3.0-or-later\"},\"contracts/verifier/Transcript.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../libraries/Utils.sol\\\";\\nimport {BN254} from \\\"../libraries/BN254.sol\\\";\\nimport {IPlonkVerifier} from \\\"../interfaces/IPlonkVerifier.sol\\\";\\n\\nlibrary Transcript {\\n    struct TranscriptData {\\n        bytes transcript;\\n        bytes32[2] state;\\n    }\\n\\n    // ================================\\n    // Primitive functions\\n    // ================================\\n    function appendMessage(TranscriptData memory self, bytes memory message) internal pure {\\n        self.transcript = abi.encodePacked(self.transcript, message);\\n    }\\n\\n    function appendFieldElement(TranscriptData memory self, uint256 fieldElement) internal pure {\\n        appendMessage(self, abi.encodePacked(Utils.reverseEndianness(fieldElement)));\\n    }\\n\\n    function appendGroupElement(TranscriptData memory self, BN254.G1Point memory comm)\\n        internal\\n        pure\\n    {\\n        bytes memory commBytes = BN254.g1Serialize(comm);\\n        appendMessage(self, commBytes);\\n    }\\n\\n    // ================================\\n    // Transcript APIs\\n    // ================================\\n    function appendChallenge(TranscriptData memory self, uint256 challenge) internal pure {\\n        appendFieldElement(self, challenge);\\n    }\\n\\n    function appendCommitments(TranscriptData memory self, BN254.G1Point[] memory comms)\\n        internal\\n        pure\\n    {\\n        for (uint256 i = 0; i < comms.length; i++) {\\n            appendCommitment(self, comms[i]);\\n        }\\n    }\\n\\n    function appendCommitment(TranscriptData memory self, BN254.G1Point memory comm)\\n        internal\\n        pure\\n    {\\n        appendGroupElement(self, comm);\\n    }\\n\\n    function getAndAppendChallenge(TranscriptData memory self) internal pure returns (uint256) {\\n        bytes32 h1 = keccak256(\\n            abi.encodePacked(self.state[0], self.state[1], self.transcript, uint8(0))\\n        );\\n        bytes32 h2 = keccak256(\\n            abi.encodePacked(self.state[0], self.state[1], self.transcript, uint8(1))\\n        );\\n\\n        self.state[0] = h1;\\n        self.state[1] = h2;\\n\\n        return BN254.fromLeBytesModOrder(BytesLib.slice(abi.encodePacked(h1, h2), 0, 48));\\n    }\\n\\n    /// @dev Append the verifying key and the public inputs to the transcript.\\n    /// @param verifyingKey verifiying key\\n    /// @param publicInput a list of field elements\\n    function appendVkAndPubInput(\\n        TranscriptData memory self,\\n        IPlonkVerifier.VerifyingKey memory verifyingKey,\\n        uint256[] memory publicInput\\n    ) internal pure {\\n        uint64 sizeInBits = 254;\\n\\n        // Fr field size in bits\\n        appendMessage(\\n            self,\\n            BytesLib.slice(abi.encodePacked(Utils.reverseEndianness(sizeInBits)), 0, 8)\\n        );\\n\\n        // domain size\\n        appendMessage(\\n            self,\\n            BytesLib.slice(\\n                abi.encodePacked(Utils.reverseEndianness(verifyingKey.domainSize)),\\n                0,\\n                8\\n            )\\n        );\\n\\n        // number of inputs\\n        appendMessage(\\n            self,\\n            BytesLib.slice(abi.encodePacked(Utils.reverseEndianness(verifyingKey.numInputs)), 0, 8)\\n        );\\n\\n        // =====================\\n        // k: coset representatives\\n        // =====================\\n        // Currently, K is hardcoded, and there are 5 of them since\\n        // # wire types == 5\\n        appendFieldElement(self, 0x1); // k0 = 1\\n        appendFieldElement(\\n            self,\\n            0x2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a\\n        ); // k1\\n        appendFieldElement(\\n            self,\\n            0x1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb025\\n        ); // k2\\n        appendFieldElement(\\n            self,\\n            0x2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a\\n        ); // k3\\n        appendFieldElement(\\n            self,\\n            0x2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e881\\n        ); // k4\\n\\n        // selectors\\n        appendGroupElement(self, verifyingKey.q1);\\n        appendGroupElement(self, verifyingKey.q2);\\n        appendGroupElement(self, verifyingKey.q3);\\n        appendGroupElement(self, verifyingKey.q4);\\n        appendGroupElement(self, verifyingKey.qM12);\\n        appendGroupElement(self, verifyingKey.qM34);\\n        appendGroupElement(self, verifyingKey.qH1);\\n        appendGroupElement(self, verifyingKey.qH2);\\n        appendGroupElement(self, verifyingKey.qH3);\\n        appendGroupElement(self, verifyingKey.qH4);\\n        appendGroupElement(self, verifyingKey.qO);\\n        appendGroupElement(self, verifyingKey.qC);\\n        appendGroupElement(self, verifyingKey.qEcc);\\n\\n        // sigmas\\n        appendGroupElement(self, verifyingKey.sigma0);\\n        appendGroupElement(self, verifyingKey.sigma1);\\n        appendGroupElement(self, verifyingKey.sigma2);\\n        appendGroupElement(self, verifyingKey.sigma3);\\n        appendGroupElement(self, verifyingKey.sigma4);\\n\\n        // public inputs\\n        for (uint256 i = 0; i < publicInput.length; i++) {\\n            appendFieldElement(self, publicInput[i]);\\n        }\\n    }\\n\\n    /// @dev Append the proof to the transcript.\\n    function appendProofEvaluations(\\n        TranscriptData memory self,\\n        IPlonkVerifier.PlonkProof memory proof\\n    ) internal pure {\\n        appendFieldElement(self, proof.wireEval0);\\n        appendFieldElement(self, proof.wireEval1);\\n        appendFieldElement(self, proof.wireEval2);\\n        appendFieldElement(self, proof.wireEval3);\\n        appendFieldElement(self, proof.wireEval4);\\n\\n        appendFieldElement(self, proof.sigmaEval0);\\n        appendFieldElement(self, proof.sigmaEval1);\\n        appendFieldElement(self, proof.sigmaEval2);\\n        appendFieldElement(self, proof.sigmaEval3);\\n\\n        appendFieldElement(self, proof.prodPermZetaOmegaEval);\\n    }\\n}\\n\",\"keccak256\":\"0x4c53b2d2def6126cac49fd718b9d00c454f41dfd069db8ed460584683c45fc4d\",\"license\":\"GPL-3.0-or-later\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x6101006040527f260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c160808190527f0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b060a08190527f04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe460c08190527f22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e5560e08190526000939093556001919091556002556003553480156100bb57600080fd5b50613906806100cb6000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063830affd614610030575b600080fd5b61004361003e3660046134d1565b610057565b604051901515815260200160405180910390f35b60008251855114801561006b575082518451145b8015610078575082518251145b6100c65760405162461bcd60e51b815260206004820152601a602482015279506c6f6e6b3a20696e76616c696420696e70757420706172616d60301b60448201526064015b60405180910390fd5b60008351116101165760405162461bcd60e51b815260206004820152601c60248201527b283637b7359d103732b2b21030ba103632b0b9ba101890383937b7b360211b60448201526064016100bd565b600083516001600160401b038111156101315761013161300c565b60405190808252806020026020018201604052801561016a57816020015b610157612f2e565b81526020019060019003908161014f5790505b50905060005b84518110156102ae5761019b85828151811061018e5761018e613753565b60200260200101516102c4565b60005b8682815181106101b0576101b0613753565b60200260200101515181101561020d576101fb8783815181106101d5576101d5613753565b602002602001015182815181106101ee576101ee613753565b60200260200101516103f1565b806102058161377f565b91505061019e565b5061027e87828151811061022357610223613753565b602002602001015187838151811061023d5761023d613753565b602002602001015187848151811061025757610257613753565b602002602001015187858151811061027157610271613753565b6020026020010151610451565b82828151811061029057610290613753565b602002602001018190525080806102a69061377f565b915050610170565b506102b8816105c9565b9150505b949350505050565b80516102cf90610ca0565b6102dc8160200151610ca0565b6102e98160400151610ca0565b6102f68160600151610ca0565b6103038160800151610ca0565b6103108160a00151610ca0565b61031d8160c00151610ca0565b61032a8160e00151610ca0565b610338816101000151610ca0565b610346816101200151610ca0565b610354816101400151610ca0565b610362816101600151610ca0565b610370816101a001516103f1565b61037e816101c001516103f1565b61038c816101e001516103f1565b61039a8161020001516103f1565b6103a88161022001516103f1565b6103b68161024001516103f1565b6103c48161026001516103f1565b6103d28161028001516103f1565b6103e0816102a001516103f1565b6103ee816102c001516103f1565b50565b6000805160206138b183398151915281108061044d5760405162461bcd60e51b815260206004820152601b60248201527a109b8c8d4d0e881a5b9d985b1a59081cd8d85b185c88199a595b19602a1b60448201526064016100bd565b5050565b610459612f2e565b84602001518451146104aa5760405162461bcd60e51b815260206004820152601a602482015279506c6f6e6b3a2077726f6e6720766572696679696e67206b657960301b60448201526064016100bd565b60006104b886868686610d29565b905060006104c98760000151610ef7565b905060006104dc828460a00151896111c5565b60408051601e8082526103e0820190925291925060009190602082016103c080368337505060408051601e8082526103e082019092529293506000929150602082015b610527612f7e565b81526020019060019003908161051f579050509050600061054c8b858b898787611225565b60a08701516060870151919250906000805160206138b1833981519152600081838509604080516101008101825260e09c8d0151815260208101969096528501525050506060810191909152608081019290925260a082015261016087015160c08201526101809096015192860192909252509295945050505050565b80516000906000805160206138b183398151915260018083111561064a576105ef612f98565b60005b8481101561063c5761062a87828151811061060f5761060f613753565b6020026020010151600001518361125a90919063ffffffff16565b806106348161377f565b9150506105f2565b5061064681611264565b9150505b610652612f7e565b61065a612f7e565b600061066786600261379a565b6001600160401b0381111561067e5761067e61300c565b6040519080825280602002602001820160405280156106a7578160200160208202803683370190505b50905060006106b787600261379a565b6001600160401b038111156106ce576106ce61300c565b60405190808252806020026020018201604052801561070757816020015b6106f4612f7e565b8152602001906001900390816106ec5790505b509050600160005b8881101561085057818461072483600261379a565b8151811061073457610734613753565b6020026020010181815250508a818151811061075257610752613753565b602002602001015160c001518382600261076c919061379a565b8151811061077c5761077c613753565b60200260200101819052506000808c838151811061079c5761079c613753565b602002602001015160000151905089818509915081866107bd85600261379a565b6107c89060016137b9565b815181106107d8576107d8613753565b60200260200101818152505050508a81815181106107f8576107f8613753565b602002602001015160e0015183826002610812919061379a565b61081d9060016137b9565b8151811061082d5761082d613753565b6020026020010181905250878783099150806108488161377f565b91505061070f565b5061085b8284611391565b945050505060608060008960008151811061087857610878613753565b60200260200101516080015151905060008a5182600261089891906137b9565b6108a2919061379a565b6108ad9060016137b9565b9050806001600160401b038111156108c7576108c761300c565b6040519080825280602002602001820160405280156108f0578160200160208202803683370190505b509350806001600160401b0381111561090b5761090b61300c565b60405190808252806020026020018201604052801561094457816020015b610931612f7e565b8152602001906001900390816109295790505b509250600091508190506001815b8c51811015610bee5760005b8d60008151811061097157610971613753565b60200260200101516080015151811015610a5c5760008e838151811061099957610999613753565b60200260200101516080015182815181106109b6576109b6613753565b6020026020010151905060008c8286099050808987815181106109db576109db613753565b60200260200101818152505050508d82815181106109fb576109fb613753565b602002602001015160a001518181518110610a1857610a18613753565b6020026020010151868581518110610a3257610a32613753565b6020908102919091010152610a486001856137b9565b935080610a548161377f565b91505061095e565b5060008d8281518110610a7157610a71613753565b602002602001015160200151905060008b828509905080888681518110610a9a57610a9a613753565b60200260200101818152505050508c8181518110610aba57610aba613753565b602002602001015160c00151858481518110610ad857610ad8613753565b6020908102919091010152610aee6001846137b9565b925060008d8281518110610b0457610b04613753565b602002602001015160000151905060008e8381518110610b2657610b26613753565b602002602001015160400151905060008c8d8385098609905080898781518110610b5257610b52613753565b6020026020010181815250505050508c8181518110610b7357610b73613753565b602002602001015160e00151858481518110610b9157610b91613753565b6020908102919091010152610ba76001846137b9565b925060008d8281518110610bbd57610bbd613753565b60200260200101516060015190508a8b828509860894508a8a84099250508080610be69061377f565b915050610952565b50610bf883611489565b858381518110610c0a57610c0a613753565b602002602001018181525050610c1e6114c1565b848381518110610c3057610c30613753565b6020026020010181905250610c4d610c488587611391565b6114e2565b6040805160808101825260005481526001546020820152600254918101919091526003546060820152909650610c9595508794509250859150610c909050611551565b611622565b979650505050505050565b8051602082015160009160008051602061389183398151915291826003818085800985090883828309148115831517198483108585101616169350505081610d245760405162461bcd60e51b8152602060048201526017602482015276109b8c8d4d0e881a5b9d985b1a590811cc481c1bda5b9d604a1b60448201526064016100bd565b505050565b610d7160405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b610d79612f98565b6000805160206138b1833981519152610d928285611703565b610d9d82888861172d565b8451610daa908390611999565b6020850151610dba908390611999565b6040850151610dca908390611999565b6060850151610dda908390611999565b6080850151610dea908390611999565b610df382611264565b50610dfd82611264565b6060840152610e0b82611264565b608084015260a0850151610e20908390611999565b610e2982611264565b835260c0850151610e3b908390611999565b60e0850151610e4b908390611999565b610100850151610e5c908390611999565b610120850151610e6d908390611999565b610140850151610e7e908390611999565b610e8782611264565b60a0840152610e9682866119b0565b610e9f82611264565b60c0840152610160850151610eb5908390611999565b610180850151610ec6908390611999565b610ecf82611264565b60e0840152825181818009828282096020860191909152604085015250919695505050505050565b610f296040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b816140001415610fbe57506040805160a081018252600e815260208101929092527f30638ce1a7661b6337a964756aa75257c6bf4778d89789ab819ce60c19b04001908201527f2d965651cdd9e4811f4e51b80ddca8a8b4a93ee17420aae6adaa01c2617c6e8560608201527f281c036f06e7e9e911680d42558e6e8cf40976b0677771c0f8eee934641c8410608082015290565b81618000141561105357506040805160a081018252600f815260208101929092527f3063edaa444bddc677fcd515f614555a777997e0a9287d1e62bf6dd004d82001908201527f2d1ba66f5941dc91017171fa69ec2bd0022a2a2d4115a009a93458fd4e26ecfb60608201527f05d33766e4590b3722701b6f2fa43d0dc3f028424d384e68c92a742fb2dbc0b4608082015290565b816201000014156110e857506040805160a0810182526010815260208101929092527f30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001908201527eeeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b760608201527f0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4608082015290565b8162020000141561117e57506040805160a0810182526011815260208101929092527f30643640b9f82f90e83b698e5ea6179c7c05542e859533b48b9953a2f5360801908201527f1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e560608201527f244cf010c43ca87237d8b00bf9dd50c4c01c7f086bd4e8c920e75251d96f0d22608082015290565b60405162461bcd60e51b815260206004820152601c60248201527b506f6c793a2073697a65206d75737420696e20325e7b31347e31377d60201b60448201526064016100bd565b6111e960405180606001604052806000815260200160008152602001600081525090565b6111f38484611a46565b8082526112039085908590611a9a565b6020820152805161121990859084908690611afd565b60408201529392505050565b600080611233858789611c50565b9050611243888689898888611d3c565b61124e818786612048565b98975050505050505050565b61044d8282612098565b6020818101518051908201518351604051600094859461128c9490939092909186910161380c565b604051602081830303815290604052805190602001209050600083602001516000600281106112bd576112bd613753565b602002015184602001516001600281106112d9576112d9613753565b6020020151856000015160016040516020016112f8949392919061380c565b60405160208183030381529060405280519060200120905081846020015160006002811061132857611328613753565b60200201818152505080846020015160016002811061134957611349613753565b6020020181815250506102bc61138c8383604051602001611374929190918252602082015260400190565b604051602081830303815290604052600060306120cb565b6121d8565b611399612f7e565b82518251146113ea5760405162461bcd60e51b815260206004820181905260248201527f4d534d206572726f723a206c656e67746820646f6573206e6f74206d6174636860448201526064016100bd565b6114288360008151811061140057611400613753565b60200260200101518360008151811061141b5761141b613753565b6020026020010151612258565b905060015b82518110156114825761146e8261146986848151811061144f5761144f613753565b602002602001015186858151811061141b5761141b613753565b6122e8565b91508061147a8161377f565b91505061142d565b5092915050565b60006114a36000805160206138b183398151915283613842565b6114bb906000805160206138b1833981519152613864565b92915050565b6114c9612f7e565b5060408051808201909152600181526002602082015290565b6114ea612f7e565b8151602083015115901516156114fe575090565b60405180604001604052808360000151815260200160008051602061389183398151915284602001516115319190613842565b61154990600080516020613891833981519152613864565b905292915050565b61157c6040518060800160405280600081526020016000815260200160008152602001600081525090565b60405180608001604052807f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81526020017f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa815250905090565b60008060006040518751815260208801516020820152865160408201526020870151606082015260408701516080820152606087015160a0820152855160c0820152602086015160e08201528451610100820152602085015161012082015260408501516101408201526060850151610160820152602060006101808360085afa9150506000519150806116f75760405162461bcd60e51b815260206004820152601c60248201527b426e3235343a2050616972696e6720636865636b206661696c65642160201b60448201526064016100bd565b50151595945050505050565b81516040516117179190839060200161387b565b60408051601f1981840301815291905290915250565b60fe61176e8461176961173f8461237f565b60405160200161175191815260200190565b604051602081830303815290604052600060086120cb565b611703565b6117828461176961173f866000015161237f565b6117968461176961173f866020015161237f565b6117a1846001612098565b6117cb847f2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a612098565b6117f5847f1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb025612098565b61181f847f2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a612098565b611849847f2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e881612098565b611857848460e00151611999565b61186684846101000151611999565b61187584846101200151611999565b61188484846101400151611999565b61189384846101600151611999565b6118a284846101800151611999565b6118b184846101e00151611999565b6118c084846102000151611999565b6118cf84846102200151611999565b6118de84846102400151611999565b6118ed84846101a00151611999565b6118fc84846101c00151611999565b61190b84846102600151611999565b611919848460400151611999565b611927848460600151611999565b611935848460800151611999565b611943848460a00151611999565b611951848460c00151611999565b60005b8251811015611992576119808584838151811061197357611973613753565b6020026020010151612098565b8061198a8161377f565b915050611954565b5050505050565b60006119a4826124ba565b9050610d248382611703565b6119bf82826101a00151612098565b6119ce82826101c00151612098565b6119dd82826101e00151612098565b6119ec82826102000151612098565b6119fb82826102200151612098565b611a0a82826102400151612098565b611a1982826102600151612098565b611a2882826102800151612098565b611a3782826102a00151612098565b61044d82826102c00151612098565b81516000906000805160206138b183398151915290838015611a8a5784935060005b82811015611a7e57838586099450600101611a68565b50600184039350611a91565b6001830393505b50505092915050565b600081611aa957506000611af6565b60408401516000805160206138b183398151915290600090828186099050858015611ad957600187039250611ae0565b6001840392505b50611aea82612533565b91508282820993505050505b9392505050565b600081611b0c575060006102bc565b835160408601516000805160206138b18339815191529190600090819081908180611b378d886125d9565b90506000876001600160401b03811115611b5357611b5361300c565b604051908082528060200260200182016040528015611b7c578160200160208202803683370190505b509050888b850993506001925060005b88811015611bc157602081026020840101519550898d878c030896508987850960208281028401018890529350600101611b8c565b50611bcb83612533565b925060005b88811015611c3e5760208102602084010151955089868609975089848909975060005b89811015611c1d57808214611c15576020810260208401015197508a888a0998505b600101611bf3565b506020810260208f010151955089868909975089888c089a50600101611bd0565b50505050505050505050949350505050565b6000806000805160206138b18339815191529050600083602001519050600084604001519050600060019050606088015160808901516101a08901516102408a0151878889838709858501088609945050506101c08901516102608a0151878889838709858501088609945050506101e08901516102808a0151878889838709858501088609945050506102008901516102a08a01518788898387098585010886099450505061022089015191506102c0890151868782898587080985099350505050875160208901518586868309870385089650508485838309860387089998505050505050505050565b611d4a868686868587612678565b60c085015182516000805160206138b183398151915291908190819086906014908110611d7957611d79613753565b602002602001018181525050856000015184601481518110611d9d57611d9d613753565b60200260200101819052508282820990508085601581518110611dc257611dc2613753565b602002602001018181525050856020015184601581518110611de657611de6613753565b60200260200101819052508282820990508085601681518110611e0b57611e0b613753565b602002602001018181525050856040015184601681518110611e2f57611e2f613753565b60200260200101819052508282820990508085601781518110611e5457611e54613753565b602002602001018181525050856060015184601781518110611e7857611e78613753565b60200260200101819052508282820990508085601881518110611e9d57611e9d613753565b602002602001018181525050856080015184601881518110611ec157611ec1613753565b60200260200101819052508282820990508085601981518110611ee657611ee6613753565b602002602001018181525050886040015184601981518110611f0a57611f0a613753565b60200260200101819052508282820990508085601a81518110611f2f57611f2f613753565b602002602001018181525050886060015184601a81518110611f5357611f53613753565b60200260200101819052508282820990508085601b81518110611f7857611f78613753565b602002602001018181525050886080015184601b81518110611f9c57611f9c613753565b60200260200101819052508282820990508085601c81518110611fc157611fc1613753565b6020026020010181815250508860a0015184601c81518110611fe557611fe5613753565b60200260200101819052508282820990508760e0015185601d8151811061200e5761200e613753565b6020026020010181815250508560a0015184601d8151811061203257612032613753565b6020026020010181905250505050505050505050565b6000805160206138b18339815191528381039060005b600a81101561208f5760206015820102840151602082026101a001860151838482840986089450505060010161205e565b50509392505050565b61044d826120a58361237f565b6040516020016120b791815260200190565b604051602081830303815290604052611703565b6060816120d981601f6137b9565b10156121185760405162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b60448201526064016100bd565b61212282846137b9565b845110156121665760405162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b60448201526064016100bd565b60608215801561218557604051915060008252602082016040526121cf565b6040519150601f8416801560200281840101858101878315602002848b0101015b818310156121be5780518352602092830192016121a6565b5050858452601f01601f1916604052505b50949350505050565b6000805b8251811015612252576000805160206138b1833981519152610100830991506000805160206138b183398151915283826001865161221a9190613864565b6122249190613864565b8151811061223457612234613753565b016020015160f81c830891508061224a8161377f565b9150506121dc565b50919050565b612260612f7e565b612268612fb2565b835181526020808501519082015260408101839052600060608360808460076107d05a03fa905080801561002b5750806122e05760405162461bcd60e51b8152602060048201526019602482015278426e3235343a207363616c6172206d756c206661696c65642160381b60448201526064016100bd565b505092915050565b6122f0612f7e565b6122f8612fd0565b8351815260208085015181830152835160408301528301516060808301919091526000908360c08460066107d05a03fa905080801561002b5750806122e05760405162461bcd60e51b815260206004820152601d60248201527f426e3235343a2067726f7570206164646974696f6e206661696c65642100000060448201526064016100bd565b60008190506008817eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff16901b6008827fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff0016901c1790506010817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff16901b6010827dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff1916901c1790506020817bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16901b6020827bffffffff00000000ffffffff00000000ffffffff00000000ffffffff1916901c17905060408167ffffffffffffffff67ffffffffffffffff60801b0116901b60408267ffffffffffffffff67ffffffffffffffff60801b011916901c179050608081901b608082901c179050919050565b8051602082015160609160009115901516156124d757600160fe1b175b602083015160008051602061389183398151915260019190911b106124fd5750600160ff1b5b825161250a90821761237f565b60405160200161251c91815260200190565b604051602081830303815290604052915050919050565b60008060006000805160206138b1833981519152905060405160208152602080820152602060408201528460608201526002820360808201528160a08201526020600060c08360055afa9250506000519250816125d25760405162461bcd60e51b815260206004820152601d60248201527f426e3235343a20706f7720707265636f6d70696c65206661696c65642100000060448201526064016100bd565b5050919050565b60608281015160016000805160206138b1833981519152846001600160401b038111156126085761260861300c565b604051908082528060200260200182016040528015612631578160200160208202803683370190505b50935084151915611a915760208401856020028101600182526020820191505b8082101561266d57828585099350838252602082019150612651565b505050505092915050565b6000806000806000806000805160206138b183398151915290508060208b015160208d01510995508a5193508060a08c015160608d0151099250806101a08a0151840891508060808c015183089150808483099350807f2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a84099150806101c08a0151830891508060808c015183089150808483099350807f1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb02584099150806101e08a0151830891508060808c015183089150808483099350807f2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a84099150806102008a0151830891508060808c015183089150808483099350807f2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e88184099150806102208a0151830891508060808c0151830891508084830993508084870895508860a00151886000815181106127ef576127ef613753565b6020026020010181905250858760008151811061280e5761280e613753565b6020026020010181815250508060608c01518c51099450806102c08a015186099450806102408a015160608d0151099250806101a08a0151840892508060808c015184089250808386099450806102608a015160608d0151099250806101c08a0151840892508060808c015184089250808386099450806102808a015160608d0151099250806101e08a0151840892508060808c015184089250808386099450806102a08a015160608d0151099250806102008a0151840892508060808c0151840892508083860994508b60c00151886001815181106128f0576128f0613753565b60209081029190910101526129058582613864565b8760018151811061291857612918613753565b602002602001018181525050886101a001518760028151811061293d5761293d613753565b602002602001018181525050886101c001518760038151811061296257612962613753565b602002602001018181525050886101e001518760048151811061298757612987613753565b602002602001018181525050886102000151876005815181106129ac576129ac613753565b6020026020010181815250508b60e00151886002815181106129d0576129d0613753565b60200260200101819052508b6101000151886003815181106129f4576129f4613753565b60200260200101819052508b610120015188600481518110612a1857612a18613753565b60200260200101819052508b610140015188600581518110612a3c57612a3c613753565b6020026020010181905250806101c08a01516101a08b01510992508287600681518110612a6b57612a6b613753565b6020026020010181815250508b610160015188600681518110612a9057612a90613753565b6020026020010181905250806102008a01516101e08b01510992508287600781518110612abf57612abf613753565b6020026020010181815250508b610180015188600781518110612ae457612ae4613753565b60200260200101819052506101a089015192508083840991508082830991508082840992508287600881518110612b1d57612b1d613753565b6020026020010181815250508b6101e0015188600881518110612b4257612b42613753565b60200260200101819052506101c089015192508083840991508082830991508082840992508287600981518110612b7b57612b7b613753565b6020026020010181815250508b610200015188600981518110612ba057612ba0613753565b60200260200101819052506101e089015192508083840991508082830991508082840992508287600a81518110612bd957612bd9613753565b6020026020010181815250508b610220015188600a81518110612bfe57612bfe613753565b602002602001018190525061020089015192508083840991508082830991508082840992508287600b81518110612c3757612c37613753565b6020026020010181815250508b610240015188600b81518110612c5c57612c5c613753565b602002602001018190525088610220015181612c789190613864565b87600c81518110612c8b57612c8b613753565b6020026020010181815250508b6101a0015188600c81518110612cb057612cb0613753565b6020026020010181905250600187600d81518110612cd057612cd0613753565b6020026020010181815250508b6101c0015188600d81518110612cf557612cf5613753565b6020026020010181905250806101c08a01516101a08b0151099250806101e08a015184099250806102008a015184099250806102208a0151840992508287600e81518110612d4557612d45613753565b6020026020010181815250508b610260015188600e81518110612d6a57612d6a613753565b60209081029190910101528951612d819082613864565b87600f81518110612d9457612d94613753565b6020026020010181815250508860c0015188600f81518110612db857612db8613753565b60200260200101819052508060018b510860a08c0151909350819080099150808284099250808360206010028901510991508187601081518110612dfe57612dfe613753565b6020026020010181815250508860e0015188601081518110612e2257612e22613753565b6020026020010181905250808360206011028901510991508187601181518110612e4e57612e4e613753565b60200260200101818152505088610100015188601181518110612e7357612e73613753565b6020026020010181905250808360206012028901510991508187601281518110612e9f57612e9f613753565b60200260200101818152505088610120015188601281518110612ec457612ec4613753565b6020026020010181905250808360206013028901510991508187601381518110612ef057612ef0613753565b60200260200101818152505088610140015188601381518110612f1557612f15613753565b6020026020010181905250505050505050505050505050565b604051806101000160405280600081526020016000815260200160008152602001600081526020016060815260200160608152602001612f6c612f7e565b8152602001612f79612f7e565b905290565b604051806040016040528060008152602001600081525090565b604051806040016040528060608152602001612f79612fee565b60405180606001604052806003906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b60405180604001604052806002906020820280368337509192915050565b634e487b7160e01b600052604160045260246000fd5b6040516102e081016001600160401b03811182821017156130455761304561300c565b60405290565b60405161028081016001600160401b03811182821017156130455761304561300c565b604051601f8201601f191681016001600160401b03811182821017156130965761309661300c565b604052919050565b60006001600160401b038211156130b7576130b761300c565b5060051b60200190565b6000604082840312156130d357600080fd5b604051604081018181106001600160401b03821117156130f5576130f561300c565b604052823581526020928301359281019290925250919050565b600082601f83011261312057600080fd5b813560206131356131308361309e565b61306e565b828152600592831b850182019282820191908785111561315457600080fd5b8387015b858110156131e75780356001600160401b038111156131775760008081fd5b8801603f81018a136131895760008081fd5b85810135604061319b6131308361309e565b82815291851b8301810191888101908d8411156131b85760008081fd5b938201935b838510156131d6578435825293890193908901906131bd565b885250505093850193508401613158565b5090979650505050505050565b600082601f83011261320557600080fd5b81356132136131308261309e565b80828252602082019150610480602081850287010193508684111561323757600080fd5b602086015b848110156133e2578181890312156132545760008081fd5b61325c613022565b61326689836130c1565b815260406132768a8285016130c1565b602083015260806132898b8286016130c1565b8284015260c0915061329d8b8386016130c1565b60608401526101006132b18c8287016130c1565b8285015261014091506132c68c8387016130c1565b60a08501526101806132da8d8288016130c1565b848601526101c093506132ef8d8588016130c1565b60e08601526102006133038e8289016130c1565b8387015261024092506133188e8489016130c1565b61012087015261028061332d8f828a016130c1565b858801526102c094506133428f868a016130c1565b6101608801526133568f6103008a016130c1565b838801526103408801356101a0880152610360880135868801526103808801356101e08801526103a0880135828801526103c08801356102208801526103e08801358488015261040088013561026088015261042088013581880152505050506104408401356102a084015261046084013581840152505080855250602084019350818101905061323c565b50909695505050505050565b6000601f838184011261340057600080fd5b823560206134106131308361309e565b82815260059290921b8501810191818101908784111561342f57600080fd5b8287015b848110156134c55780356001600160401b03808211156134535760008081fd5b818a0191508a603f8301126134685760008081fd5b8582013560408282111561347e5761347e61300c565b61348f828b01601f1916890161306e565b92508183528c818386010111156134a65760008081fd5b8181850189850137506000908201870152845250918301918301613433565b50979650505050505050565b600080600080608085870312156134e757600080fd5b84356001600160401b03808211156134fe57600080fd5b818701915087601f83011261351257600080fd5b813560206135226131308361309e565b8281526104c0928302850182019282820191908c85111561354257600080fd5b958301955b848710156136df5780878e03121561355e57600080fd5b61356661304b565b87358152848801358582015261357f8e60408a016130c1565b60408201526135918e60808a016130c1565b60608201526135a38e60c08a016130c1565b60808201526135b68e6101008a016130c1565b60a08201526135c98e6101408a016130c1565b60c08201526135dc8e6101808a016130c1565b60e08201526135ef8e6101c08a016130c1565b6101008201526136038e6102008a016130c1565b6101208201526102406136188f828b016130c1565b61014083015261362c8f6102808b016130c1565b6101608301526136408f6102c08b016130c1565b6101808301526136548f6103008b016130c1565b6101a08301526136688f6103408b016130c1565b6101c083015261367c8f6103808b016130c1565b6101e08301526136908f6103c08b016130c1565b6102008301526136a48f6104008b016130c1565b6102208301526136b88f6104408b016130c1565b908201526136ca8e6104808a016130c1565b61026082015283529586019591830191613547565b50985050880135925050808211156136f657600080fd5b6137028883890161310f565b9450604087013591508082111561371857600080fd5b613724888389016131f4565b9350606087013591508082111561373a57600080fd5b50613747878288016133ee565b91505092959194509250565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060001982141561379357613793613769565b5060010190565b60008160001904831182151516156137b4576137b4613769565b500290565b600082198211156137cc576137cc613769565b500190565b6000815160005b818110156137f257602081850181015186830152016137d8565b81811115613801576000828601525b509290920192915050565b848152836020820152600061382460408301856137d1565b60f89390931b6001600160f81b031916835250506001019392505050565b60008261385f57634e487b7160e01b600052601260045260246000fd5b500690565b60008282101561387657613876613769565b500390565b60006102bc61388a83866137d1565b846137d156fe30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4730644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001a2646970667358221220e2c3014eba58a65b33e9433c6a0e7d5e4b930de442ea32d147e02df2f4d9d0b664736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063830affd614610030575b600080fd5b61004361003e3660046134d1565b610057565b604051901515815260200160405180910390f35b60008251855114801561006b575082518451145b8015610078575082518251145b6100c65760405162461bcd60e51b815260206004820152601a602482015279506c6f6e6b3a20696e76616c696420696e70757420706172616d60301b60448201526064015b60405180910390fd5b60008351116101165760405162461bcd60e51b815260206004820152601c60248201527b283637b7359d103732b2b21030ba103632b0b9ba101890383937b7b360211b60448201526064016100bd565b600083516001600160401b038111156101315761013161300c565b60405190808252806020026020018201604052801561016a57816020015b610157612f2e565b81526020019060019003908161014f5790505b50905060005b84518110156102ae5761019b85828151811061018e5761018e613753565b60200260200101516102c4565b60005b8682815181106101b0576101b0613753565b60200260200101515181101561020d576101fb8783815181106101d5576101d5613753565b602002602001015182815181106101ee576101ee613753565b60200260200101516103f1565b806102058161377f565b91505061019e565b5061027e87828151811061022357610223613753565b602002602001015187838151811061023d5761023d613753565b602002602001015187848151811061025757610257613753565b602002602001015187858151811061027157610271613753565b6020026020010151610451565b82828151811061029057610290613753565b602002602001018190525080806102a69061377f565b915050610170565b506102b8816105c9565b9150505b949350505050565b80516102cf90610ca0565b6102dc8160200151610ca0565b6102e98160400151610ca0565b6102f68160600151610ca0565b6103038160800151610ca0565b6103108160a00151610ca0565b61031d8160c00151610ca0565b61032a8160e00151610ca0565b610338816101000151610ca0565b610346816101200151610ca0565b610354816101400151610ca0565b610362816101600151610ca0565b610370816101a001516103f1565b61037e816101c001516103f1565b61038c816101e001516103f1565b61039a8161020001516103f1565b6103a88161022001516103f1565b6103b68161024001516103f1565b6103c48161026001516103f1565b6103d28161028001516103f1565b6103e0816102a001516103f1565b6103ee816102c001516103f1565b50565b6000805160206138b183398151915281108061044d5760405162461bcd60e51b815260206004820152601b60248201527a109b8c8d4d0e881a5b9d985b1a59081cd8d85b185c88199a595b19602a1b60448201526064016100bd565b5050565b610459612f2e565b84602001518451146104aa5760405162461bcd60e51b815260206004820152601a602482015279506c6f6e6b3a2077726f6e6720766572696679696e67206b657960301b60448201526064016100bd565b60006104b886868686610d29565b905060006104c98760000151610ef7565b905060006104dc828460a00151896111c5565b60408051601e8082526103e0820190925291925060009190602082016103c080368337505060408051601e8082526103e082019092529293506000929150602082015b610527612f7e565b81526020019060019003908161051f579050509050600061054c8b858b898787611225565b60a08701516060870151919250906000805160206138b1833981519152600081838509604080516101008101825260e09c8d0151815260208101969096528501525050506060810191909152608081019290925260a082015261016087015160c08201526101809096015192860192909252509295945050505050565b80516000906000805160206138b183398151915260018083111561064a576105ef612f98565b60005b8481101561063c5761062a87828151811061060f5761060f613753565b6020026020010151600001518361125a90919063ffffffff16565b806106348161377f565b9150506105f2565b5061064681611264565b9150505b610652612f7e565b61065a612f7e565b600061066786600261379a565b6001600160401b0381111561067e5761067e61300c565b6040519080825280602002602001820160405280156106a7578160200160208202803683370190505b50905060006106b787600261379a565b6001600160401b038111156106ce576106ce61300c565b60405190808252806020026020018201604052801561070757816020015b6106f4612f7e565b8152602001906001900390816106ec5790505b509050600160005b8881101561085057818461072483600261379a565b8151811061073457610734613753565b6020026020010181815250508a818151811061075257610752613753565b602002602001015160c001518382600261076c919061379a565b8151811061077c5761077c613753565b60200260200101819052506000808c838151811061079c5761079c613753565b602002602001015160000151905089818509915081866107bd85600261379a565b6107c89060016137b9565b815181106107d8576107d8613753565b60200260200101818152505050508a81815181106107f8576107f8613753565b602002602001015160e0015183826002610812919061379a565b61081d9060016137b9565b8151811061082d5761082d613753565b6020026020010181905250878783099150806108488161377f565b91505061070f565b5061085b8284611391565b945050505060608060008960008151811061087857610878613753565b60200260200101516080015151905060008a5182600261089891906137b9565b6108a2919061379a565b6108ad9060016137b9565b9050806001600160401b038111156108c7576108c761300c565b6040519080825280602002602001820160405280156108f0578160200160208202803683370190505b509350806001600160401b0381111561090b5761090b61300c565b60405190808252806020026020018201604052801561094457816020015b610931612f7e565b8152602001906001900390816109295790505b509250600091508190506001815b8c51811015610bee5760005b8d60008151811061097157610971613753565b60200260200101516080015151811015610a5c5760008e838151811061099957610999613753565b60200260200101516080015182815181106109b6576109b6613753565b6020026020010151905060008c8286099050808987815181106109db576109db613753565b60200260200101818152505050508d82815181106109fb576109fb613753565b602002602001015160a001518181518110610a1857610a18613753565b6020026020010151868581518110610a3257610a32613753565b6020908102919091010152610a486001856137b9565b935080610a548161377f565b91505061095e565b5060008d8281518110610a7157610a71613753565b602002602001015160200151905060008b828509905080888681518110610a9a57610a9a613753565b60200260200101818152505050508c8181518110610aba57610aba613753565b602002602001015160c00151858481518110610ad857610ad8613753565b6020908102919091010152610aee6001846137b9565b925060008d8281518110610b0457610b04613753565b602002602001015160000151905060008e8381518110610b2657610b26613753565b602002602001015160400151905060008c8d8385098609905080898781518110610b5257610b52613753565b6020026020010181815250505050508c8181518110610b7357610b73613753565b602002602001015160e00151858481518110610b9157610b91613753565b6020908102919091010152610ba76001846137b9565b925060008d8281518110610bbd57610bbd613753565b60200260200101516060015190508a8b828509860894508a8a84099250508080610be69061377f565b915050610952565b50610bf883611489565b858381518110610c0a57610c0a613753565b602002602001018181525050610c1e6114c1565b848381518110610c3057610c30613753565b6020026020010181905250610c4d610c488587611391565b6114e2565b6040805160808101825260005481526001546020820152600254918101919091526003546060820152909650610c9595508794509250859150610c909050611551565b611622565b979650505050505050565b8051602082015160009160008051602061389183398151915291826003818085800985090883828309148115831517198483108585101616169350505081610d245760405162461bcd60e51b8152602060048201526017602482015276109b8c8d4d0e881a5b9d985b1a590811cc481c1bda5b9d604a1b60448201526064016100bd565b505050565b610d7160405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b610d79612f98565b6000805160206138b1833981519152610d928285611703565b610d9d82888861172d565b8451610daa908390611999565b6020850151610dba908390611999565b6040850151610dca908390611999565b6060850151610dda908390611999565b6080850151610dea908390611999565b610df382611264565b50610dfd82611264565b6060840152610e0b82611264565b608084015260a0850151610e20908390611999565b610e2982611264565b835260c0850151610e3b908390611999565b60e0850151610e4b908390611999565b610100850151610e5c908390611999565b610120850151610e6d908390611999565b610140850151610e7e908390611999565b610e8782611264565b60a0840152610e9682866119b0565b610e9f82611264565b60c0840152610160850151610eb5908390611999565b610180850151610ec6908390611999565b610ecf82611264565b60e0840152825181818009828282096020860191909152604085015250919695505050505050565b610f296040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b816140001415610fbe57506040805160a081018252600e815260208101929092527f30638ce1a7661b6337a964756aa75257c6bf4778d89789ab819ce60c19b04001908201527f2d965651cdd9e4811f4e51b80ddca8a8b4a93ee17420aae6adaa01c2617c6e8560608201527f281c036f06e7e9e911680d42558e6e8cf40976b0677771c0f8eee934641c8410608082015290565b81618000141561105357506040805160a081018252600f815260208101929092527f3063edaa444bddc677fcd515f614555a777997e0a9287d1e62bf6dd004d82001908201527f2d1ba66f5941dc91017171fa69ec2bd0022a2a2d4115a009a93458fd4e26ecfb60608201527f05d33766e4590b3722701b6f2fa43d0dc3f028424d384e68c92a742fb2dbc0b4608082015290565b816201000014156110e857506040805160a0810182526010815260208101929092527f30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001908201527eeeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b760608201527f0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4608082015290565b8162020000141561117e57506040805160a0810182526011815260208101929092527f30643640b9f82f90e83b698e5ea6179c7c05542e859533b48b9953a2f5360801908201527f1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e560608201527f244cf010c43ca87237d8b00bf9dd50c4c01c7f086bd4e8c920e75251d96f0d22608082015290565b60405162461bcd60e51b815260206004820152601c60248201527b506f6c793a2073697a65206d75737420696e20325e7b31347e31377d60201b60448201526064016100bd565b6111e960405180606001604052806000815260200160008152602001600081525090565b6111f38484611a46565b8082526112039085908590611a9a565b6020820152805161121990859084908690611afd565b60408201529392505050565b600080611233858789611c50565b9050611243888689898888611d3c565b61124e818786612048565b98975050505050505050565b61044d8282612098565b6020818101518051908201518351604051600094859461128c9490939092909186910161380c565b604051602081830303815290604052805190602001209050600083602001516000600281106112bd576112bd613753565b602002015184602001516001600281106112d9576112d9613753565b6020020151856000015160016040516020016112f8949392919061380c565b60405160208183030381529060405280519060200120905081846020015160006002811061132857611328613753565b60200201818152505080846020015160016002811061134957611349613753565b6020020181815250506102bc61138c8383604051602001611374929190918252602082015260400190565b604051602081830303815290604052600060306120cb565b6121d8565b611399612f7e565b82518251146113ea5760405162461bcd60e51b815260206004820181905260248201527f4d534d206572726f723a206c656e67746820646f6573206e6f74206d6174636860448201526064016100bd565b6114288360008151811061140057611400613753565b60200260200101518360008151811061141b5761141b613753565b6020026020010151612258565b905060015b82518110156114825761146e8261146986848151811061144f5761144f613753565b602002602001015186858151811061141b5761141b613753565b6122e8565b91508061147a8161377f565b91505061142d565b5092915050565b60006114a36000805160206138b183398151915283613842565b6114bb906000805160206138b1833981519152613864565b92915050565b6114c9612f7e565b5060408051808201909152600181526002602082015290565b6114ea612f7e565b8151602083015115901516156114fe575090565b60405180604001604052808360000151815260200160008051602061389183398151915284602001516115319190613842565b61154990600080516020613891833981519152613864565b905292915050565b61157c6040518060800160405280600081526020016000815260200160008152602001600081525090565b60405180608001604052807f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c281526020017f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed81526020017f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81526020017f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa815250905090565b60008060006040518751815260208801516020820152865160408201526020870151606082015260408701516080820152606087015160a0820152855160c0820152602086015160e08201528451610100820152602085015161012082015260408501516101408201526060850151610160820152602060006101808360085afa9150506000519150806116f75760405162461bcd60e51b815260206004820152601c60248201527b426e3235343a2050616972696e6720636865636b206661696c65642160201b60448201526064016100bd565b50151595945050505050565b81516040516117179190839060200161387b565b60408051601f1981840301815291905290915250565b60fe61176e8461176961173f8461237f565b60405160200161175191815260200190565b604051602081830303815290604052600060086120cb565b611703565b6117828461176961173f866000015161237f565b6117968461176961173f866020015161237f565b6117a1846001612098565b6117cb847f2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a612098565b6117f5847f1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb025612098565b61181f847f2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a612098565b611849847f2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e881612098565b611857848460e00151611999565b61186684846101000151611999565b61187584846101200151611999565b61188484846101400151611999565b61189384846101600151611999565b6118a284846101800151611999565b6118b184846101e00151611999565b6118c084846102000151611999565b6118cf84846102200151611999565b6118de84846102400151611999565b6118ed84846101a00151611999565b6118fc84846101c00151611999565b61190b84846102600151611999565b611919848460400151611999565b611927848460600151611999565b611935848460800151611999565b611943848460a00151611999565b611951848460c00151611999565b60005b8251811015611992576119808584838151811061197357611973613753565b6020026020010151612098565b8061198a8161377f565b915050611954565b5050505050565b60006119a4826124ba565b9050610d248382611703565b6119bf82826101a00151612098565b6119ce82826101c00151612098565b6119dd82826101e00151612098565b6119ec82826102000151612098565b6119fb82826102200151612098565b611a0a82826102400151612098565b611a1982826102600151612098565b611a2882826102800151612098565b611a3782826102a00151612098565b61044d82826102c00151612098565b81516000906000805160206138b183398151915290838015611a8a5784935060005b82811015611a7e57838586099450600101611a68565b50600184039350611a91565b6001830393505b50505092915050565b600081611aa957506000611af6565b60408401516000805160206138b183398151915290600090828186099050858015611ad957600187039250611ae0565b6001840392505b50611aea82612533565b91508282820993505050505b9392505050565b600081611b0c575060006102bc565b835160408601516000805160206138b18339815191529190600090819081908180611b378d886125d9565b90506000876001600160401b03811115611b5357611b5361300c565b604051908082528060200260200182016040528015611b7c578160200160208202803683370190505b509050888b850993506001925060005b88811015611bc157602081026020840101519550898d878c030896508987850960208281028401018890529350600101611b8c565b50611bcb83612533565b925060005b88811015611c3e5760208102602084010151955089868609975089848909975060005b89811015611c1d57808214611c15576020810260208401015197508a888a0998505b600101611bf3565b506020810260208f010151955089868909975089888c089a50600101611bd0565b50505050505050505050949350505050565b6000806000805160206138b18339815191529050600083602001519050600084604001519050600060019050606088015160808901516101a08901516102408a0151878889838709858501088609945050506101c08901516102608a0151878889838709858501088609945050506101e08901516102808a0151878889838709858501088609945050506102008901516102a08a01518788898387098585010886099450505061022089015191506102c0890151868782898587080985099350505050875160208901518586868309870385089650508485838309860387089998505050505050505050565b611d4a868686868587612678565b60c085015182516000805160206138b183398151915291908190819086906014908110611d7957611d79613753565b602002602001018181525050856000015184601481518110611d9d57611d9d613753565b60200260200101819052508282820990508085601581518110611dc257611dc2613753565b602002602001018181525050856020015184601581518110611de657611de6613753565b60200260200101819052508282820990508085601681518110611e0b57611e0b613753565b602002602001018181525050856040015184601681518110611e2f57611e2f613753565b60200260200101819052508282820990508085601781518110611e5457611e54613753565b602002602001018181525050856060015184601781518110611e7857611e78613753565b60200260200101819052508282820990508085601881518110611e9d57611e9d613753565b602002602001018181525050856080015184601881518110611ec157611ec1613753565b60200260200101819052508282820990508085601981518110611ee657611ee6613753565b602002602001018181525050886040015184601981518110611f0a57611f0a613753565b60200260200101819052508282820990508085601a81518110611f2f57611f2f613753565b602002602001018181525050886060015184601a81518110611f5357611f53613753565b60200260200101819052508282820990508085601b81518110611f7857611f78613753565b602002602001018181525050886080015184601b81518110611f9c57611f9c613753565b60200260200101819052508282820990508085601c81518110611fc157611fc1613753565b6020026020010181815250508860a0015184601c81518110611fe557611fe5613753565b60200260200101819052508282820990508760e0015185601d8151811061200e5761200e613753565b6020026020010181815250508560a0015184601d8151811061203257612032613753565b6020026020010181905250505050505050505050565b6000805160206138b18339815191528381039060005b600a81101561208f5760206015820102840151602082026101a001860151838482840986089450505060010161205e565b50509392505050565b61044d826120a58361237f565b6040516020016120b791815260200190565b604051602081830303815290604052611703565b6060816120d981601f6137b9565b10156121185760405162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b60448201526064016100bd565b61212282846137b9565b845110156121665760405162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b60448201526064016100bd565b60608215801561218557604051915060008252602082016040526121cf565b6040519150601f8416801560200281840101858101878315602002848b0101015b818310156121be5780518352602092830192016121a6565b5050858452601f01601f1916604052505b50949350505050565b6000805b8251811015612252576000805160206138b1833981519152610100830991506000805160206138b183398151915283826001865161221a9190613864565b6122249190613864565b8151811061223457612234613753565b016020015160f81c830891508061224a8161377f565b9150506121dc565b50919050565b612260612f7e565b612268612fb2565b835181526020808501519082015260408101839052600060608360808460076107d05a03fa905080801561002b5750806122e05760405162461bcd60e51b8152602060048201526019602482015278426e3235343a207363616c6172206d756c206661696c65642160381b60448201526064016100bd565b505092915050565b6122f0612f7e565b6122f8612fd0565b8351815260208085015181830152835160408301528301516060808301919091526000908360c08460066107d05a03fa905080801561002b5750806122e05760405162461bcd60e51b815260206004820152601d60248201527f426e3235343a2067726f7570206164646974696f6e206661696c65642100000060448201526064016100bd565b60008190506008817eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff16901b6008827fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff0016901c1790506010817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff16901b6010827dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff1916901c1790506020817bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16901b6020827bffffffff00000000ffffffff00000000ffffffff00000000ffffffff1916901c17905060408167ffffffffffffffff67ffffffffffffffff60801b0116901b60408267ffffffffffffffff67ffffffffffffffff60801b011916901c179050608081901b608082901c179050919050565b8051602082015160609160009115901516156124d757600160fe1b175b602083015160008051602061389183398151915260019190911b106124fd5750600160ff1b5b825161250a90821761237f565b60405160200161251c91815260200190565b604051602081830303815290604052915050919050565b60008060006000805160206138b1833981519152905060405160208152602080820152602060408201528460608201526002820360808201528160a08201526020600060c08360055afa9250506000519250816125d25760405162461bcd60e51b815260206004820152601d60248201527f426e3235343a20706f7720707265636f6d70696c65206661696c65642100000060448201526064016100bd565b5050919050565b60608281015160016000805160206138b1833981519152846001600160401b038111156126085761260861300c565b604051908082528060200260200182016040528015612631578160200160208202803683370190505b50935084151915611a915760208401856020028101600182526020820191505b8082101561266d57828585099350838252602082019150612651565b505050505092915050565b6000806000806000806000805160206138b183398151915290508060208b015160208d01510995508a5193508060a08c015160608d0151099250806101a08a0151840891508060808c015183089150808483099350807f2f8dd1f1a7583c42c4e12a44e110404c73ca6c94813f85835da4fb7bb1301d4a84099150806101c08a0151830891508060808c015183089150808483099350807f1ee678a0470a75a6eaa8fe837060498ba828a3703b311d0f77f010424afeb02584099150806101e08a0151830891508060808c015183089150808483099350807f2042a587a90c187b0a087c03e29c968b950b1db26d5c82d666905a6895790c0a84099150806102008a0151830891508060808c015183089150808483099350807f2e2b91456103698adf57b799969dea1c8f739da5d8d40dd3eb9222db7c81e88184099150806102208a0151830891508060808c0151830891508084830993508084870895508860a00151886000815181106127ef576127ef613753565b6020026020010181905250858760008151811061280e5761280e613753565b6020026020010181815250508060608c01518c51099450806102c08a015186099450806102408a015160608d0151099250806101a08a0151840892508060808c015184089250808386099450806102608a015160608d0151099250806101c08a0151840892508060808c015184089250808386099450806102808a015160608d0151099250806101e08a0151840892508060808c015184089250808386099450806102a08a015160608d0151099250806102008a0151840892508060808c0151840892508083860994508b60c00151886001815181106128f0576128f0613753565b60209081029190910101526129058582613864565b8760018151811061291857612918613753565b602002602001018181525050886101a001518760028151811061293d5761293d613753565b602002602001018181525050886101c001518760038151811061296257612962613753565b602002602001018181525050886101e001518760048151811061298757612987613753565b602002602001018181525050886102000151876005815181106129ac576129ac613753565b6020026020010181815250508b60e00151886002815181106129d0576129d0613753565b60200260200101819052508b6101000151886003815181106129f4576129f4613753565b60200260200101819052508b610120015188600481518110612a1857612a18613753565b60200260200101819052508b610140015188600581518110612a3c57612a3c613753565b6020026020010181905250806101c08a01516101a08b01510992508287600681518110612a6b57612a6b613753565b6020026020010181815250508b610160015188600681518110612a9057612a90613753565b6020026020010181905250806102008a01516101e08b01510992508287600781518110612abf57612abf613753565b6020026020010181815250508b610180015188600781518110612ae457612ae4613753565b60200260200101819052506101a089015192508083840991508082830991508082840992508287600881518110612b1d57612b1d613753565b6020026020010181815250508b6101e0015188600881518110612b4257612b42613753565b60200260200101819052506101c089015192508083840991508082830991508082840992508287600981518110612b7b57612b7b613753565b6020026020010181815250508b610200015188600981518110612ba057612ba0613753565b60200260200101819052506101e089015192508083840991508082830991508082840992508287600a81518110612bd957612bd9613753565b6020026020010181815250508b610220015188600a81518110612bfe57612bfe613753565b602002602001018190525061020089015192508083840991508082830991508082840992508287600b81518110612c3757612c37613753565b6020026020010181815250508b610240015188600b81518110612c5c57612c5c613753565b602002602001018190525088610220015181612c789190613864565b87600c81518110612c8b57612c8b613753565b6020026020010181815250508b6101a0015188600c81518110612cb057612cb0613753565b6020026020010181905250600187600d81518110612cd057612cd0613753565b6020026020010181815250508b6101c0015188600d81518110612cf557612cf5613753565b6020026020010181905250806101c08a01516101a08b0151099250806101e08a015184099250806102008a015184099250806102208a0151840992508287600e81518110612d4557612d45613753565b6020026020010181815250508b610260015188600e81518110612d6a57612d6a613753565b60209081029190910101528951612d819082613864565b87600f81518110612d9457612d94613753565b6020026020010181815250508860c0015188600f81518110612db857612db8613753565b60200260200101819052508060018b510860a08c0151909350819080099150808284099250808360206010028901510991508187601081518110612dfe57612dfe613753565b6020026020010181815250508860e0015188601081518110612e2257612e22613753565b6020026020010181905250808360206011028901510991508187601181518110612e4e57612e4e613753565b60200260200101818152505088610100015188601181518110612e7357612e73613753565b6020026020010181905250808360206012028901510991508187601281518110612e9f57612e9f613753565b60200260200101818152505088610120015188601281518110612ec457612ec4613753565b6020026020010181905250808360206013028901510991508187601381518110612ef057612ef0613753565b60200260200101818152505088610140015188601381518110612f1557612f15613753565b6020026020010181905250505050505050505050505050565b604051806101000160405280600081526020016000815260200160008152602001600081526020016060815260200160608152602001612f6c612f7e565b8152602001612f79612f7e565b905290565b604051806040016040528060008152602001600081525090565b604051806040016040528060608152602001612f79612fee565b60405180606001604052806003906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b60405180604001604052806002906020820280368337509192915050565b634e487b7160e01b600052604160045260246000fd5b6040516102e081016001600160401b03811182821017156130455761304561300c565b60405290565b60405161028081016001600160401b03811182821017156130455761304561300c565b604051601f8201601f191681016001600160401b03811182821017156130965761309661300c565b604052919050565b60006001600160401b038211156130b7576130b761300c565b5060051b60200190565b6000604082840312156130d357600080fd5b604051604081018181106001600160401b03821117156130f5576130f561300c565b604052823581526020928301359281019290925250919050565b600082601f83011261312057600080fd5b813560206131356131308361309e565b61306e565b828152600592831b850182019282820191908785111561315457600080fd5b8387015b858110156131e75780356001600160401b038111156131775760008081fd5b8801603f81018a136131895760008081fd5b85810135604061319b6131308361309e565b82815291851b8301810191888101908d8411156131b85760008081fd5b938201935b838510156131d6578435825293890193908901906131bd565b885250505093850193508401613158565b5090979650505050505050565b600082601f83011261320557600080fd5b81356132136131308261309e565b80828252602082019150610480602081850287010193508684111561323757600080fd5b602086015b848110156133e2578181890312156132545760008081fd5b61325c613022565b61326689836130c1565b815260406132768a8285016130c1565b602083015260806132898b8286016130c1565b8284015260c0915061329d8b8386016130c1565b60608401526101006132b18c8287016130c1565b8285015261014091506132c68c8387016130c1565b60a08501526101806132da8d8288016130c1565b848601526101c093506132ef8d8588016130c1565b60e08601526102006133038e8289016130c1565b8387015261024092506133188e8489016130c1565b61012087015261028061332d8f828a016130c1565b858801526102c094506133428f868a016130c1565b6101608801526133568f6103008a016130c1565b838801526103408801356101a0880152610360880135868801526103808801356101e08801526103a0880135828801526103c08801356102208801526103e08801358488015261040088013561026088015261042088013581880152505050506104408401356102a084015261046084013581840152505080855250602084019350818101905061323c565b50909695505050505050565b6000601f838184011261340057600080fd5b823560206134106131308361309e565b82815260059290921b8501810191818101908784111561342f57600080fd5b8287015b848110156134c55780356001600160401b03808211156134535760008081fd5b818a0191508a603f8301126134685760008081fd5b8582013560408282111561347e5761347e61300c565b61348f828b01601f1916890161306e565b92508183528c818386010111156134a65760008081fd5b8181850189850137506000908201870152845250918301918301613433565b50979650505050505050565b600080600080608085870312156134e757600080fd5b84356001600160401b03808211156134fe57600080fd5b818701915087601f83011261351257600080fd5b813560206135226131308361309e565b8281526104c0928302850182019282820191908c85111561354257600080fd5b958301955b848710156136df5780878e03121561355e57600080fd5b61356661304b565b87358152848801358582015261357f8e60408a016130c1565b60408201526135918e60808a016130c1565b60608201526135a38e60c08a016130c1565b60808201526135b68e6101008a016130c1565b60a08201526135c98e6101408a016130c1565b60c08201526135dc8e6101808a016130c1565b60e08201526135ef8e6101c08a016130c1565b6101008201526136038e6102008a016130c1565b6101208201526102406136188f828b016130c1565b61014083015261362c8f6102808b016130c1565b6101608301526136408f6102c08b016130c1565b6101808301526136548f6103008b016130c1565b6101a08301526136688f6103408b016130c1565b6101c083015261367c8f6103808b016130c1565b6101e08301526136908f6103c08b016130c1565b6102008301526136a48f6104008b016130c1565b6102208301526136b88f6104408b016130c1565b908201526136ca8e6104808a016130c1565b61026082015283529586019591830191613547565b50985050880135925050808211156136f657600080fd5b6137028883890161310f565b9450604087013591508082111561371857600080fd5b613724888389016131f4565b9350606087013591508082111561373a57600080fd5b50613747878288016133ee565b91505092959194509250565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060001982141561379357613793613769565b5060010190565b60008160001904831182151516156137b4576137b4613769565b500290565b600082198211156137cc576137cc613769565b500190565b6000815160005b818110156137f257602081850181015186830152016137d8565b81811115613801576000828601525b509290920192915050565b848152836020820152600061382460408301856137d1565b60f89390931b6001600160f81b031916835250506001019392505050565b60008261385f57634e487b7160e01b600052601260045260246000fd5b500690565b60008282101561387657613876613769565b500390565b60006102bc61388a83866137d1565b846137d156fe30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4730644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001a2646970667358221220e2c3014eba58a65b33e9433c6a0e7d5e4b930de442ea32d147e02df2f4d9d0b664736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "batchVerify((uint256,uint256,(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256))[],uint256[][],((uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)[],bytes[])": {
        "details": "Batch verify multiple TurboPlonk proofs.",
        "params": {
          "extraTranscriptInitMsgs": "An array of bytes from transcript initialization messages",
          "proofs": "An array of Plonk proofs",
          "publicInputs": "A two-dimensional array of public inputs.",
          "verifyingKeys": "An array of verifier keys"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11591,
        "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
        "label": "_betaH",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(G2Point)5868_storage"
      }
    ],
    "types": {
      "t_struct(G2Point)5868_storage": {
        "encoding": "inplace",
        "label": "struct BN254.G2Point",
        "members": [
          {
            "astId": 5861,
            "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
            "label": "x0",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 5863,
            "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
            "label": "x1",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 5865,
            "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
            "label": "y0",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 5867,
            "contract": "contracts/verifier/PlonkVerifier.sol:PlonkVerifier",
            "label": "y1",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}