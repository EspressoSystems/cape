{
  "address": "0x2978AB8E662396CBBDC5D201388178faEBAbD716",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "subtractedValue",
          "type": "uint256"
        }
      ],
      "name": "decreaseAllowance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "addedValue",
          "type": "uint256"
        }
      ],
      "name": "increaseAllowance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "selectDepositAttack",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "selectSubmitBlockAttack",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "targetContractAddress",
          "type": "address"
        }
      ],
      "name": "setTargetContractAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xa582319a84bf8b01875e944d2a0477adebe9c4dc788276a0454ff9a07bcedfa4",
  "receipt": {
    "to": null,
    "from": "0x2FB18F4b4519a5fc792cb6508C6505675BA659E9",
    "contractAddress": "0x2978AB8E662396CBBDC5D201388178faEBAbD716",
    "transactionIndex": 3,
    "gasUsed": "1080420",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0468e32ed658e2cd6a799bbf00c772ad4da3b27af1e6bb7497212f542e7fb028",
    "transactionHash": "0xa582319a84bf8b01875e944d2a0477adebe9c4dc788276a0454ff9a07bcedfa4",
    "logs": [],
    "blockNumber": 6600721,
    "cumulativeGasUsed": "4579220",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "4562b65aed9d47b1fb3c1971213274b0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selectDepositAttack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selectSubmitBlockAttack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetContractAddress\",\"type\":\"address\"}],\"name\":\"setTargetContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"See {IERC20-allowance}.\"},\"approve(address,uint256)\":{\"details\":\"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.\"},\"balanceOf(address)\":{\"details\":\"See {IERC20-balanceOf}.\"},\"decimals()\":{\"details\":\"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.\"},\"decreaseAllowance(address,uint256)\":{\"details\":\"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.\"},\"increaseAllowance(address,uint256)\":{\"details\":\"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.\"},\"name()\":{\"details\":\"Returns the name of the token.\"},\"selectDepositAttack()\":{\"details\":\"pick the depositErc20 function when calling back the CAPE contract\"},\"selectSubmitBlockAttack()\":{\"details\":\"pick the submitBlock function when calling back the CAPE contract\"},\"setTargetContractAddress(address)\":{\"details\":\"Sets the address for performing the reentrancy attack.\"},\"symbol()\":{\"details\":\"Returns the symbol of the token, usually a shorter version of the name.\"},\"totalSupply()\":{\"details\":\"See {IERC20-totalSupply}.\"},\"transfer(address,uint256)\":{\"details\":\"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"MaliciousToken contract constructor.\"},\"transferFrom(address,address,uint256)\":{\"notice\":\"Malicious implementation of transferFrom\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MaliciousToken.sol\":\"MaliciousToken\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x842ccf9a6cd33e17b7acef8372ca42090755217b358fe0c44c98e951ea549d3a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xb03df8481a954604ad0c9125680893b2e3f7ff770fe470e38b89ac61b84e8072\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x83fe24f5c04a56091e50f4a345ff504c8bff658a76d4c43b16878c8f940c53b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x698cdbf614109fafc2bf00057b60715fa3aba9dad447c42f4f8b749ae16ce84f\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcc39d0f5693925ea1e8c517f7cc24211a9899c83a57e62d806180cdb056b6b75\",\"license\":\"AGPL-3.0-only\"},\"contracts/AssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/BN254.sol\\\";\\nimport \\\"./libraries/EdOnBN254.sol\\\";\\n\\ncontract AssetRegistry {\\n    bytes13 public constant DOM_SEP_FOREIGN_ASSET = \\\"FOREIGN_ASSET\\\";\\n    bytes14 public constant DOM_SEP_DOMESTIC_ASSET = \\\"DOMESTIC_ASSET\\\";\\n    uint256 public constant CAP_NATIVE_ASSET_CODE = 1;\\n\\n    mapping(bytes32 => address) public assets;\\n\\n    struct AssetDefinition {\\n        uint256 code;\\n        AssetPolicy policy;\\n    }\\n\\n    struct AssetPolicy {\\n        EdOnBN254.EdOnBN254Point auditorPk;\\n        EdOnBN254.EdOnBN254Point credPk;\\n        EdOnBN254.EdOnBN254Point freezerPk;\\n        uint256 revealMap;\\n        uint64 revealThreshold;\\n    }\\n\\n    /// @notice Return the CAP-native asset definition.\\n    function nativeDomesticAsset() public pure returns (AssetDefinition memory assetDefinition) {\\n        assetDefinition.code = CAP_NATIVE_ASSET_CODE;\\n        // affine representation of zero point in arkwork is (0,1)\\n        assetDefinition.policy.auditorPk.y = 1;\\n        assetDefinition.policy.credPk.y = 1;\\n        assetDefinition.policy.freezerPk.y = 1;\\n    }\\n\\n    /// @notice Fetch the ERC-20 token address corresponding to the\\n    /// given asset definition.\\n    /// @param assetDefinition an asset definition\\n    /// @return An ERC-20 address\\n    function lookup(AssetDefinition memory assetDefinition) public view returns (address) {\\n        bytes32 key = keccak256(abi.encode(assetDefinition));\\n        return assets[key];\\n    }\\n\\n    /// @notice Is the given asset definition registered?\\n    /// @param assetDefinition an asset definition\\n    /// @return True if the asset type is registered, false otherwise.\\n    function isCapeAssetRegistered(AssetDefinition memory assetDefinition)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return lookup(assetDefinition) != address(0);\\n    }\\n\\n    /// @notice Create and register a new asset type associated with an\\n    /// ERC-20 token. Will revert if the asset type is already\\n    /// registered or the ERC-20 token address is zero.\\n    /// @param erc20Address An ERC-20 token address\\n    /// @param newAsset An asset type to be registered in the contract\\n    function sponsorCapeAsset(address erc20Address, AssetDefinition memory newAsset) public {\\n        require(erc20Address != address(0), \\\"Bad asset address\\\");\\n        require(!isCapeAssetRegistered(newAsset), \\\"Asset already registered\\\");\\n\\n        _checkForeignAssetCode(newAsset.code, erc20Address, msg.sender);\\n\\n        bytes32 key = keccak256(abi.encode(newAsset));\\n        assets[key] = erc20Address;\\n    }\\n\\n    /// @notice Throws an exception if the asset definition code is\\n    /// not correctly derived from the ERC-20 address of the token and\\n    /// the address of the sponsor.\\n    /// @dev Requires \\\"view\\\" to access msg.sender.\\n    /// @param assetDefinitionCode The code of an asset definition\\n    /// @param erc20Address The ERC-20 address bound to the asset definition\\n    /// @param sponsor The sponsor address of this wrapped asset\\n    function _checkForeignAssetCode(\\n        uint256 assetDefinitionCode,\\n        address erc20Address,\\n        address sponsor\\n    ) internal pure {\\n        bytes memory description = _computeAssetDescription(erc20Address, sponsor);\\n        require(\\n            assetDefinitionCode ==\\n                BN254.fromLeBytesModOrder(\\n                    bytes.concat(keccak256(bytes.concat(DOM_SEP_FOREIGN_ASSET, description)))\\n                ),\\n            \\\"Wrong foreign asset code\\\"\\n        );\\n    }\\n\\n    /// @dev Checks if the asset definition code is correctly derived from the internal asset code.\\n    /// @param assetDefinitionCode asset definition code\\n    /// @param internalAssetCode internal asset code\\n    function _checkDomesticAssetCode(uint256 assetDefinitionCode, uint256 internalAssetCode)\\n        internal\\n        pure\\n    {\\n        require(\\n            assetDefinitionCode ==\\n                BN254.fromLeBytesModOrder(\\n                    bytes.concat(\\n                        keccak256(\\n                            bytes.concat(\\n                                DOM_SEP_DOMESTIC_ASSET,\\n                                bytes32(Utils.reverseEndianness(internalAssetCode))\\n                            )\\n                        )\\n                    )\\n                ),\\n            \\\"Wrong domestic asset code\\\"\\n        );\\n    }\\n\\n    /// @dev Compute the asset description from the address of the\\n    /// ERC-20 token and the address of the sponsor.\\n    /// @param erc20Address address of the erc20 token\\n    /// @param sponsor address of the sponsor\\n    /// @return The asset description\\n    function _computeAssetDescription(address erc20Address, address sponsor)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            bytes.concat(\\\"EsSCAPE ERC20\\\", bytes20(erc20Address), \\\"sponsored by\\\", bytes20(sponsor));\\n    }\\n}\\n\",\"keccak256\":\"0xed6de9292b294d4a5c87da3372858b64f02b0900ad747aeff25ee288247d5a63\",\"license\":\"GPL-3.0-or-later\"},\"contracts/CAPE.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Configurable Anonymous Payments for Ethereum\\n/// CAPE provides auditable anonymous payments on Ethereum.\\n/// @author Espresso Systems <hello@espressosys.com>\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\n\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"./libraries/AccumulatingArray.sol\\\";\\nimport \\\"./libraries/EdOnBN254.sol\\\";\\nimport \\\"./libraries/RescueLib.sol\\\";\\nimport \\\"./libraries/VerifyingKeys.sol\\\";\\nimport \\\"./interfaces/IPlonkVerifier.sol\\\";\\nimport \\\"./AssetRegistry.sol\\\";\\nimport \\\"./RecordsMerkleTree.sol\\\";\\nimport \\\"./RootStore.sol\\\";\\n\\ncontract CAPE is RecordsMerkleTree, RootStore, AssetRegistry, ReentrancyGuard {\\n    using AccumulatingArray for AccumulatingArray.Data;\\n\\n    mapping(uint256 => bool) public nullifiers;\\n    uint64 public blockHeight;\\n    IPlonkVerifier private _verifier;\\n    uint256[] public pendingDeposits;\\n\\n    // NOTE: used for faucet in testnet only, removed for mainnet\\n    address public deployer;\\n    bool public faucetInitialized;\\n\\n    bytes public constant CAPE_BURN_MAGIC_BYTES = \\\"EsSCAPE burn\\\";\\n    uint256 public constant CAPE_BURN_MAGIC_BYTES_SIZE = 12;\\n    // In order to avoid the contract running out of gas if the queue is too large\\n    // we set the maximum number of pending deposits record commitments to process\\n    // when a new block is submitted. This is a temporary solution.\\n    // See https://github.com/EspressoSystems/cape/issues/400\\n    uint256 public constant MAX_NUM_PENDING_DEPOSIT = 10;\\n\\n    event FaucetInitialized(bytes roBytes);\\n    event BlockCommitted(uint64 indexed height, uint256[] depositCommitments);\\n    event Erc20TokensDeposited(bytes roBytes, address erc20TokenAddress, address from);\\n\\n    struct AuditMemo {\\n        EdOnBN254.EdOnBN254Point ephemeralKey;\\n        uint256[] data;\\n    }\\n\\n    enum NoteType {\\n        TRANSFER,\\n        MINT,\\n        FREEZE,\\n        BURN\\n    }\\n\\n    struct TransferNote {\\n        uint256[] inputNullifiers;\\n        uint256[] outputCommitments;\\n        IPlonkVerifier.PlonkProof proof;\\n        AuditMemo auditMemo;\\n        TransferAuxInfo auxInfo;\\n    }\\n\\n    struct BurnNote {\\n        TransferNote transferNote;\\n        RecordOpening recordOpening;\\n    }\\n\\n    struct MintNote {\\n        /// nullifier for the input (i.e. transaction fee record)\\n        uint256 inputNullifier;\\n        /// output commitment for the fee change\\n        uint256 chgComm;\\n        /// output commitment for the minted asset\\n        uint256 mintComm;\\n        /// the amount of the minted asset\\n        uint64 mintAmount;\\n        /// the asset definition of the asset\\n        AssetDefinition mintAssetDef;\\n        /// Internal asset code\\n        uint256 mintInternalAssetCode;\\n        /// the validity proof of this note\\n        IPlonkVerifier.PlonkProof proof;\\n        /// memo for policy compliance specified for the designated auditor\\n        AuditMemo auditMemo;\\n        /// auxiliary information\\n        MintAuxInfo auxInfo;\\n    }\\n\\n    struct FreezeNote {\\n        uint256[] inputNullifiers;\\n        uint256[] outputCommitments;\\n        IPlonkVerifier.PlonkProof proof;\\n        FreezeAuxInfo auxInfo;\\n    }\\n\\n    struct TransferAuxInfo {\\n        uint256 merkleRoot;\\n        uint64 fee;\\n        uint64 validUntil;\\n        EdOnBN254.EdOnBN254Point txnMemoVerKey;\\n        bytes extraProofBoundData;\\n    }\\n\\n    struct MintAuxInfo {\\n        uint256 merkleRoot;\\n        uint64 fee;\\n        EdOnBN254.EdOnBN254Point txnMemoVerKey;\\n    }\\n\\n    struct FreezeAuxInfo {\\n        uint256 merkleRoot;\\n        uint64 fee;\\n        EdOnBN254.EdOnBN254Point txnMemoVerKey;\\n    }\\n\\n    struct RecordOpening {\\n        uint64 amount;\\n        AssetDefinition assetDef;\\n        EdOnBN254.EdOnBN254Point userAddr;\\n        bytes32 encKey;\\n        bool freezeFlag;\\n        uint256 blind;\\n    }\\n\\n    struct CapeBlock {\\n        EdOnBN254.EdOnBN254Point minerAddr;\\n        NoteType[] noteTypes;\\n        TransferNote[] transferNotes;\\n        MintNote[] mintNotes;\\n        FreezeNote[] freezeNotes;\\n        BurnNote[] burnNotes;\\n    }\\n\\n    /// @notice CAPE contract constructor method\\n    /// @param merkleTreeHeight height of the merkle tree that stores the asset record commitments\\n    /// @param nRoots number of the most recent roots of the records merkle tree to be stored\\n    /// @param verifierAddr address of the Plonk Verifier contract\\n    constructor(\\n        uint8 merkleTreeHeight,\\n        uint64 nRoots,\\n        address verifierAddr\\n    ) RecordsMerkleTree(merkleTreeHeight) RootStore(nRoots) {\\n        _verifier = IPlonkVerifier(verifierAddr);\\n\\n        // NOTE: used for faucet in testnet only, removed for mainnet\\n        deployer = msg.sender;\\n    }\\n\\n    /// @notice Allocate native token faucet to a manager for testnet only\\n    /// @param faucetManagerAddress address of public key of faucet manager for CAP native token (testnet only!)\\n    /// @param faucetManagerEncKey public key of faucet manager for CAP native token (testnet only!)\\n    function faucetSetupForTestnet(\\n        EdOnBN254.EdOnBN254Point memory faucetManagerAddress,\\n        bytes32 faucetManagerEncKey\\n    ) public {\\n        // faucet can only be set up once by the manager\\n        require(msg.sender == deployer, \\\"Only invocable by deployer\\\");\\n        require(!faucetInitialized, \\\"Faucet already set up\\\");\\n\\n        // allocate maximum possible amount of native CAP token to faucet manager on testnet\\n        // max amount len is set to 63 bits: https://github.com/EspressoSystems/cap/blob/main/src/constants.rs#L50-L51\\n        RecordOpening memory ro = RecordOpening(\\n            type(uint64).max / 2,\\n            nativeDomesticAsset(),\\n            faucetManagerAddress,\\n            faucetManagerEncKey,\\n            false,\\n            0 // arbitrary blind factor\\n        );\\n        uint256[] memory recordCommitments = new uint256[](1);\\n        recordCommitments[0] = _deriveRecordCommitment(ro);\\n\\n        // insert the record into record accumulator\\n        _updateRecordsMerkleTree(recordCommitments);\\n        _addRoot(_rootValue);\\n\\n        emit FaucetInitialized(abi.encode(ro));\\n        faucetInitialized = true;\\n    }\\n\\n    /// @dev Publish an array of nullifiers\\n    /// @dev Requires all nullifiers to be unique and unpublished.\\n    /// @dev A block creator must not submit notes with duplicate nullifiers.\\n    /// @param newNullifiers list of nullifiers to publish\\n    function _publish(uint256[] memory newNullifiers) internal {\\n        for (uint256 j = 0; j < newNullifiers.length; j++) {\\n            _publish(newNullifiers[j]);\\n        }\\n    }\\n\\n    /// @dev Publish a nullifier if it hasn't been published before\\n    /// @dev reverts if the nullifier is already published\\n    /// @param nullifier nullifier to publish\\n    function _publish(uint256 nullifier) internal {\\n        require(!nullifiers[nullifier], \\\"Nullifier already published\\\");\\n        nullifiers[nullifier] = true;\\n    }\\n\\n    /// @notice allows to wrap some erc20 tokens into some CAPE asset defined in the record opening\\n    /// @param ro record opening that will be inserted in the records merkle tree once the deposit is validated.\\n    /// @param erc20Address address of the ERC20 token corresponding to the deposit.\\n    function depositErc20(RecordOpening memory ro, address erc20Address) public nonReentrant {\\n        require(isCapeAssetRegistered(ro.assetDef), \\\"Asset definition not registered\\\");\\n\\n        // We skip the sanity checks mentioned in the rust specification as they are optional.\\n        if (pendingDeposits.length >= MAX_NUM_PENDING_DEPOSIT) {\\n            revert(\\\"Pending deposits queue is full\\\");\\n        }\\n        pendingDeposits.push(_deriveRecordCommitment(ro));\\n\\n        SafeTransferLib.safeTransferFrom(\\n            ERC20(erc20Address),\\n            msg.sender,\\n            address(this),\\n            ro.amount\\n        );\\n\\n        emit Erc20TokensDeposited(abi.encode(ro), erc20Address, msg.sender);\\n    }\\n\\n    /// @notice Submit a new block with extra data to the CAPE contract.\\n    /// @param newBlock block to be processed by the CAPE contract.\\n    /// @param extraData extra data to be stored in calldata, this data is ignored by the contract function.\\n    // solhint-disable-next-line no-unused-vars\\n    function submitCapeBlockWithMemos(CapeBlock memory newBlock, bytes calldata extraData) public {\\n        submitCapeBlock(newBlock);\\n    }\\n\\n    /// @notice Submit a new block to the CAPE contract. Transactions are validated and the blockchain state is updated. Moreover *BURN* transactions trigger the unwrapping of cape asset records into erc20 tokens.\\n    /// @param newBlock block to be processed by the CAPE contract.\\n    function submitCapeBlock(CapeBlock memory newBlock) public nonReentrant {\\n        AccumulatingArray.Data memory commitments = AccumulatingArray.create(\\n            _computeNumCommitments(newBlock) + pendingDeposits.length\\n        );\\n\\n        uint256 numNotes = newBlock.noteTypes.length;\\n\\n        // Batch verify plonk proofs\\n        IPlonkVerifier.VerifyingKey[] memory vks = new IPlonkVerifier.VerifyingKey[](numNotes);\\n        uint256[][] memory publicInputs = new uint256[][](numNotes);\\n        IPlonkVerifier.PlonkProof[] memory proofs = new IPlonkVerifier.PlonkProof[](numNotes);\\n        bytes[] memory extraMsgs = new bytes[](numNotes);\\n\\n        // Preserve the ordering of the (sub) arrays of notes.\\n        uint256 transferIdx = 0;\\n        uint256 mintIdx = 0;\\n        uint256 freezeIdx = 0;\\n        uint256 burnIdx = 0;\\n\\n        for (uint256 i = 0; i < numNotes; i++) {\\n            NoteType noteType = newBlock.noteTypes[i];\\n\\n            if (noteType == NoteType.TRANSFER) {\\n                TransferNote memory note = newBlock.transferNotes[transferIdx];\\n                transferIdx += 1;\\n\\n                _checkContainsRoot(note.auxInfo.merkleRoot);\\n                _checkTransfer(note);\\n                require(!_isExpired(note), \\\"Expired note\\\");\\n\\n                _publish(note.inputNullifiers);\\n\\n                commitments.add(note.outputCommitments);\\n\\n                (vks[i], publicInputs[i], proofs[i], extraMsgs[i]) = _prepareForProofVerification(\\n                    note\\n                );\\n            } else if (noteType == NoteType.MINT) {\\n                MintNote memory note = newBlock.mintNotes[mintIdx];\\n                mintIdx += 1;\\n\\n                _checkContainsRoot(note.auxInfo.merkleRoot);\\n                _checkDomesticAssetCode(note.mintAssetDef.code, note.mintInternalAssetCode);\\n\\n                _publish(note.inputNullifier);\\n\\n                commitments.add(note.chgComm);\\n                commitments.add(note.mintComm);\\n\\n                (vks[i], publicInputs[i], proofs[i], extraMsgs[i]) = _prepareForProofVerification(\\n                    note\\n                );\\n            } else if (noteType == NoteType.FREEZE) {\\n                FreezeNote memory note = newBlock.freezeNotes[freezeIdx];\\n                freezeIdx += 1;\\n\\n                _checkContainsRoot(note.auxInfo.merkleRoot);\\n\\n                _publish(note.inputNullifiers);\\n\\n                commitments.add(note.outputCommitments);\\n\\n                (vks[i], publicInputs[i], proofs[i], extraMsgs[i]) = _prepareForProofVerification(\\n                    note\\n                );\\n            } else if (noteType == NoteType.BURN) {\\n                BurnNote memory note = newBlock.burnNotes[burnIdx];\\n                burnIdx += 1;\\n\\n                _checkContainsRoot(note.transferNote.auxInfo.merkleRoot);\\n                _checkBurn(note);\\n\\n                _publish(note.transferNote.inputNullifiers);\\n\\n                // Insert all the output commitments to the records merkle tree except from the second one (corresponding to the burned output)\\n                for (uint256 j = 0; j < note.transferNote.outputCommitments.length; j++) {\\n                    if (j != 1) {\\n                        commitments.add(note.transferNote.outputCommitments[j]);\\n                    }\\n                }\\n\\n                (vks[i], publicInputs[i], proofs[i], extraMsgs[i]) = _prepareForProofVerification(\\n                    note\\n                );\\n\\n                // Send the tokens\\n                _handleWithdrawal(note);\\n            } else {\\n                revert(\\\"Cape: unreachable!\\\");\\n            }\\n        }\\n\\n        // Skip the batch plonk verification if the block is empty\\n        if (numNotes > 0) {\\n            require(\\n                _verifier.batchVerify(vks, publicInputs, proofs, extraMsgs),\\n                \\\"Cape: batch verify failed.\\\"\\n            );\\n        }\\n\\n        // Process the pending deposits obtained after calling `depositErc20`\\n        for (uint256 i = 0; i < pendingDeposits.length; i++) {\\n            commitments.add(pendingDeposits[i]);\\n        }\\n\\n        // Only update the merkle tree and add the root if the list of records commitments is non empty\\n        if (!commitments.isEmpty()) {\\n            _updateRecordsMerkleTree(commitments.items);\\n            _addRoot(_rootValue);\\n        }\\n\\n        // In all cases (the block is empty or not), the height is incremented.\\n        blockHeight += 1;\\n\\n        // Inform clients about the new block and the processed deposits.\\n        emit BlockCommitted(blockHeight, pendingDeposits);\\n\\n        // Empty the queue now that the record commitments have been inserted\\n        delete pendingDeposits;\\n    }\\n\\n    /// @dev send the ERC20 tokens equivalent to the asset records being burnt. Recall that the burned record opening is contained inside the note.\\n    /// @param note note of type *BURN*\\n    function _handleWithdrawal(BurnNote memory note) internal {\\n        address ercTokenAddress = lookup(note.recordOpening.assetDef);\\n\\n        // Extract recipient address\\n        address recipientAddress = BytesLib.toAddress(\\n            note.transferNote.auxInfo.extraProofBoundData,\\n            CAPE_BURN_MAGIC_BYTES_SIZE\\n        );\\n        SafeTransferLib.safeTransfer(\\n            ERC20(ercTokenAddress),\\n            recipientAddress,\\n            note.recordOpening.amount\\n        );\\n    }\\n\\n    /// @dev Compute an upper bound on the number of records to be inserted\\n    function _computeNumCommitments(CapeBlock memory newBlock) internal pure returns (uint256) {\\n        // MintNote always has 2 commitments: mint_comm, chg_comm\\n        uint256 numComms = 2 * newBlock.mintNotes.length;\\n        for (uint256 i = 0; i < newBlock.transferNotes.length; i++) {\\n            numComms += newBlock.transferNotes[i].outputCommitments.length;\\n        }\\n        for (uint256 i = 0; i < newBlock.burnNotes.length; i++) {\\n            // Subtract one for the burn record commitment that is not inserted.\\n            // The function _containsBurnRecord checks that there are at least 2 output commitments.\\n            numComms += newBlock.burnNotes[i].transferNote.outputCommitments.length - 1;\\n        }\\n        for (uint256 i = 0; i < newBlock.freezeNotes.length; i++) {\\n            numComms += newBlock.freezeNotes[i].outputCommitments.length;\\n        }\\n        return numComms;\\n    }\\n\\n    /// @dev Verify if a note is of type *TRANSFER*\\n    /// @param note note which could be of type *TRANSFER* or *BURN*\\n    function _checkTransfer(TransferNote memory note) internal pure {\\n        require(\\n            !_containsBurnPrefix(note.auxInfo.extraProofBoundData),\\n            \\\"Burn prefix in transfer note\\\"\\n        );\\n    }\\n\\n    /// @dev check if a note has expired\\n    /// @param note note for which we want to check its timestamp against the current block height\\n    function _isExpired(TransferNote memory note) internal view returns (bool) {\\n        return note.auxInfo.validUntil < blockHeight;\\n    }\\n\\n    /// @dev check if a burn note is well formed\\n    /// @param note note of type *BURN*\\n    function _checkBurn(BurnNote memory note) internal view {\\n        bytes memory extra = note.transferNote.auxInfo.extraProofBoundData;\\n        require(_containsBurnPrefix(extra), \\\"Bad burn tag\\\");\\n        require(_containsBurnRecord(note), \\\"Bad record commitment\\\");\\n    }\\n\\n    /// @dev helper function to check if a sequence of bytes contains hardcoded prefix\\n    /// @param byteSeq sequence of bytes\\n    function _containsBurnPrefix(bytes memory byteSeq) internal pure returns (bool) {\\n        if (byteSeq.length < CAPE_BURN_MAGIC_BYTES_SIZE) {\\n            return false;\\n        }\\n        return\\n            BytesLib.equal(\\n                BytesLib.slice(byteSeq, 0, CAPE_BURN_MAGIC_BYTES_SIZE),\\n                CAPE_BURN_MAGIC_BYTES\\n            );\\n    }\\n\\n    /// @dev check if the burned record opening and the record commitment in position 1 are consistent\\n    /// @param note note of type *BURN*\\n    function _containsBurnRecord(BurnNote memory note) internal view returns (bool) {\\n        if (note.transferNote.outputCommitments.length < 2) {\\n            return false;\\n        }\\n        uint256 rc = _deriveRecordCommitment(note.recordOpening);\\n        return rc == note.transferNote.outputCommitments[1];\\n    }\\n\\n    /// @dev compute the commitment of a record opening\\n    /// @param ro record opening\\n    function _deriveRecordCommitment(RecordOpening memory ro) internal view returns (uint256 rc) {\\n        require(ro.assetDef.policy.revealMap < 2**12, \\\"Reveal map exceeds 12 bits\\\");\\n\\n        // No overflow check, only 12 bits in reveal map\\n        uint256 revealMapAndFreezeFlag = 2 *\\n            ro.assetDef.policy.revealMap +\\n            (ro.freezeFlag ? 1 : 0);\\n\\n        // blind in front of rest -> 13 elements, pad to 15 (5 x 3)\\n        uint256[15] memory inputs = [\\n            ro.blind,\\n            ro.amount,\\n            ro.assetDef.code,\\n            ro.userAddr.x,\\n            ro.userAddr.y,\\n            ro.assetDef.policy.auditorPk.x,\\n            ro.assetDef.policy.auditorPk.y,\\n            ro.assetDef.policy.credPk.x,\\n            ro.assetDef.policy.credPk.y,\\n            ro.assetDef.policy.freezerPk.x,\\n            ro.assetDef.policy.freezerPk.y,\\n            revealMapAndFreezeFlag,\\n            ro.assetDef.policy.revealThreshold,\\n            0,\\n            0\\n        ];\\n\\n        return RescueLib.commit(inputs);\\n    }\\n\\n    /// @dev An overloaded function (one for each note type) to prepare all inputs necessary for batch verification of the plonk proof\\n    /// @param note note of type *TRANSFER*\\n    function _prepareForProofVerification(TransferNote memory note)\\n        internal\\n        view\\n        returns (\\n            IPlonkVerifier.VerifyingKey memory vk,\\n            uint256[] memory publicInput,\\n            IPlonkVerifier.PlonkProof memory proof,\\n            bytes memory transcriptInitMsg\\n        )\\n    {\\n        // load the correct (hardcoded) vk\\n        vk = VerifyingKeys.getVkById(\\n            VerifyingKeys.getEncodedId(\\n                uint8(NoteType.TRANSFER),\\n                uint8(note.inputNullifiers.length),\\n                uint8(note.outputCommitments.length),\\n                uint8(_merkleTreeHeight)\\n            )\\n        );\\n        // prepare public inputs\\n        // 4: root, native_asset_code, valid_until, fee\\n        // 2: audit_memo.ephemeral_key (x and y)\\n        publicInput = new uint256[](\\n            4 +\\n                note.inputNullifiers.length +\\n                note.outputCommitments.length +\\n                2 +\\n                note.auditMemo.data.length\\n        );\\n        publicInput[0] = note.auxInfo.merkleRoot;\\n        publicInput[1] = CAP_NATIVE_ASSET_CODE;\\n        publicInput[2] = note.auxInfo.validUntil;\\n        publicInput[3] = note.auxInfo.fee;\\n        {\\n            uint256 idx = 4;\\n            for (uint256 i = 0; i < note.inputNullifiers.length; i++) {\\n                publicInput[idx + i] = note.inputNullifiers[i];\\n            }\\n            idx += note.inputNullifiers.length;\\n\\n            for (uint256 i = 0; i < note.outputCommitments.length; i++) {\\n                publicInput[idx + i] = note.outputCommitments[i];\\n            }\\n            idx += note.outputCommitments.length;\\n\\n            publicInput[idx] = note.auditMemo.ephemeralKey.x;\\n            publicInput[idx + 1] = note.auditMemo.ephemeralKey.y;\\n            idx += 2;\\n\\n            for (uint256 i = 0; i < note.auditMemo.data.length; i++) {\\n                publicInput[idx + i] = note.auditMemo.data[i];\\n            }\\n        }\\n\\n        // extract out proof\\n        proof = note.proof;\\n\\n        // prepare transcript init messages\\n        transcriptInitMsg = abi.encodePacked(\\n            EdOnBN254.serialize(note.auxInfo.txnMemoVerKey),\\n            note.auxInfo.extraProofBoundData\\n        );\\n    }\\n\\n    /// @dev An overloaded function (one for each note type) to prepare all inputs necessary for batch verification of the plonk proof\\n    /// @param note note of type *BURN*\\n    function _prepareForProofVerification(BurnNote memory note)\\n        internal\\n        view\\n        returns (\\n            IPlonkVerifier.VerifyingKey memory,\\n            uint256[] memory,\\n            IPlonkVerifier.PlonkProof memory,\\n            bytes memory\\n        )\\n    {\\n        return _prepareForProofVerification(note.transferNote);\\n    }\\n\\n    /// @dev An overloaded function (one for each note type) to prepare all inputs necessary for batch verification of the plonk proof\\n    /// @param note note of type *MINT*\\n    function _prepareForProofVerification(MintNote memory note)\\n        internal\\n        view\\n        returns (\\n            IPlonkVerifier.VerifyingKey memory vk,\\n            uint256[] memory publicInput,\\n            IPlonkVerifier.PlonkProof memory proof,\\n            bytes memory transcriptInitMsg\\n        )\\n    {\\n        // load the correct (hardcoded) vk\\n        vk = VerifyingKeys.getVkById(\\n            VerifyingKeys.getEncodedId(\\n                uint8(NoteType.MINT),\\n                1, // num of input\\n                2, // num of output\\n                uint8(_merkleTreeHeight)\\n            )\\n        );\\n\\n        // prepare public inputs\\n        // 9: see below; 8: asset policy; rest: audit memo\\n        publicInput = new uint256[](9 + 8 + 2 + note.auditMemo.data.length);\\n        publicInput[0] = note.auxInfo.merkleRoot;\\n        publicInput[1] = CAP_NATIVE_ASSET_CODE;\\n        publicInput[2] = note.inputNullifier;\\n        publicInput[3] = note.auxInfo.fee;\\n        publicInput[4] = note.mintComm;\\n        publicInput[5] = note.chgComm;\\n        publicInput[6] = note.mintAmount;\\n        publicInput[7] = note.mintAssetDef.code;\\n        publicInput[8] = note.mintInternalAssetCode;\\n\\n        publicInput[9] = note.mintAssetDef.policy.revealMap;\\n        publicInput[10] = note.mintAssetDef.policy.auditorPk.x;\\n        publicInput[11] = note.mintAssetDef.policy.auditorPk.y;\\n        publicInput[12] = note.mintAssetDef.policy.credPk.x;\\n        publicInput[13] = note.mintAssetDef.policy.credPk.y;\\n        publicInput[14] = note.mintAssetDef.policy.freezerPk.x;\\n        publicInput[15] = note.mintAssetDef.policy.freezerPk.y;\\n        publicInput[16] = note.mintAssetDef.policy.revealThreshold;\\n\\n        {\\n            publicInput[17] = note.auditMemo.ephemeralKey.x;\\n            publicInput[18] = note.auditMemo.ephemeralKey.y;\\n\\n            uint256 idx = 19;\\n            for (uint256 i = 0; i < note.auditMemo.data.length; i++) {\\n                publicInput[idx + i] = note.auditMemo.data[i];\\n            }\\n        }\\n\\n        // extract out proof\\n        proof = note.proof;\\n\\n        // prepare transcript init messages\\n        transcriptInitMsg = EdOnBN254.serialize(note.auxInfo.txnMemoVerKey);\\n    }\\n\\n    /// @dev An overloaded function (one for each note type) to prepare all inputs necessary for batch verification of the plonk proof\\n    /// @param note note of type *FREEZE*\\n    function _prepareForProofVerification(FreezeNote memory note)\\n        internal\\n        view\\n        returns (\\n            IPlonkVerifier.VerifyingKey memory vk,\\n            uint256[] memory publicInput,\\n            IPlonkVerifier.PlonkProof memory proof,\\n            bytes memory transcriptInitMsg\\n        )\\n    {\\n        // load the correct (hardcoded) vk\\n        vk = VerifyingKeys.getVkById(\\n            VerifyingKeys.getEncodedId(\\n                uint8(NoteType.FREEZE),\\n                uint8(note.inputNullifiers.length),\\n                uint8(note.outputCommitments.length),\\n                uint8(_merkleTreeHeight)\\n            )\\n        );\\n\\n        // prepare public inputs\\n        publicInput = new uint256[](\\n            3 + note.inputNullifiers.length + note.outputCommitments.length\\n        );\\n        publicInput[0] = note.auxInfo.merkleRoot;\\n        publicInput[1] = CAP_NATIVE_ASSET_CODE;\\n        publicInput[2] = note.auxInfo.fee;\\n        {\\n            uint256 idx = 3;\\n            for (uint256 i = 0; i < note.inputNullifiers.length; i++) {\\n                publicInput[idx + i] = note.inputNullifiers[i];\\n            }\\n            idx += note.inputNullifiers.length;\\n\\n            for (uint256 i = 0; i < note.outputCommitments.length; i++) {\\n                publicInput[idx + i] = note.outputCommitments[i];\\n            }\\n        }\\n\\n        // extract out proof\\n        proof = note.proof;\\n\\n        // prepare transcript init messages\\n        transcriptInitMsg = EdOnBN254.serialize(note.auxInfo.txnMemoVerKey);\\n    }\\n}\\n\",\"keccak256\":\"0xffb33ca5147483f33b92f393f098a698e0c1e6ec7ff0bba97b3e3646fd1f5598\",\"license\":\"GPL-3.0-or-later\"},\"contracts/MaliciousToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport {TestCAPE} from \\\"./mocks/TestCAPE.sol\\\";\\n\\n// Learn more about the ERC20 implementation\\n// on OpenZeppelin docs: https://docs.openzeppelin.com/contracts/4.x/erc20\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MaliciousToken is ERC20 {\\n    address private _targetContractAddress;\\n    bool private _runDeposit;\\n    bool private _runSubmitBlock;\\n\\n    /// @notice MaliciousToken contract constructor.\\n    constructor() ERC20(\\\"Malicious Token\\\", \\\"MAT\\\") {\\n        _runDeposit = false;\\n        _runSubmitBlock = false;\\n    }\\n\\n    /**\\n     * /// @dev Sets the address for performing the reentrancy attack.\\n     */\\n    function setTargetContractAddress(address targetContractAddress) public {\\n        _targetContractAddress = targetContractAddress;\\n    }\\n\\n    /**\\n     * /// @dev pick the depositErc20 function when calling back the CAPE contract\\n     */\\n    function selectDepositAttack() public {\\n        _runDeposit = true;\\n        _runSubmitBlock = false;\\n    }\\n\\n    /**\\n     * /// @dev pick the submitBlock function when calling back the CAPE contract\\n     */\\n    function selectSubmitBlockAttack() public {\\n        _runDeposit = false;\\n        _runSubmitBlock = true;\\n    }\\n\\n    /**\\n     * /// @notice Malicious implementation of transferFrom\\n     */\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) public virtual override returns (bool) {\\n        TestCAPE cape = TestCAPE(_targetContractAddress);\\n\\n        if (_runDeposit) {\\n            TestCAPE.RecordOpening memory dummyRo;\\n            address dummyAddress;\\n            cape.depositErc20(dummyRo, dummyAddress);\\n        }\\n\\n        if (_runSubmitBlock) {\\n            TestCAPE.CapeBlock memory dummyBlock;\\n            cape.submitCapeBlock(dummyBlock);\\n        }\\n\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x8ff5e6839d24aad5c8c502b1fe7a6c6f5e3cc379c1a25782fcff63198fb3e022\",\"license\":\"GPL-3.0-or-later\"},\"contracts/RecordsMerkleTree.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"./libraries/RescueLib.sol\\\";\\n\\ncontract RecordsMerkleTree {\\n    enum Position {\\n        LEFT,\\n        MIDDLE,\\n        RIGHT\\n    }\\n\\n    // Representation of a (tree) node\\n    // A node contains a value and pointers (which are index in an array of other nodes).\\n    // By convention a node that has no (left,middle,right) children will point to index 0.\\n    struct Node {\\n        uint256 val;\\n        uint64 left; // Pointer (index) to the left child\\n        uint64 middle; // Pointer (index) to the middle child\\n        uint64 right; // Pointer (index) to the right child\\n    }\\n\\n    uint256 internal _rootValue;\\n    uint64 internal _numLeaves;\\n    uint8 internal _merkleTreeHeight;\\n\\n    mapping(uint256 => uint256) internal _flattenedFrontier;\\n\\n    /// @dev Create a records Merkle tree of the given height.\\n    /// @param merkleTreeHeight The height\\n    constructor(uint8 merkleTreeHeight) {\\n        _rootValue = 0;\\n        _numLeaves = 0;\\n        _merkleTreeHeight = merkleTreeHeight;\\n    }\\n\\n    /// @dev Is the given node a terminal node?\\n    /// @param node A node\\n    /// @return _ True if the node is terminal, false otherwise.\\n    function _isTerminal(Node memory node) private pure returns (bool) {\\n        return (node.left == 0) && (node.middle == 0) && (node.right == 0);\\n    }\\n\\n    /// @dev Does the given node have children?\\n    /// @param node A node\\n    /// @return _ True if the node has at least one child, false otherwise\\n    function _hasChildren(Node memory node) private pure returns (bool) {\\n        return !_isTerminal(node);\\n    }\\n\\n    /// @dev Is the given node null?\\n    /// @param node A node\\n    /// @return _ True if the node is NULL, false otherwise\\n    function _isNull(Node memory node) private pure returns (bool) {\\n        return (node.val == 0 && _isTerminal(node));\\n    }\\n\\n    /// @dev Create a new \\\"hole node\\\" at the given position in the\\n    /// tree. A cursor position can be obtained from an extant node or\\n    /// from a function that returns a position such as _buildTreeFromFrontier.\\n    /// @param cursor The index of the node in the array of nodes\\n    /// @param posSibling The position of the sibling i.e. (LEFT, MIDDLE or RIGHT)\\n    /// @return _ The new created node\\n    function _createHoleNode(uint64 cursor, Position posSibling)\\n        private\\n        pure\\n        returns (Node memory)\\n    {\\n        // Copy pasting these values to save gas\\n        // indexHoleNode = cursor - 3;\\n        // indexFirstSibling = cursor - 2;\\n        // indexSecondSibling = cursor - 1;\\n\\n        Node memory node;\\n        if (posSibling == Position.LEFT) {\\n            node = Node(0, cursor - 3, cursor - 2, cursor - 1);\\n        } else if (posSibling == Position.MIDDLE) {\\n            node = Node(0, cursor - 2, cursor - 3, cursor - 1);\\n        } else if (posSibling == Position.RIGHT) {\\n            node = Node(0, cursor - 2, cursor - 1, cursor - 3);\\n        }\\n\\n        return node;\\n    }\\n\\n    /// @dev Create a Merkle tree from the given frontier.\\n    /// @param nodes The list of nodes to be filled or updated\\n    /// @return A cursor to the root node of the create tree\\n    function _buildTreeFromFrontier(Node[] memory nodes) internal view returns (uint64) {\\n        // Tree is empty\\n        if (_numLeaves == 0) {\\n            nodes[0] = Node(0, 0, 0, 0); // Empty node\\n            nodes[1] = Node(0, 0, 0, 0); // Root node\\n            return 1;\\n        }\\n\\n        // Tree is not empty\\n\\n        // Set the first node to the NULL node\\n        nodes[0] = Node(0, 0, 0, 0);\\n\\n        // Insert the leaf\\n        nodes[1] = Node(_flattenedFrontier[0], 0, 0, 0);\\n\\n        // Insert the siblings\\n        nodes[2] = Node(_flattenedFrontier[1], 0, 0, 0);\\n        nodes[3] = Node(_flattenedFrontier[2], 0, 0, 0);\\n\\n        // Compute the position of each node\\n        uint64 absolutePosition = _numLeaves - 1;\\n        uint8 localPosition = uint8(absolutePosition % 3);\\n\\n        // We process the nodes of the Merkle path\\n        uint64 cursor = 4;\\n        uint64 cursorFrontier = 3;\\n\\n        // Build the tree expect the root node\\n        while (cursor < 3 * _merkleTreeHeight + 1) {\\n            nodes[cursor] = _createHoleNode(cursor, Position(localPosition));\\n\\n            // Create the siblings of the \\\"hole node\\\". These siblings have no children\\n            nodes[cursor + 1] = Node(_flattenedFrontier[cursorFrontier], 0, 0, 0);\\n            nodes[cursor + 2] = Node(_flattenedFrontier[cursorFrontier + 1], 0, 0, 0);\\n\\n            // Move forward\\n            absolutePosition /= 3;\\n            localPosition = uint8(absolutePosition % 3);\\n\\n            cursor += 3;\\n            cursorFrontier += 2;\\n        }\\n\\n        // Add the root node\\n        nodes[cursor] = _createHoleNode(cursor, Position(localPosition));\\n        return cursor;\\n    }\\n\\n    /// @dev Compute the index of the next node when going down in the tree.\\n    /// @param nodes The list of nodes of the tree\\n    /// @param nodeIndex The index of the starting node\\n    /// @param pos The position for going down, i.e. LEFT, MIDDLE or RIGHT.\\n    /// @return The index of the next node\\n    function _nextNodeIndex(\\n        Node[] memory nodes,\\n        uint64 nodeIndex,\\n        Position pos\\n    ) private pure returns (uint64) {\\n        uint64 res;\\n\\n        if (pos == Position.LEFT) {\\n            res = nodes[nodeIndex].left;\\n        } else if (pos == Position.MIDDLE) {\\n            res = nodes[nodeIndex].middle;\\n        } else if (pos == Position.RIGHT) {\\n            res = nodes[nodeIndex].right;\\n        }\\n\\n        return res;\\n    }\\n\\n    /// @dev Update the child of a node based on the position (which child to select) and an index to the new child.\\n    /// @param node node for which we want to update the child\\n    /// @param newChildIndex index of the new child\\n    /// @param pos position of the child node relative to the node (i.e. LEFT, MIDDLE or RIGHT)\\n    function _updateChildNode(\\n        Node memory node,\\n        uint64 newChildIndex,\\n        Position pos\\n    ) private pure {\\n        // Update the node\\n        if (pos == Position.LEFT) {\\n            node.left = newChildIndex;\\n        } else if (pos == Position.MIDDLE) {\\n            node.middle = newChildIndex;\\n        } else if (pos == Position.RIGHT) {\\n            node.right = newChildIndex;\\n        }\\n    }\\n\\n    function _computeNodePos(uint64 absolutePos, uint64 branchIndex)\\n        private\\n        view\\n        returns (uint64, uint64)\\n    {\\n        uint64 localPos;\\n        uint64 divisor = uint64(3**(_merkleTreeHeight - branchIndex - 1));\\n\\n        localPos = absolutePos / divisor;\\n        absolutePos = absolutePos % divisor;\\n\\n        return (absolutePos, localPos);\\n    }\\n\\n    /// @notice Insert an element into the tree in the position num_leaves.\\n    /// @param nodes The array of nodes\\n    /// @param rootIndex The index of the root node\\n    /// @param maxIndex The index of the latest element inserted in the nodes array\\n    /// @param element The value of the element to insert into the tree\\n    /// @return updated the value of maxIndex\\n    function _pushElement(\\n        Node[] memory nodes,\\n        uint64 rootIndex,\\n        uint64 maxIndex,\\n        uint256 element\\n    ) private returns (uint64) {\\n        require(_numLeaves < 3**_merkleTreeHeight, \\\"The tree is full.\\\");\\n\\n        // Get the position of the leaf from the smart contract state\\n        uint64 leafPos = _numLeaves;\\n        uint64 branchIndex = 0;\\n        uint64 currentNodeIndex = rootIndex;\\n        uint64 previousNodeIndex = rootIndex;\\n\\n        // Go down inside the tree until finding the first terminal node.\\n        uint64 absolutePos = leafPos;\\n        uint64 localPos = 0;\\n        while (!_isNull(nodes[currentNodeIndex])) {\\n            (absolutePos, localPos) = _computeNodePos(absolutePos, branchIndex);\\n\\n            previousNodeIndex = currentNodeIndex;\\n            currentNodeIndex = _nextNodeIndex(nodes, currentNodeIndex, Position(localPos));\\n\\n            branchIndex += 1;\\n        }\\n\\n        // maxIndex tracks the index of the last element inserted in the tree\\n        uint64 newNodeIndex = maxIndex + 1;\\n\\n        // Create new nodes until completing the path one level above the leaf level\\n        // Always inserting to the left\\n\\n        // To compensate the extra increment at the end of the previous loop ,\\n        // except if the tree is reduced to a single root node.\\n        if (branchIndex > 0) {\\n            branchIndex -= 1;\\n        }\\n\\n        while (branchIndex < _merkleTreeHeight - 1) {\\n            nodes[newNodeIndex] = Node(0, 0, 0, 0);\\n            _updateChildNode(nodes[previousNodeIndex], newNodeIndex, Position(localPos));\\n\\n            // Prepare the next iteration of the loop\\n            previousNodeIndex = newNodeIndex;\\n            newNodeIndex += 1;\\n            branchIndex += 1;\\n            (absolutePos, localPos) = _computeNodePos(absolutePos, branchIndex);\\n        }\\n\\n        // The last node contains the leaf value (compute the hash)\\n        // Remember position is computed with the remainder\\n\\n        // Leaf node where the value is hash(0,_numLeaves,element)\\n        uint256 val = RescueLib.hash(0, _numLeaves, element);\\n        nodes[newNodeIndex] = Node(val, 0, 0, 0);\\n        _updateChildNode(nodes[previousNodeIndex], newNodeIndex, Position(localPos));\\n\\n        // Increment the number of leaves\\n        _numLeaves += 1;\\n\\n        // Return the new value of maxIndex\\n        return newNodeIndex;\\n    }\\n\\n    /// @dev Store the frontier.\\n    /// @param nodes The list of node of the tree\\n    /// @param rootIndex The index of the root node\\n    function _storeFrontier(Node[] memory nodes, uint64 rootIndex) private {\\n        uint64 frontierSize = 2 * _merkleTreeHeight + 1;\\n\\n        /// Collect the values from the root to the leaf but in reverse order\\n        uint64 currentNodeIndex = rootIndex;\\n        uint64 firstSiblingIndex = 0;\\n        uint64 secondSiblingIndex = 0;\\n        // Go down until the leaf\\n        for (uint256 i = 0; i < _merkleTreeHeight; i++) {\\n            // Pick the non-empty node that is most right\\n            Node memory currentNode = nodes[currentNodeIndex];\\n            if (!_isNull(nodes[currentNode.right])) {\\n                // Keep to the right\\n                currentNodeIndex = currentNode.right;\\n                firstSiblingIndex = currentNode.left;\\n                secondSiblingIndex = currentNode.middle;\\n            } else if (!_isNull(nodes[currentNode.middle])) {\\n                // Keep to the middle\\n                currentNodeIndex = currentNode.middle;\\n                firstSiblingIndex = currentNode.left;\\n                secondSiblingIndex = currentNode.right;\\n            } else {\\n                // Keep to the left\\n                currentNodeIndex = currentNode.left;\\n                firstSiblingIndex = currentNode.middle;\\n                secondSiblingIndex = currentNode.right;\\n            }\\n            uint256 secondSiblingPos = frontierSize - 1 - (2 * i);\\n            uint256 firstSiblingPos = secondSiblingPos - 1;\\n            _flattenedFrontier[secondSiblingPos] = nodes[secondSiblingIndex].val;\\n            _flattenedFrontier[firstSiblingPos] = nodes[firstSiblingIndex].val;\\n        }\\n        // currentNodeIndex points to the leaf\\n        _flattenedFrontier[0] = nodes[currentNodeIndex].val;\\n    }\\n\\n    /// @dev Update the state of the record merkle tree by inserting new elements.\\n    /// @param elements The list of elements to be appended to the current merkle tree described by the frontier.\\n    function _updateRecordsMerkleTree(uint256[] memory elements) internal {\\n        // The total number of nodes is bounded by 3*height+1 + 3*N*height = 3*(N+1)*height + 1\\n        // where N is the number of new records\\n        uint256 numElements = elements.length;\\n        Node[] memory nodes = new Node[](3 * (numElements + 1) * _merkleTreeHeight + 2);\\n\\n        /// Insert the new elements ///\\n\\n        // maxIndex tracks the index of the last element inserted in the tree\\n        uint64 rootIndex = _buildTreeFromFrontier(nodes);\\n        uint64 maxIndex = rootIndex;\\n        for (uint32 i = 0; i < elements.length; i++) {\\n            maxIndex = _pushElement(nodes, rootIndex, maxIndex, elements[i]);\\n        }\\n        //// Compute the root hash value ////\\n        _rootValue = _computeRootValueAndUpdateTree(nodes, rootIndex);\\n\\n        //// Store the frontier\\n        _storeFrontier(nodes, rootIndex);\\n    }\\n\\n    // Returns the root value of the Merkle tree\\n    function getRootValue() public view returns (uint256) {\\n        return _rootValue;\\n    }\\n\\n    /// @dev Update the tree by hashing the children of each node.\\n    /// @param nodes The tree. Note that the nodes are updated by this function.\\n    /// @param rootNodePos The index of the root node in the list of nodes.\\n    /// @return The value obtained at the root.\\n    function _computeRootValueAndUpdateTree(Node[] memory nodes, uint256 rootNodePos)\\n        private\\n        returns (uint256)\\n    {\\n        // If the root node has no children return its value\\n        Node memory rootNode = nodes[rootNodePos];\\n        if (_isTerminal(rootNode)) {\\n            return rootNode.val;\\n        } else {\\n            uint256 valLeft = _computeRootValueAndUpdateTree(nodes, rootNode.left);\\n            uint256 valMiddle = _computeRootValueAndUpdateTree(nodes, rootNode.middle);\\n            uint256 valRight = _computeRootValueAndUpdateTree(nodes, rootNode.right);\\n\\n            nodes[rootNode.left].val = valLeft;\\n            nodes[rootNode.middle].val = valMiddle;\\n            nodes[rootNode.right].val = valRight;\\n\\n            return RescueLib.hash(valLeft, valMiddle, valRight);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb848f595a4a4a586a96977fe7000e7ba4d0be5608caf1cc5c660dc137b2ae565\",\"license\":\"GPL-3.0-or-later\"},\"contracts/RootStore.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\ncontract RootStore {\\n    uint256[] internal _roots;\\n    mapping(uint256 => bool) internal _rootsMap;\\n    uint64 internal _writeHead;\\n\\n    /// @dev Create a root store.\\n    /// @param nRoots The maximum number of roots to store\\n    constructor(uint64 nRoots) {\\n        // Set up the circular buffer for handling the last N roots\\n        require(nRoots > 1, \\\"A least 2 roots required\\\");\\n\\n        _roots = new uint256[](nRoots);\\n\\n        // Intially all roots are set to zero.\\n        // This value is such that no adversary can extend a branch from this root node.\\n        // See proposition 2, page 48 of the AT-Spec document EspressoSystems/AT-spec@01f71ce\\n    }\\n\\n    /// @dev Add a root value. Only keep the latest nRoots ones.\\n    /// @param newRoot The value of the new root\\n    function _addRoot(uint256 newRoot) internal {\\n        require(!_rootsMap[newRoot], \\\"Root already exists\\\");\\n\\n        // Ensure the root we will \\\"overwrite\\\" is removed.\\n        _rootsMap[_roots[_writeHead]] = false;\\n\\n        _roots[_writeHead] = newRoot;\\n        _rootsMap[newRoot] = true;\\n\\n        _writeHead = (_writeHead + 1) % uint64(_roots.length);\\n    }\\n\\n    /// @dev Is the root value contained in the store?\\n    /// @param root The root value to find\\n    /// @return _ True if the root value is in the store, false otherwise\\n    function _containsRoot(uint256 root) internal view returns (bool) {\\n        return _rootsMap[root];\\n    }\\n\\n    /// @dev Raise an exception if the root is not present in the store.\\n    /// @param root The required root value\\n    function _checkContainsRoot(uint256 root) internal view {\\n        require(_containsRoot(root), \\\"Root not found\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x15aa0b64169f29c7f15624b9449630ed22c82e385998a612351612f1d98a3528\",\"license\":\"GPL-3.0-or-later\"},\"contracts/interfaces/IPlonkVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/BN254.sol\\\";\\n\\ninterface IPlonkVerifier {\\n    // Flatten out TurboPlonk proof\\n    struct PlonkProof {\\n        // the first 5 are 4 inputs and 1 output wire poly commmitments\\n        // i.e., batch_proof.wires_poly_comms_vec.iter()\\n        // wire0 is 32 bytes which is a pointer to BN254.G1Point\\n        BN254.G1Point wire0; // 0x00\\n        BN254.G1Point wire1; // 0x20\\n        BN254.G1Point wire2; // 0x40\\n        BN254.G1Point wire3; // 0x60\\n        BN254.G1Point wire4; // 0x80\\n        // the next one is the  product permutation poly commitment\\n        // i.e., batch_proof.prod_perm_poly_comms_vec.iter()\\n        BN254.G1Point prodPerm; // 0xA0\\n        // the next 5 are split quotient poly commmitments\\n        // i.e., batch_proof.split_quot_poly_comms\\n        BN254.G1Point split0; // 0xC0\\n        BN254.G1Point split1; // 0xE0\\n        BN254.G1Point split2; // 0x100\\n        BN254.G1Point split3; // 0x120\\n        BN254.G1Point split4; // 0x140\\n        // witness poly com for aggregated opening at `zeta`\\n        // i.e., batch_proof.opening_proof\\n        BN254.G1Point zeta; // 0x160\\n        // witness poly com for shifted opening at `zeta * \\\\omega`\\n        // i.e., batch_proof.shifted_opening_proof\\n        BN254.G1Point zetaOmega; // 0x180\\n        // wire poly eval at `zeta`\\n        uint256 wireEval0; // 0x1A0\\n        uint256 wireEval1; // 0x1C0\\n        uint256 wireEval2; // 0x1E0\\n        uint256 wireEval3; // 0x200\\n        uint256 wireEval4; // 0x220\\n        // extended permutation (sigma) poly eval at `zeta`\\n        // last (sigmaEval4) is saved by Maller Optimization\\n        uint256 sigmaEval0; // 0x240\\n        uint256 sigmaEval1; // 0x260\\n        uint256 sigmaEval2; // 0x280\\n        uint256 sigmaEval3; // 0x2A0\\n        // product permutation poly eval at `zeta * \\\\omega`\\n        uint256 prodPermZetaOmegaEval; // 0x2C0\\n    }\\n\\n    // The verifying key for Plonk proofs.\\n    struct VerifyingKey {\\n        uint256 domainSize; // 0x00\\n        uint256 numInputs; // 0x20\\n        // commitment to extended perm (sigma) poly\\n        BN254.G1Point sigma0; // 0x40\\n        BN254.G1Point sigma1; // 0x60\\n        BN254.G1Point sigma2; // 0x80\\n        BN254.G1Point sigma3; // 0xA0\\n        BN254.G1Point sigma4; // 0xC0\\n        // commitment to selector poly\\n        // first 4 are linear combination selector\\n        BN254.G1Point q1; // 0xE0\\n        BN254.G1Point q2; // 0x100\\n        BN254.G1Point q3; // 0x120\\n        BN254.G1Point q4; // 0x140\\n        // multiplication selector for 1st, 2nd wire\\n        BN254.G1Point qM12; // 0x160\\n        // multiplication selector for 3rd, 4th wire\\n        BN254.G1Point qM34; // 0x180\\n        // output selector\\n        BN254.G1Point qO; // 0x1A0\\n        // constant term selector\\n        BN254.G1Point qC; // 0x1C0\\n        // rescue selector qH1 * w_ai^5\\n        BN254.G1Point qH1; // 0x1E0\\n        // rescue selector qH2 * w_bi^5\\n        BN254.G1Point qH2; // 0x200\\n        // rescue selector qH3 * w_ci^5\\n        BN254.G1Point qH3; // 0x220\\n        // rescue selector qH4 * w_di^5\\n        BN254.G1Point qH4; // 0x240\\n        // elliptic curve selector\\n        BN254.G1Point qEcc; // 0x260\\n    }\\n\\n    /// @dev Batch verify multiple TurboPlonk proofs.\\n    /// @param verifyingKeys An array of verifying keys\\n    /// @param publicInputs A two-dimensional array of public inputs.\\n    /// @param proofs An array of Plonk proofs\\n    /// @param extraTranscriptInitMsgs An array of bytes from\\n    /// transcript initialization messages\\n    /// @return _ A boolean that is true for successful verification, false otherwise\\n    function batchVerify(\\n        VerifyingKey[] memory verifyingKeys,\\n        uint256[][] memory publicInputs,\\n        PlonkProof[] memory proofs,\\n        bytes[] memory extraTranscriptInitMsgs\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x00fe49efd24714544a8bec75e0a179a07f80752b72e4840a894e574b663baa3b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/AccumulatingArray.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/// @title AccumulatingArray library\\n/// @dev This library simplifies inserting elements into an array by keeping track\\n///      of the insertion index.\\n\\nlibrary AccumulatingArray {\\n    struct Data {\\n        uint256[] items;\\n        uint256 index;\\n    }\\n\\n    /// @dev Create a new AccumulatingArray\\n    /// @param length the number of items that will be inserted\\n    function create(uint256 length) internal pure returns (Data memory) {\\n        return Data(new uint256[](length), 0);\\n    }\\n\\n    /// @param items the items to accumulate\\n    /// @dev Will revert if items past length are added.\\n    function add(Data memory self, uint256[] memory items) internal pure {\\n        for (uint256 i = 0; i < items.length; i++) {\\n            self.items[i + self.index] = items[i];\\n        }\\n        self.index += items.length;\\n    }\\n\\n    /// @param item the item to accumulate.\\n    /// @dev Will revert if items past length are added.\\n    function add(Data memory self, uint256 item) internal pure {\\n        self.items[self.index] = item;\\n        self.index += 1;\\n    }\\n\\n    function isEmpty(Data memory self) internal pure returns (bool) {\\n        return (self.index == 0);\\n    }\\n}\\n\",\"keccak256\":\"0x7c1c8c932bc1b218fcf7d977efc140d0ff3f29f6ae7aa6cf7c6230ea7a78d7af\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/BN254.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// Based on:\\n// - Christian Reitwiessner: https://gist.githubusercontent.com/chriseth/f9be9d9391efc5beb9704255a8e2989d/raw/4d0fb90847df1d4e04d507019031888df8372239/snarktest.solidity\\n// - Aztec: https://github.com/AztecProtocol/aztec-2-bug-bounty\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Utils.sol\\\";\\n\\n/// @notice Barreto-Naehrig curve over a 254 bit prime field\\nlibrary BN254 {\\n    // use notation from https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/\\n    //\\n    // Elliptic curve is defined over a prime field GF(p), with embedding degree k.\\n    // Short Weierstrass (SW form) is, for a, b \\\\in GF(p^n) for some natural number n > 0:\\n    //   E: y^2 = x^3 + a * x + b\\n    //\\n    // Pairing is defined over cyclic subgroups G1, G2, both of which are of order r.\\n    // G1 is a subgroup of E(GF(p)), G2 is a subgroup of E(GF(p^k)).\\n    //\\n    // BN family are parameterized curves with well-chosen t,\\n    //   p = 36 * t^4 + 36 * t^3 + 24 * t^2 + 6 * t + 1\\n    //   r = 36 * t^4 + 36 * t^3 + 18 * t^2 + 6 * t + 1\\n    // for some integer t.\\n    // E has the equation:\\n    //   E: y^2 = x^3 + b\\n    // where b is a primitive element of multiplicative group (GF(p))^* of order (p-1).\\n    // A pairing e is defined by taking G1 as a subgroup of E(GF(p)) of order r,\\n    // G2 as a subgroup of E'(GF(p^2)),\\n    // and G_T as a subgroup of a multiplicative group (GF(p^12))^* of order r.\\n    //\\n    // BN254 is defined over a 254-bit prime order p, embedding degree k = 12.\\n    uint256 public constant P_MOD =\\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 public constant R_MOD =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fp2 = x0 * z + x1\\n    struct G2Point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    /// @return the generator of G1\\n    // solhint-disable-next-line func-name-mixedcase\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    /// @return the generator of G2\\n    // solhint-disable-next-line func-name-mixedcase\\n    function P2() internal pure returns (G2Point memory) {\\n        return\\n            G2Point({\\n                x0: 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                x1: 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,\\n                y0: 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                y1: 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n            });\\n    }\\n\\n    /// @dev check if a G1 point is Infinity\\n    /// @notice precompile bn256Add at address(6) takes (0, 0) as Point of Infinity,\\n    /// some crypto libraries (such as arkwork) uses a boolean flag to mark PoI, and\\n    /// just use (0, 1) as affine coordinates (not on curve) to represents PoI.\\n    function isInfinity(G1Point memory point) internal pure returns (bool result) {\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n            result := and(iszero(x), iszero(y))\\n        }\\n    }\\n\\n    /// @return r the negation of p, i.e. p.add(p.negate()) should be zero.\\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\\n        if (isInfinity(p)) {\\n            return p;\\n        }\\n        return G1Point(p.x, P_MOD - (p.y % P_MOD));\\n    }\\n\\n    /// @return res = -fr the negation of scalar field element.\\n    function negate(uint256 fr) internal pure returns (uint256 res) {\\n        return R_MOD - (fr % R_MOD);\\n    }\\n\\n    /// @return r the sum of two points of G1\\n    function add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n        uint256[4] memory input;\\n        input[0] = p1.x;\\n        input[1] = p1.y;\\n        input[2] = p2.x;\\n        input[3] = p2.y;\\n        bool success;\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"Bn254: group addition failed!\\\");\\n    }\\n\\n    /// @return r the product of a point on G1 and a scalar, i.e.\\n    /// p == p.mul(1) and p.add(p) == p.mul(2) for all points p.\\n    function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\\n        uint256[3] memory input;\\n        input[0] = p.x;\\n        input[1] = p.y;\\n        input[2] = s;\\n        bool success;\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"Bn254: scalar mul failed!\\\");\\n    }\\n\\n    /// @dev Multi-scalar Mulitiplication (MSM)\\n    /// @return r = \\\\Prod{B_i^s_i} where {s_i} are `scalars` and {B_i} are `bases`\\n    function multiScalarMul(G1Point[] memory bases, uint256[] memory scalars)\\n        internal\\n        view\\n        returns (G1Point memory r)\\n    {\\n        require(scalars.length == bases.length, \\\"MSM error: length does not match\\\");\\n\\n        r = scalarMul(bases[0], scalars[0]);\\n        for (uint256 i = 1; i < scalars.length; i++) {\\n            r = add(r, scalarMul(bases[i], scalars[i]));\\n        }\\n    }\\n\\n    /// @dev Compute f^-1 for f \\\\in Fr scalar field\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function invert(uint256 fr) internal view returns (uint256 output) {\\n        bool success;\\n        uint256 p = R_MOD;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), fr)\\n            mstore(add(mPtr, 0x80), sub(p, 2))\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            output := mload(0x00)\\n        }\\n        require(success, \\\"Bn254: pow precompile failed!\\\");\\n    }\\n\\n    /**\\n     * validate the following:\\n     *   x != 0\\n     *   y != 0\\n     *   x < p\\n     *   y < p\\n     *   y^2 = x^3 + 3 mod p\\n     */\\n    /// @dev validate G1 point and check if it is on curve\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function validateG1Point(G1Point memory point) internal pure {\\n        bool isWellFormed;\\n        uint256 p = P_MOD;\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n\\n            isWellFormed := and(\\n                and(and(lt(x, p), lt(y, p)), not(or(iszero(x), iszero(y)))),\\n                eq(mulmod(y, y, p), addmod(mulmod(x, mulmod(x, x, p), p), 3, p))\\n            )\\n        }\\n        require(isWellFormed, \\\"Bn254: invalid G1 point\\\");\\n    }\\n\\n    /// @dev Validate scalar field, revert if invalid (namely if fr > r_mod).\\n    /// @notice Writing this inline instead of calling it might save gas.\\n    function validateScalarField(uint256 fr) internal pure {\\n        bool isValid;\\n        assembly {\\n            isValid := lt(fr, R_MOD)\\n        }\\n        require(isValid, \\\"Bn254: invalid scalar field\\\");\\n    }\\n\\n    /// @dev Evaluate the following pairing product:\\n    /// @dev e(a1, a2).e(-b1, b2) == 1\\n    /// @dev caller needs to ensure that a1, a2, b1 and b2 are within proper group\\n    /// @notice credit: Aztec, Spilsbury Holdings Ltd\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        uint256 out;\\n        bool success;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, mload(a1))\\n            mstore(add(mPtr, 0x20), mload(add(a1, 0x20)))\\n            mstore(add(mPtr, 0x40), mload(a2))\\n            mstore(add(mPtr, 0x60), mload(add(a2, 0x20)))\\n            mstore(add(mPtr, 0x80), mload(add(a2, 0x40)))\\n            mstore(add(mPtr, 0xa0), mload(add(a2, 0x60)))\\n\\n            mstore(add(mPtr, 0xc0), mload(b1))\\n            mstore(add(mPtr, 0xe0), mload(add(b1, 0x20)))\\n            mstore(add(mPtr, 0x100), mload(b2))\\n            mstore(add(mPtr, 0x120), mload(add(b2, 0x20)))\\n            mstore(add(mPtr, 0x140), mload(add(b2, 0x40)))\\n            mstore(add(mPtr, 0x160), mload(add(b2, 0x60)))\\n            success := staticcall(gas(), 8, mPtr, 0x180, 0x00, 0x20)\\n            out := mload(0x00)\\n        }\\n        require(success, \\\"Bn254: Pairing check failed!\\\");\\n        return (out != 0);\\n    }\\n\\n    function fromLeBytesModOrder(bytes memory leBytes) internal pure returns (uint256 ret) {\\n        for (uint256 i = 0; i < leBytes.length; i++) {\\n            ret = mulmod(ret, 256, R_MOD);\\n            ret = addmod(ret, uint256(uint8(leBytes[leBytes.length - 1 - i])), R_MOD);\\n        }\\n    }\\n\\n    /// @dev Check if y-coordinate of G1 point is negative.\\n    function isYNegative(G1Point memory point) internal pure returns (bool) {\\n        return (point.y << 1) < P_MOD;\\n    }\\n\\n    // @dev Perform a modular exponentiation.\\n    // @return base^exponent (mod modulus)\\n    // This method is ideal for small exponents (~64 bits or less), as it is cheaper than using the pow precompile\\n    // @notice credit: credit: Aztec, Spilsbury Holdings Ltd\\n    function powSmall(\\n        uint256 base,\\n        uint256 exponent,\\n        uint256 modulus\\n    ) internal pure returns (uint256) {\\n        uint256 result = 1;\\n        uint256 input = base;\\n        uint256 count = 1;\\n\\n        assembly {\\n            let endpoint := add(exponent, 0x01)\\n            for {\\n\\n            } lt(count, endpoint) {\\n                count := add(count, count)\\n            } {\\n                if and(exponent, count) {\\n                    result := mulmod(result, input, modulus)\\n                }\\n                input := mulmod(input, input, modulus)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function g1Serialize(G1Point memory point) internal pure returns (bytes memory) {\\n        uint256 mask;\\n\\n        // Set the 254-th bit to 1 for infinity\\n        // https://docs.rs/ark-serialize/0.3.0/src/ark_serialize/flags.rs.html#117\\n        if (isInfinity(point)) {\\n            mask |= 0x4000000000000000000000000000000000000000000000000000000000000000;\\n        }\\n\\n        // Set the 255-th bit to 1 for positive Y\\n        // https://docs.rs/ark-serialize/0.3.0/src/ark_serialize/flags.rs.html#118\\n        if (!isYNegative(point)) {\\n            mask = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n        }\\n\\n        return abi.encodePacked(Utils.reverseEndianness(point.x | mask));\\n    }\\n\\n    function g1Deserialize(bytes32 input) internal view returns (G1Point memory point) {\\n        uint256 mask = 0x4000000000000000000000000000000000000000000000000000000000000000;\\n        uint256 x = Utils.reverseEndianness(uint256(input));\\n        uint256 y;\\n        bool isQuadraticResidue;\\n        bool isYPositive;\\n        if (x & mask != 0) {\\n            // the 254-th bit == 1 for infinity\\n            x = 0;\\n            y = 0;\\n        } else {\\n            // Set the 255-th bit to 1 for positive Y\\n            mask = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n            isYPositive = (x & mask != 0);\\n            // mask off the first two bits of x\\n            mask = 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n            x &= mask;\\n\\n            // solve for y where E: y^2 = x^3 + 3\\n            y = mulmod(x, x, P_MOD);\\n            y = mulmod(y, x, P_MOD);\\n            y = addmod(y, 3, P_MOD);\\n            (isQuadraticResidue, y) = quadraticResidue(y);\\n\\n            require(isQuadraticResidue, \\\"deser fail: not on curve\\\");\\n\\n            if (isYPositive) {\\n                y = P_MOD - y;\\n            }\\n        }\\n\\n        point = G1Point(x, y);\\n    }\\n\\n    function quadraticResidue(uint256 x)\\n        internal\\n        view\\n        returns (bool isQuadraticResidue, uint256 a)\\n    {\\n        bool success;\\n        // e = (p+1)/4\\n        uint256 e = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52;\\n        uint256 p = P_MOD;\\n\\n        // we have p == 3 mod 4 therefore\\n        // a = x^((p+1)/4)\\n        assembly {\\n            // credit: Aztec\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), x)\\n            mstore(add(mPtr, 0x80), e)\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            a := mload(0x00)\\n        }\\n        require(success, \\\"pow precompile call failed!\\\");\\n\\n        // ensure a < p/2\\n        if (a << 1 > p) {\\n            a = p - a;\\n        }\\n\\n        // check if a^2 = x, if not x is not a quadratic residue\\n        e = mulmod(a, a, p);\\n\\n        isQuadraticResidue = (e == x);\\n    }\\n}\\n\",\"keccak256\":\"0x159e456383bb5a73c075e8e5fcb135b188636e58735e31a9dfee25816abc73c8\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/EdOnBN254.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/Utils.sol\\\";\\n\\n/// @notice Edward curve on BN254.\\n/// This library only implements a serialization function that is consistent with\\n/// Arkworks' format. It does not support any group operations.\\nlibrary EdOnBN254 {\\n    uint256 public constant P_MOD =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    struct EdOnBN254Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    /// @dev check if a G1 point is Infinity\\n    /// @notice precompile bn256Add at address(6) takes (0, 0) as Point of Infinity,\\n    /// some crypto libraries (such as arkwork) uses a boolean flag to mark PoI, and\\n    /// just use (0, 1) as affine coordinates (not on curve) to represents PoI.\\n    function isInfinity(EdOnBN254Point memory point) internal pure returns (bool result) {\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n            result := and(iszero(x), iszero(y))\\n        }\\n    }\\n\\n    /// @dev Check if y-coordinate of G1 point is negative.\\n    function isYNegative(EdOnBN254Point memory point) internal pure returns (bool) {\\n        return (point.y << 1) < P_MOD;\\n    }\\n\\n    function serialize(EdOnBN254Point memory point) internal pure returns (bytes memory res) {\\n        uint256 mask;\\n        // Edward curve does not have an infinity flag.\\n        // Set the 255-th bit to 1 for positive Y\\n        // See: https://github.com/arkworks-rs/algebra/blob/d6365c3a0724e5d71322fe19cbdb30f979b064c8/serialize/src/flags.rs#L148\\n        if (!EdOnBN254.isYNegative(point)) {\\n            mask = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n        }\\n\\n        return abi.encodePacked(Utils.reverseEndianness(point.x | mask));\\n    }\\n}\\n\",\"keccak256\":\"0xebc999b75f51ae35fa82148a91f14b14ce346083a7a1149956c1c7632e517ff4\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Freeze2In2Out24DepthVk.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\n// NOTE: DO NOT MODIFY! GENERATED BY SCRIPT VIA `cargo run --bin gen-vk-libraries --release`.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport \\\"./BN254.sol\\\";\\n\\nlibrary Freeze2In2Out24DepthVk {\\n    function getVk() internal pure returns (IPlonkVerifier.VerifyingKey memory vk) {\\n        assembly {\\n            // domain size\\n            mstore(vk, 32768)\\n            // num of public inputs\\n            mstore(add(vk, 0x20), 7)\\n\\n            // sigma0\\n            mstore(\\n                mload(add(vk, 0x40)),\\n                5118137774697846205332813764527928981094534629179826197661885163309718792664\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x40)), 0x20),\\n                21444510867008360096097791654924066970628086592132286765149218644570218218958\\n            )\\n            // sigma1\\n            mstore(\\n                mload(add(vk, 0x60)),\\n                8803078987858664729272498900762799875194584982758288268215987493230494163132\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x60)), 0x20),\\n                2433303804972293717223914306424233027859258355453999879123493306111951897773\\n            )\\n            // sigma2\\n            mstore(\\n                mload(add(vk, 0x80)),\\n                3260803333275595200572169884988811547059839215101652317716205725226978273005\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x80)), 0x20),\\n                3613466037895382109608881276133312019690204476510004381563636709063308697093\\n            )\\n            // sigma3\\n            mstore(\\n                mload(add(vk, 0xa0)),\\n                2899439069156777615431510251772750434873724497570948892914993632800602868003\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xa0)), 0x20),\\n                8379069052308825781842073463279139505822176676050290986587894691217284563176\\n            )\\n            // sigma4\\n            mstore(\\n                mload(add(vk, 0xc0)),\\n                11732815069861807091165298838511758216456754114248634732985660813617441774658\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xc0)), 0x20),\\n                13166648630773672378735632573860809427570624939066078822309995911184719468349\\n            )\\n\\n            // q1\\n            mstore(\\n                mload(add(vk, 0xe0)),\\n                3491113372305405096734724369052497193940883294098266073462122391919346338715\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xe0)), 0x20),\\n                9827940866231584614489847721346069816554104560301469101889136447541239075558\\n            )\\n            // q2\\n            mstore(\\n                mload(add(vk, 0x100)),\\n                13435736629650136340196094187820825115318808951343660439499146542480924445056\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x100)), 0x20),\\n                17982003639419860944219119425071532203644939147988825284644182004036282633420\\n            )\\n            // q3\\n            mstore(\\n                mload(add(vk, 0x120)),\\n                9420441314344923881108805693844267870391289724837370305813596950535269618889\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x120)), 0x20),\\n                14052028114719021167053334693322209909986772869796949309216011765205181071250\\n            )\\n            // q4\\n            mstore(\\n                mload(add(vk, 0x140)),\\n                5993794253539477186956400554691260472169114800994727061541419240125118730670\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x140)), 0x20),\\n                7932960467420473760327919608797843731121974235494949218022535850994096308221\\n            )\\n\\n            // qM12\\n            mstore(\\n                mload(add(vk, 0x160)),\\n                20429406452243707916630058273965650451352739230543746812138739882954609124362\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x160)), 0x20),\\n                19692763177526054221606086118119451355223254880919552106296824049356634107628\\n            )\\n            // qM34\\n            mstore(\\n                mload(add(vk, 0x180)),\\n                5116116081275540865026368436909879211124168610156815899416152073819842308833\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x180)), 0x20),\\n                19842614482623746480218449373220727139999815807703100436601033251034509288020\\n            )\\n\\n            // qO\\n            mstore(\\n                mload(add(vk, 0x1a0)),\\n                3222495709067365879961349438698872943831082393186134710609177690951286365439\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1a0)), 0x20),\\n                3703532585269560394637679600890000571417416525562741673639173852507841008896\\n            )\\n            // qC\\n            mstore(\\n                mload(add(vk, 0x1c0)),\\n                14390471925844384916287376853753782482889671388409569687933776522892272411453\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1c0)), 0x20),\\n                12261059506574689542871751331715340905672203590996080541963527436628201655551\\n            )\\n            // qH1\\n            mstore(\\n                mload(add(vk, 0x1e0)),\\n                212133813390818941086614328570019936880884093617125797928913969643819686094\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1e0)), 0x20),\\n                2058275687345409085609950154451527352761528547310163982911053914079075244754\\n            )\\n            // qH2\\n            mstore(\\n                mload(add(vk, 0x200)),\\n                7507728187668840967683000771945777493711131652056583548804845913578647015848\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x200)), 0x20),\\n                15764897865018924692970368330703479768257677759902236501992745661340099646248\\n            )\\n            // qH3\\n            mstore(\\n                mload(add(vk, 0x220)),\\n                18302496468173370667823199324779836313672317342261283918121073083547306893947\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x220)), 0x20),\\n                8286815911028648157724790867291052312955947067988434001008620797971639607610\\n            )\\n            // qH4\\n            mstore(\\n                mload(add(vk, 0x240)),\\n                3470304694844212768511296992238419575123994956442939632524758781128057967608\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x240)), 0x20),\\n                9660892985889164184033149081062412611630238705975373538019042544308335432760\\n            )\\n            // qEcc\\n            mstore(\\n                mload(add(vk, 0x260)),\\n                2964316839877400858567376484261923751031240259689039666960763176068018735519\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x260)), 0x20),\\n                12811532772714855857084788747474913882317963037829729036129619334772557515102\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x31d2eb06d25a9c2d9216e0715ee3db8eedce5a02bc0923f70d123430f0df2c0e\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Freeze3In3Out24DepthVk.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\n// NOTE: DO NOT MODIFY! GENERATED BY SCRIPT VIA `cargo run --bin gen-vk-libraries --release`.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport \\\"./BN254.sol\\\";\\n\\nlibrary Freeze3In3Out24DepthVk {\\n    function getVk() internal pure returns (IPlonkVerifier.VerifyingKey memory vk) {\\n        assembly {\\n            // domain size\\n            mstore(vk, 32768)\\n            // num of public inputs\\n            mstore(add(vk, 0x20), 9)\\n\\n            // sigma0\\n            mstore(\\n                mload(add(vk, 0x40)),\\n                13960731824189571867091334541157339805012676983241098249236778497915465352053\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x40)), 0x20),\\n                15957967148909612161116218663566087497068811688498797226467515095325657152045\\n            )\\n            // sigma1\\n            mstore(\\n                mload(add(vk, 0x60)),\\n                10072587287838607559866316765624459623039578259829899225485734337870604479821\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x60)), 0x20),\\n                15609102652788964903340031795269302405421393375766454476378251576322947285858\\n            )\\n            // sigma2\\n            mstore(\\n                mload(add(vk, 0x80)),\\n                6565707169634610873662073730120423414251877113110818166564470784428289496576\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x80)), 0x20),\\n                9611712776953584296612678707999788907754017999002246476393974258810867124564\\n            )\\n            // sigma3\\n            mstore(\\n                mload(add(vk, 0xa0)),\\n                19122400063214294010991425447556532201595762243736666161415050184531098654161\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xa0)), 0x20),\\n                8531074110951311734071734321378003618052738734286317677359289798683215129985\\n            )\\n            // sigma4\\n            mstore(\\n                mload(add(vk, 0xc0)),\\n                18914674706112982859579196036464470962561796494057486369943014188445892675591\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xc0)), 0x20),\\n                8521550178820292984099911306615540388090622911114862049753515592863829430736\\n            )\\n\\n            // q1\\n            mstore(\\n                mload(add(vk, 0xe0)),\\n                14630335835391046544786473024276900306274085179180854494149987003151236405693\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xe0)), 0x20),\\n                11927636740621831793456799535735389934490350641107279163802406976389995490906\\n            )\\n            // q2\\n            mstore(\\n                mload(add(vk, 0x100)),\\n                12724914112829888521503996001370933887413324349676112061904353298191125761834\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x100)), 0x20),\\n                3433370683786676509006167821257247081483834358490691629467376279251656650897\\n            )\\n            // q3\\n            mstore(\\n                mload(add(vk, 0x120)),\\n                9566744544381523978155846140753126684369534823789897373672815695046810310988\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x120)), 0x20),\\n                260017699035964770662690666115311602214922546306804012310168827438556483441\\n            )\\n            // q4\\n            mstore(\\n                mload(add(vk, 0x140)),\\n                18742890127040989288898023133652949889864689947035150783791742574000686319400\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x140)), 0x20),\\n                18749161983189150319356152659011703669863797011859087161475368338926038180308\\n            )\\n\\n            // qM12\\n            mstore(\\n                mload(add(vk, 0x160)),\\n                20773233313791930222139945008080890514898946888819625041024291924369611870607\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x160)), 0x20),\\n                13521724424975535658347353167027580945107539483287924982357298371687877483981\\n            )\\n            // qM34\\n            mstore(\\n                mload(add(vk, 0x180)),\\n                10660982607928179139814177842882617778440401746692506684983260589289268170379\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x180)), 0x20),\\n                15139413484465466645149010003574654339361200137557967877891360282092282891685\\n            )\\n\\n            // qO\\n            mstore(\\n                mload(add(vk, 0x1a0)),\\n                17250558007005834955604250406579207360748810924758511953913092810009135851470\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1a0)), 0x20),\\n                11258418978437321501318046240697776859180107275977030400553604411488978149668\\n            )\\n            // qC\\n            mstore(\\n                mload(add(vk, 0x1c0)),\\n                18952078950487788846193130112459018587473354670050028821020889375362878213321\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1c0)), 0x20),\\n                17193026626593699161155564126784943150078109362562131961513990003707313130311\\n            )\\n            // qH1\\n            mstore(\\n                mload(add(vk, 0x1e0)),\\n                14543481681504505345294846715453463092188884601462120536722150134676588633429\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1e0)), 0x20),\\n                18051927297986484527611703191585266713528321784715802343699150271856051244721\\n            )\\n            // qH2\\n            mstore(\\n                mload(add(vk, 0x200)),\\n                17183091890960203175777065490726876011944304977299231686457191186480347944964\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x200)), 0x20),\\n                4490401529426574565331238171714181866458606184922225399124187058005801778892\\n            )\\n            // qH3\\n            mstore(\\n                mload(add(vk, 0x220)),\\n                1221754396433704762941109064372027557900417150628742839724350141274324105531\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x220)), 0x20),\\n                5852202975250895807153833762470523277935452126865915206223172229093142057204\\n            )\\n            // qH4\\n            mstore(\\n                mload(add(vk, 0x240)),\\n                15942219407079940317108327336758085920828255563342347502490598820248118460133\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x240)), 0x20),\\n                13932908789216121516788648116401360726086794781411868046768741292235436938527\\n            )\\n            // qEcc\\n            mstore(\\n                mload(add(vk, 0x260)),\\n                11253921189643581015308547816247612243572238063440388125238308675751100437670\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x260)), 0x20),\\n                21538818198962061056994656088458979220103547193654086011201760604068846580076\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5901613650e96c8f5056d2c86c6c239f47ddff10dd63fe495dfca0fc306d8bbb\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Mint1In2Out24DepthVk.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\n// NOTE: DO NOT MODIFY! GENERATED BY SCRIPT VIA `cargo run --bin gen-vk-libraries --release`.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport \\\"./BN254.sol\\\";\\n\\nlibrary Mint1In2Out24DepthVk {\\n    function getVk() internal pure returns (IPlonkVerifier.VerifyingKey memory vk) {\\n        assembly {\\n            // domain size\\n            mstore(vk, 16384)\\n            // num of public inputs\\n            mstore(add(vk, 0x20), 22)\\n\\n            // sigma0\\n            mstore(\\n                mload(add(vk, 0x40)),\\n                14708041522873209202464618950611504807168696855480720848360413590326729841973\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x40)), 0x20),\\n                2753391240893238116569628860982882954353792578019920766428726340611015647581\\n            )\\n            // sigma1\\n            mstore(\\n                mload(add(vk, 0x60)),\\n                3736215203151709462427825581991044329817961401819325086573903036518525176090\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x60)), 0x20),\\n                12284473618321395163309979733066433449809233564826193169921444928840687100523\\n            )\\n            // sigma2\\n            mstore(\\n                mload(add(vk, 0x80)),\\n                11948153932361754444295437431688112113763465916556532032853808907007255324832\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x80)), 0x20),\\n                5247166478759706764702942889858430530186042193040312355719301585036655612459\\n            )\\n            // sigma3\\n            mstore(\\n                mload(add(vk, 0xa0)),\\n                17184781586365391989471544204947701083939573062775992140067289916802254834188\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xa0)), 0x20),\\n                1695548810031655609675397387003567906043418871571997772255611361115032629003\\n            )\\n            // sigma4\\n            mstore(\\n                mload(add(vk, 0xc0)),\\n                4501183465908078766709944423483386166697765379860531518789327025791827694266\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xc0)), 0x20),\\n                17179919563903728314665267245084588379374464645703406635631119875332721091062\\n            )\\n\\n            // q1\\n            mstore(\\n                mload(add(vk, 0xe0)),\\n                8233664603830467551407560711982259529601063264885744179029753653795440811880\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xe0)), 0x20),\\n                15890473389663313484400232619457945250113260815521617218577960950923821395961\\n            )\\n            // q2\\n            mstore(\\n                mload(add(vk, 0x100)),\\n                14842917854453150581899781597532237976322234382964084206933989618934323526445\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x100)), 0x20),\\n                16447842172982150537473552975294340243672291348134029457070764238385172728852\\n            )\\n            // q3\\n            mstore(\\n                mload(add(vk, 0x120)),\\n                9473551627160998361000472320259848783011643008757616507618705701015024223999\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x120)), 0x20),\\n                11314416338785822922260197499038268393262643508579752114469422388580655977102\\n            )\\n            // q4\\n            mstore(\\n                mload(add(vk, 0x140)),\\n                3736408701597418834318726881826839552728418266216645424811344776852549712816\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x140)), 0x20),\\n                9236488906535632856862877101736177223606785065252708856745807157980987984387\\n            )\\n\\n            // qM12\\n            mstore(\\n                mload(add(vk, 0x160)),\\n                14102260043757883202366109964215541081299927672047603711818995797147714865094\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x160)), 0x20),\\n                17534575210236353125951475539478479017023300116581894838767353256804423795888\\n            )\\n            // qM34\\n            mstore(\\n                mload(add(vk, 0x180)),\\n                9147214868025953364750888491087621905427748656716737534941501783669122960379\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x180)), 0x20),\\n                1392401634629635498019533543932086568632128115192597982401550578444977393547\\n            )\\n\\n            // qO\\n            mstore(\\n                mload(add(vk, 0x1a0)),\\n                10905264501530050014704452452494914745596183555206362825031535539577170367475\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1a0)), 0x20),\\n                17138899495046135206471329677572657240135846790961757879454458120765242310575\\n            )\\n            // qC\\n            mstore(\\n                mload(add(vk, 0x1c0)),\\n                16573281449079492002777383418086249227397635509941971752517637461403659421155\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1c0)), 0x20),\\n                4575446980340017635017887407539797482781705198893380506254262640090465211655\\n            )\\n            // qH1\\n            mstore(\\n                mload(add(vk, 0x1e0)),\\n                9089742723053765306677953175198389661353135493790082378155841294705327694917\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1e0)), 0x20),\\n                11133242012031704156289281393180107718619015102295906028702493235407386901280\\n            )\\n            // qH2\\n            mstore(\\n                mload(add(vk, 0x200)),\\n                10009477156249913501931891243909788618345391893663991287711709770530743764439\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x200)), 0x20),\\n                2335006503907830689782212423634682006869891487153768081847010024128012642090\\n            )\\n            // qH3\\n            mstore(\\n                mload(add(vk, 0x220)),\\n                204582489322604335877947037789506354815242950315871800117188914050721754147\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x220)), 0x20),\\n                4017254452065892946191861754786121551706223202798323858822829895419210960406\\n            )\\n            // qH4\\n            mstore(\\n                mload(add(vk, 0x240)),\\n                3674255676567461700605617197873932900311232245160095442299763249794134579502\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x240)), 0x20),\\n                14717173916044651338237546750276495403229974586112157441016319173772835390378\\n            )\\n            // qEcc\\n            mstore(\\n                mload(add(vk, 0x260)),\\n                12191628753324517001666106106337946847104780287136368645491927996790130156414\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x260)), 0x20),\\n                13305212653333031744208722140065322148127616384688600512629199891590396358314\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x21b3abf227e93abcb4bc8b2858d17a6c96ba38c3f16ce50a998cd1acd09ae4e9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/RescueLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary RescueLib {\\n    /// The constants are obtained from the Sage script\\n    /// https://github.com/EspressoSystems/Marvellous/blob/fcd4c41672f485ac2f62526bc87a16789d4d0459/rescue254.sage\\n\\n    uint256 private constant _N_ROUNDS = 12;\\n    uint256 private constant _STATE_SIZE = 4;\\n    uint256 private constant _SCHEDULED_KEY_SIZE = (2 * _N_ROUNDS + 1) * _STATE_SIZE;\\n\\n    // Obtained by running KeyScheduling([0,0,0,0]). See Algorithm 2 of AT specification document.\\n    // solhint-disable-next-line var-name-mixedcase\\n\\n    uint256 private constant _PRIME =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    uint256 private constant _ALPHA = 5;\\n\\n    uint256 private constant _ALPHA_INV =\\n        17510594297471420177797124596205820070838691520332827474958563349260646796493;\\n\\n    // MDS is hardcoded\\n    function _linearOp(\\n        uint256 s0,\\n        uint256 s1,\\n        uint256 s2,\\n        uint256 s3\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Matrix multiplication\\n        unchecked {\\n            return (\\n                mulmod(\\n                    21888242871839275222246405745257275088548364400416034343698204186575808479992,\\n                    s0,\\n                    _PRIME\\n                ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186575806058117,\\n                        s1,\\n                        _PRIME\\n                    ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186575491214367,\\n                        s2,\\n                        _PRIME\\n                    ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186535831058117,\\n                        s3,\\n                        _PRIME\\n                    ),\\n                mulmod(19500, s0, _PRIME) +\\n                    mulmod(3026375, s1, _PRIME) +\\n                    mulmod(393529500, s2, _PRIME) +\\n                    mulmod(49574560750, s3, _PRIME),\\n                mulmod(\\n                    21888242871839275222246405745257275088548364400416034343698204186575808491587,\\n                    s0,\\n                    _PRIME\\n                ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186575807886437,\\n                        s1,\\n                        _PRIME\\n                    ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186575729688812,\\n                        s2,\\n                        _PRIME\\n                    ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186565891044437,\\n                        s3,\\n                        _PRIME\\n                    ),\\n                mulmod(156, s0, _PRIME) +\\n                    mulmod(20306, s1, _PRIME) +\\n                    mulmod(2558556, s2, _PRIME) +\\n                    mulmod(320327931, s3, _PRIME)\\n            );\\n        }\\n    }\\n\\n    function _expAlphaInv4Setup(uint256[6] memory scratch) private pure {\\n        assembly {\\n            let p := scratch\\n            mstore(p, 0x20) // Length of Base\\n            mstore(add(p, 0x20), 0x20) // Length of Exponent\\n            mstore(add(p, 0x40), 0x20) // Length of Modulus\\n            mstore(add(p, 0x80), _ALPHA_INV) // Exponent\\n            mstore(add(p, 0xa0), _PRIME) // Modulus\\n        }\\n    }\\n\\n    function _expAlphaInv4(\\n        uint256[6] memory scratch,\\n        uint256 s0,\\n        uint256 s1,\\n        uint256 s2,\\n        uint256 s3\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 o0,\\n            uint256 o1,\\n            uint256 o2,\\n            uint256 o3\\n        )\\n    {\\n        assembly {\\n            // define pointer\\n            let p := scratch\\n            let basep := add(p, 0x60)\\n            mstore(basep, s0) // Base\\n            // store data assembly-favouring ways\\n            pop(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, basep, 0x20))\\n            // data\\n            o0 := mload(basep)\\n            mstore(basep, s1) // Base\\n            pop(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, basep, 0x20))\\n            // data\\n            o1 := mload(basep)\\n            mstore(basep, s2) // Base\\n            pop(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, basep, 0x20))\\n            // data\\n            o2 := mload(basep)\\n            mstore(basep, s3) // Base\\n            pop(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, basep, 0x20))\\n            // data\\n            o3 := mload(basep)\\n        }\\n    }\\n\\n    // Computes the Rescue permutation on some input\\n    // Recall that the scheduled key is precomputed in our case\\n    // @param input input for the permutation\\n    // @return permutation output\\n    function perm(\\n        uint256 s0,\\n        uint256 s1,\\n        uint256 s2,\\n        uint256 s3\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256[6] memory alphaInvScratch;\\n\\n        _expAlphaInv4Setup(alphaInvScratch);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 14613516837064033601098425266946467918409544647446217386229959902054563533267,\\n                s1 + 376600575581954944138907282479272751264978206975465380433764825531344567663,\\n                s2 + 7549886658634274343394883631367643327196152481472281919735617268044202589860,\\n                s3 + 3682071510138521345600424597536598375718773365536872232193107639375194756918\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                18657517374128716281071590782771170166993445602755371021955596036781411817786;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                7833794394096838639430144230563403530989402760602204539559270044687522640191;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                21303828694647266539931030987057572024333442749881970102454081226349775826204;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                10601447988834057856019990466870413629636256450824419416829818546423193802418;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 3394657260998945409283098835682964352503279447198495330506177586645995289229,\\n                s1 + 18437084083724939316390841967750487133622937044030373241106776324730657101302,\\n                s2 + 9281739916935170266925270432337475828741505406943764438550188362765269530037,\\n                s3 + 7363758719535652813463843693256839865026387361836644774317493432208443086206\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                307094088106440279963968943984309088038734274328527845883669678290790702381;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                20802277384865839022876847241719852837518994021170013346790603773477912819001;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                19754579269464973651593381036132218829220609572271224048608091445854164824042;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                3618840933841571232310395486452077846249117988789467996234635426899783130819;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 2604166168648013711791424714498680546427073388134923208733633668316805639713,\\n                s1 + 21355705619901626246699129842094174300693414345856149669339147704587730744579,\\n                s2 + 492957643799044929042114590851019953669919577182050726596188173945730031352,\\n                s3 + 8495959434717951575638107349559891417392372124707619959558593515759091841138\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                15608173629791582453867933160400609222904457931922627396107815347244961625587;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                16346164988481725869223011419855264063160651334419415042919928342589111681923;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                21085652277104054699752179865196164165969290053517659864117475352262716334100;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                20640310021063232205677193759981403045043444605175178332133134865746039279935;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 6015589261538006311719125697023069952804098656652050863009463360598997670240,\\n                s1 + 12498423882721726012743791752811798719201859023192663855805526312393108407357,\\n                s2 + 10785527781711732350693172404486938622378708235957779975342240483505724965040,\\n                s3 + 5563181134859229953817163002660048854420912281911747312557025480927280392569\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                4585980485870975597083581718044393941512074846925247225127276913719050121968;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                8135760428078872176830812746579993820254685977237403304445687861806698035222;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                4525715538433244696411192727226186804883202134636681498489663161593606654720;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                2537497100749435007113677475828631400227339157221711397900070636998427379023;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 6957758175844522415482704083077249782181516476067074624906502033584870962925,\\n                s1 + 17134288156316028142861248367413235848595762718317063354217292516610545487813,\\n                s2 + 20912428573104312239411321877435657586184425249645076131891636094671938892815,\\n                s3 + 16000236205755938926858829908701623009580043315308207671921283074116709575629\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                10226182617544046880850643054874064693998595520540061157646952229134207239372;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                18584346134948015676264599354709457865255277240606855245909703396343731224626;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                9263628039314899758000383385773954136696958567872461042004915206775147151562;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                21095966719856094705113273596585696209808876361583941931684481364905087347856;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 2671157351815122058649197205531097090514563992249109660044882868649840700911,\\n                s1 + 19371695134219415702961622134896564229962454573253508904477489696588594622079,\\n                s2 + 5458968308231210904289987830881528056037123818964633914555287871152343390175,\\n                s3 + 7336332584551233792026746889434554547883125466404119632794862500961953384162\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                10351436748086126474964482623536554036637945319698748519226181145454116702488;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                10588209357420186457766745724579739104572139534486480334142455690083813419064;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                14330277147584936710957102218096795520430543834717433464500965846826655802131;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                20752197679372238381408962682213349118865256502118746003818603260257076802028;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 19390446529582160674621825412345750405397926216690583196542690617266028463414,\\n                s1 + 4169994013656329171830126793466321040216273832271989491631696813297571003664,\\n                s2 + 3014817248268674641565961681956715664833306954478820029563459099892548946802,\\n                s3 + 14285412497877984113655094566695921704826935980354186365694472961163628072901\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                16224484149774307577146165975762490690838415946665379067259822320752729067513;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                5404416528124718330316441408560295270695591369912905197499507811036327404407;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                20127204244332635127213425090893250761286848618448128307344971109698523903374;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                14939477686176063572999014162186372798386193194442661892600584389296609365740;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 183740587182448242823071506013879595265109215202349952517434740768878294134,\\n                s1 + 15366166801397358994305040367078329374182896694582870542425225835844885654667,\\n                s2 + 10066796014802701613007252979619633540090232697942390802486559078446300507813,\\n                s3 + 4824035239925904398047276123907644574421550988870123756876333092498925242854\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                5526416022516734657935645023952329824887761902324086126076396040056459740202;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                18157816292703983306114736850721419851645159304249709756659476015594698876611;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                767446206481623130855439732549764381286210118638028499466788453347759203223;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                16303412231051555792435190427637047658258796056382698277687500021321460387129;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 15475465085113677237835653765189267963435264152924949727326000496982746660612,\\n                s1 + 14574823710073720047190393602502575509282844662732045439760066078137662816054,\\n                s2 + 13746490178929963947720756220409862158443939172096620003896874772477437733602,\\n                s3 + 13804898145881881347835367366352189037341704254740510664318597456840481739975\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                3523599105403569319090449327691358425990456728660349400211678603795116364226;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                8632053982708637954870974502506145434219829622278773822242070316888003350278;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                20293222318844554840191640739970825558851264905959070636369796127300969629060;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                7583204376683983181255811699503668584283525661852773339144064901897953897564;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 7562572155566079175343789986900217168516831778275127159068657756836798778249,\\n                s1 + 12689811910161401007144285031988539999455902164332232460061366402869461973371,\\n                s2 + 21878400680687418538050108788381481970431106443696421074205107984690362920637,\\n                s3 + 3428721187625124675258692786364137915132424621324969246210899039774126165479\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                2552744099402346352193097862110515290335034445517764751557635302899937367219;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                13706727374402840004346872704605212996406886221231239230397976011930486183550;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                19786308443934570499119114884492461847023732197118902978413499381102456961966;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                11767081169862697956461405434786280425108140215784390008330611807075539962898;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 1273319740931699377003430019539548781935202579355152343831464213279794249000,\\n                s1 + 20225620070386241931202098463018472034137960205721651875253423327929063224115,\\n                s2 + 13107884970924459680133954992354588464904218518440707039430314610799573960437,\\n                s3 + 10574066469653966216567896842413898230152427846140046825523989742590727910280\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                21386271527766270535632132320974945129946865648321206442664310421414128279311;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                15743262855527118149527268525857865250723531109306484598629175225221686341453;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                16251140915157602891864152518526119259367827194524273940185283798897653655734;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                5420158299017134702074915284768041702367316125403978919545323705661634647751;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 14555572526833606349832007897859411042036463045080050783981107823326880950231,\\n                s1 + 15234942318869557310939446038663331226792664588406507247341043508129993934298,\\n                s2 + 19560004467494472556570844694553210033340577742756929194362924850760034377042,\\n                s3 + 21851693551359717578445799046408060941161959589978077352548456186528047792150\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                19076469206110044175016166349949136119962165667268661130584159239385341119621;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                19132104531774396501521959463346904008488403861940301898725725957519076019017;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                6606159937109409334959297158878571243749055026127553188405933692223704734040;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                13442678592538344046772867528443594004918096722084104155946229264098946917042;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            return (\\n                s0 + 11975757366382164299373991853632416786161357061467425182041988114491638264212,\\n                s1 + 10571372363668414752587603575617060708758897046929321941050113299303675014148,\\n                s2 + 5405426474713644587066466463343175633538103521677501186003868914920014287031,\\n                s3 + 18665277628144856329335676361545218245401014824195451740181902217370165017984\\n            );\\n        }\\n    }\\n\\n    // Computes the hash of three field elements and returns a single element\\n    // In our case the rate is 3 and the capacity is 1\\n    // This hash function the one used in the Records Merkle tree.\\n    // @param a first element\\n    // @param b second element\\n    // @param c third element\\n    // @return the first element of the Rescue state\\n    function hash(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) public view returns (uint256 o) {\\n        (o, a, b, c) = perm(a % _PRIME, b % _PRIME, c % _PRIME, 0);\\n        o %= _PRIME;\\n    }\\n\\n    function checkBounded(uint256[15] memory inputs) internal pure {\\n        for (uint256 i = 0; i < inputs.length; ++i) {\\n            require(inputs[i] < _PRIME, \\\"inputs must be below _PRIME\\\");\\n        }\\n    }\\n\\n    // Must be public so it doesn't get inlined into CAPE.sol and blow\\n    // the size limit\\n    function commit(uint256[15] memory inputs) public view returns (uint256) {\\n        checkBounded(inputs);\\n\\n        uint256 a;\\n        uint256 b;\\n        uint256 c;\\n        uint256 d;\\n\\n        for (uint256 i = 0; i < 5; i++) {\\n            unchecked {\\n                (a, b, c, d) = perm(\\n                    (a + inputs[3 * i + 0]) % _PRIME,\\n                    (b + inputs[3 * i + 1]) % _PRIME,\\n                    (c + inputs[3 * i + 2]) % _PRIME,\\n                    d\\n                );\\n\\n                (a, b, c, d) = (a % _PRIME, b % _PRIME, c % _PRIME, d % _PRIME);\\n            }\\n        }\\n\\n        return a;\\n    }\\n}\\n\",\"keccak256\":\"0x440991b25b8f8e54f57e7d79e31152ae3424e10578268b9e8732926154e1ff93\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Transfer1In2Out24DepthVk.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\n// NOTE: DO NOT MODIFY! GENERATED BY SCRIPT VIA `cargo run --bin gen-vk-libraries --release`.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport \\\"./BN254.sol\\\";\\n\\nlibrary Transfer1In2Out24DepthVk {\\n    function getVk() internal pure returns (IPlonkVerifier.VerifyingKey memory vk) {\\n        assembly {\\n            // domain size\\n            mstore(vk, 32768)\\n            // num of public inputs\\n            mstore(add(vk, 0x20), 14)\\n\\n            // sigma0\\n            mstore(\\n                mload(add(vk, 0x40)),\\n                2601115423116897239893469437783815282674518870859439140584670982404446568425\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x40)), 0x20),\\n                21387703072596271753684269571766318413616637905846906200885488548605232081311\\n            )\\n            // sigma1\\n            mstore(\\n                mload(add(vk, 0x60)),\\n                18093207667326166260941967361503597170970820090303504008548886520781612262607\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x60)), 0x20),\\n                15506241883427907423143246742207987178296655397323901395523216644162934801027\\n            )\\n            // sigma2\\n            mstore(\\n                mload(add(vk, 0x80)),\\n                17224030688930263671215927622085796838744685640551295700644356316087606194453\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x80)), 0x20),\\n                9871892688266980794424413228644800345365261123544262124587988616929094794446\\n            )\\n            // sigma3\\n            mstore(\\n                mload(add(vk, 0xa0)),\\n                1653423479825136378929731986206672195437753469049273770949830103289522081013\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xa0)), 0x20),\\n                18540430158936383317781049369976810237215202752760467051838384048905582651431\\n            )\\n            // sigma4\\n            mstore(\\n                mload(add(vk, 0xc0)),\\n                6182405487934559918414504166029367587453938777975619206648907759838313063029\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xc0)), 0x20),\\n                6303636105426570943547672403434638798256828205198194404179645009191642748039\\n            )\\n\\n            // q1\\n            mstore(\\n                mload(add(vk, 0xe0)),\\n                18352717355200151877063864360131237083352005873169286557578537755751979692274\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xe0)), 0x20),\\n                18535115788456072630383925322523695497891623428396234248738154081372899880584\\n            )\\n            // q2\\n            mstore(\\n                mload(add(vk, 0x100)),\\n                9908258779995310745701077146291771577159654333216970234243768106420988535639\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x100)), 0x20),\\n                5222835988549975732420424607539021146071370844807206884805011103538281824730\\n            )\\n            // q3\\n            mstore(\\n                mload(add(vk, 0x120)),\\n                6941500137865112460544627950260307723514017850007311936769317146419972927588\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x120)), 0x20),\\n                15349893608573380976411985659730584619173031566937770787699017806561190627468\\n            )\\n            // q4\\n            mstore(\\n                mload(add(vk, 0x140)),\\n                21168364095257448760606101143948858356172338924320104703900203452473902441433\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x140)), 0x20),\\n                16660170798361651209023038026794900976183585114965877304784822006074874509205\\n            )\\n\\n            // qM12\\n            mstore(\\n                mload(add(vk, 0x160)),\\n                9190952913639104387810968179432225180425197597955362124827814569885452163057\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x160)), 0x20),\\n                18827142612117658766343514941168256204525012530604946506087566444465709027496\\n            )\\n            // qM34\\n            mstore(\\n                mload(add(vk, 0x180)),\\n                3087614871980473279723363167422819790187289361998206527420814175739516849267\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x180)), 0x20),\\n                16862987149935139591372068460264503091703957897443470436032581481036423083811\\n            )\\n\\n            // qO\\n            mstore(\\n                mload(add(vk, 0x1a0)),\\n                9706719488655451993063181268308257527997835452929632143872066940077818386420\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1a0)), 0x20),\\n                6236623652447614250698035805861101061802099331620117231564769714805411900300\\n            )\\n            // qC\\n            mstore(\\n                mload(add(vk, 0x1c0)),\\n                1411379008735327479737723833603528702843470627344722114111584994556861154980\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1c0)), 0x20),\\n                3993135852184128345174580298872023693588782847706666657191331001722079392092\\n            )\\n            // qH1\\n            mstore(\\n                mload(add(vk, 0x1e0)),\\n                9846511696349440200252734974300757392144763505883256681697549590162985402181\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1e0)), 0x20),\\n                2943021693042093632574100039021179834063372575819762871426673095266988807850\\n            )\\n            // qH2\\n            mstore(\\n                mload(add(vk, 0x200)),\\n                6939009262544205005507648947300385820226307867525750603310876841608771115967\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x200)), 0x20),\\n                1744542086304213974542290661478181313186513167898968854980022885020012543803\\n            )\\n            // qH3\\n            mstore(\\n                mload(add(vk, 0x220)),\\n                8552076371570768937374027634488546934769058846143601491495678997242529143831\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x220)), 0x20),\\n                9579090530940855809150547321287606050563533435045744882440421353731349593486\\n            )\\n            // qH4\\n            mstore(\\n                mload(add(vk, 0x240)),\\n                14499786686191977429340953516175958437978725979354053072854149749281625153583\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x240)), 0x20),\\n                12761628950782571856606556112616580736578801583124069040637032554972765433582\\n            )\\n            // qEcc\\n            mstore(\\n                mload(add(vk, 0x260)),\\n                11861036760044642147557768929016751187676005432645929589927048931795306751324\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x260)), 0x20),\\n                7411647397974044716846852003118581558974144934962247144410611563600239777076\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x043eee59b78e1669a99ee0764083e9b1ddd725e8398a16e2fff1d5075f70e82f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Transfer2In2Out24DepthVk.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\n// NOTE: DO NOT MODIFY! GENERATED BY SCRIPT VIA `cargo run --bin gen-vk-libraries --release`.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport \\\"./BN254.sol\\\";\\n\\nlibrary Transfer2In2Out24DepthVk {\\n    function getVk() internal pure returns (IPlonkVerifier.VerifyingKey memory vk) {\\n        assembly {\\n            // domain size\\n            mstore(vk, 32768)\\n            // num of public inputs\\n            mstore(add(vk, 0x20), 27)\\n\\n            // sigma0\\n            mstore(\\n                mload(add(vk, 0x40)),\\n                7628022919529421911135408904372797627127922903613932517951676759551756614275\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x40)), 0x20),\\n                1331524275175103536317606472081114729669777307477986149584111942393705962450\\n            )\\n            // sigma1\\n            mstore(\\n                mload(add(vk, 0x60)),\\n                11385474208217093339197684484172860602491108849062309339809203517524255705814\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x60)), 0x20),\\n                14742740373953540087108822854363852587371950907295700017218827187367528919422\\n            )\\n            // sigma2\\n            mstore(\\n                mload(add(vk, 0x80)),\\n                16656283720893277505520180576834218330228640426319787818259624147689712896181\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x80)), 0x20),\\n                13325231528863913137181084237184355058186595356556894827411039178877487474770\\n            )\\n            // sigma3\\n            mstore(\\n                mload(add(vk, 0xa0)),\\n                9189791310770551336126945048086887553526802063485610994702148384774531567947\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xa0)), 0x20),\\n                14841018178006034931401800499802155298679474918739530511330632965796343701845\\n            )\\n            // sigma4\\n            mstore(\\n                mload(add(vk, 0xc0)),\\n                2291377454368026633206063421914664920045658737580871725587615825936361194543\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xc0)), 0x20),\\n                1302015066005114004951991020555380375564758415605740891074815812171114380677\\n            )\\n\\n            // q1\\n            mstore(\\n                mload(add(vk, 0xe0)),\\n                20820380636256451755441529461019761091650992355545157191471886785846828368458\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xe0)), 0x20),\\n                21593297517126223340469128837410501412961385490498992377256325174187721359792\\n            )\\n            // q2\\n            mstore(\\n                mload(add(vk, 0x100)),\\n                18739722115441254876917366518913137925104098218293815822076739449944538511463\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x100)), 0x20),\\n                21704728059513369811801942736237462547455258303739352819235283602004201892046\\n            )\\n            // q3\\n            mstore(\\n                mload(add(vk, 0x120)),\\n                14641591741781012837232454331455337179912058515648809221995273046957404689696\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x120)), 0x20),\\n                7809440494808817863276605374028021971161141718007334574770841741782286482045\\n            )\\n            // q4\\n            mstore(\\n                mload(add(vk, 0x140)),\\n                12825820090241151628814776520261182308841765265286885643232345964438926321859\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x140)), 0x20),\\n                953744090209979424715539850359172951613856725623925496688974323728989047678\\n            )\\n\\n            // qM12\\n            mstore(\\n                mload(add(vk, 0x160)),\\n                12851524982620297419850126451077057609693331882274130781000694680394484937072\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x160)), 0x20),\\n                275368615438300238729991830030823846019265755187066004752089508827060302546\\n            )\\n            // qM34\\n            mstore(\\n                mload(add(vk, 0x180)),\\n                5220853497691242543339709197361896971155747151782855394304800304146652028430\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x180)), 0x20),\\n                9450857245879300465114294127329293155426034414913673478235624018652474647192\\n            )\\n\\n            // qO\\n            mstore(\\n                mload(add(vk, 0x1a0)),\\n                1021365006885138582377179911145719040433890015638098596677854082251708776428\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1a0)), 0x20),\\n                11359935238758701707761945142588661021143398751723216197162452144578378060887\\n            )\\n            // qC\\n            mstore(\\n                mload(add(vk, 0x1c0)),\\n                13464643739714429050907960983453767858349630205445421978818631227665532763905\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1c0)), 0x20),\\n                10339488547668992208892459748774743478364544079101005770106713704130208623574\\n            )\\n            // qH1\\n            mstore(\\n                mload(add(vk, 0x1e0)),\\n                9601738305327057050177966434793538325547418147491497810469219037972470343030\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1e0)), 0x20),\\n                19301188629352152421673613863134089760610229764460440766611052882385794236638\\n            )\\n            // qH2\\n            mstore(\\n                mload(add(vk, 0x200)),\\n                21079123752659904011291969128982548366933951092885387880640877829556396468124\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x200)), 0x20),\\n                8511476146119618724794262516873338224284052557219121087531014728412456998247\\n            )\\n            // qH3\\n            mstore(\\n                mload(add(vk, 0x220)),\\n                15303909812921746731917671857484723288453878023898728858584106908662401059224\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x220)), 0x20),\\n                18170356242761746817628282114440738046388581044315241707586116980550978579010\\n            )\\n            // qH4\\n            mstore(\\n                mload(add(vk, 0x240)),\\n                4268233897088460316569641617170115742335233153775249443326146549729427293896\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x240)), 0x20),\\n                18974976451146753275247755359852354432882026367027102555776389253422694257840\\n            )\\n            // qEcc\\n            mstore(\\n                mload(add(vk, 0x260)),\\n                14659915475225256091079096704713344128669967309925492152251233149380462089822\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x260)), 0x20),\\n                2059804379395436696412483294937073085747522899756612651966178273428617505712\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x47ca40af3c5833f30b0b86365cad3bcc3682b12c3743aa43f3290ef549f194c5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Transfer2In3Out24DepthVk.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\n// NOTE: DO NOT MODIFY! GENERATED BY SCRIPT VIA `cargo run --bin gen-vk-libraries --release`.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport \\\"./BN254.sol\\\";\\n\\nlibrary Transfer2In3Out24DepthVk {\\n    function getVk() internal pure returns (IPlonkVerifier.VerifyingKey memory vk) {\\n        assembly {\\n            // domain size\\n            mstore(vk, 32768)\\n            // num of public inputs\\n            mstore(add(vk, 0x20), 32)\\n\\n            // sigma0\\n            mstore(\\n                mload(add(vk, 0x40)),\\n                6443282669730485407595271828674707172530216643022146287503622911791463804043\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x40)), 0x20),\\n                15696097649475290076149769009458172575519992828166990254810336060070104703870\\n            )\\n            // sigma1\\n            mstore(\\n                mload(add(vk, 0x60)),\\n                11681656213736165656499497372446107771337122700468758173231970786274856928411\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x60)), 0x20),\\n                10450606707405144471114037991073355878505225379403084661718401703948084026025\\n            )\\n            // sigma2\\n            mstore(\\n                mload(add(vk, 0x80)),\\n                14949874541546323431113184056978425503852064124202616618464991230985415809296\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x80)), 0x20),\\n                2755002423044532136780993773451846084085886241086886025824873450959670484164\\n            )\\n            // sigma3\\n            mstore(\\n                mload(add(vk, 0xa0)),\\n                21207788223959789592306767368195516108258319638600005910214663887334522784476\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xa0)), 0x20),\\n                20339433485992657720503614053002752589189874711150471281419370881536035034628\\n            )\\n            // sigma4\\n            mstore(\\n                mload(add(vk, 0xc0)),\\n                18631493768208670705485520853887976536695065332427205279642440535222886092292\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xc0)), 0x20),\\n                6840987554837946884416088276166870742357021362040861629505787964758864275100\\n            )\\n\\n            // q1\\n            mstore(\\n                mload(add(vk, 0xe0)),\\n                16178651459227636862542353073855555416097463500529848793096041715723051182880\\n            )\\n            mstore(\\n                add(mload(add(vk, 0xe0)), 0x20),\\n                5970323786617048090410648683745859437837321145537762222392610864665454314628\\n            )\\n            // q2\\n            mstore(\\n                mload(add(vk, 0x100)),\\n                21487420887626536768737123653635887952476328827973824853831940683917744860629\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x100)), 0x20),\\n                14035356773640867098841015480173597833708530762839998143633620124000312604569\\n            )\\n            // q3\\n            mstore(\\n                mload(add(vk, 0x120)),\\n                9545837141279670455258503437926586302673276681048196091959382223343565663038\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x120)), 0x20),\\n                15947614763344839229459794400790751428004401834477218923635864884401496441892\\n            )\\n            // q4\\n            mstore(\\n                mload(add(vk, 0x140)),\\n                12080091524919005971356953696076991358627192379181758361749359305653171768953\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x140)), 0x20),\\n                17439684987066542572766750059569630478427935655895555459166833681417844092930\\n            )\\n\\n            // qM12\\n            mstore(\\n                mload(add(vk, 0x160)),\\n                5701950446803590644135190089832346121657991411362732243298925416080446841465\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x160)), 0x20),\\n                8332659994290731968190641056516336791258763359210625476231835314984112766413\\n            )\\n            // qM34\\n            mstore(\\n                mload(add(vk, 0x180)),\\n                13253969218388213652706314130513753359438541493687814506877280541684975690258\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x180)), 0x20),\\n                16009690647717929647856071917243036723170363003070166259833423021444206394391\\n            )\\n\\n            // qO\\n            mstore(\\n                mload(add(vk, 0x1a0)),\\n                5576536153829630973927473424831889868656235111882426196623002728030063738858\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1a0)), 0x20),\\n                11726598312732354680625205255493076317120545671716157650418651212412840704738\\n            )\\n            // qC\\n            mstore(\\n                mload(add(vk, 0x1c0)),\\n                5405551642410088215503372225048806703517930422578070794318382858583234132381\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1c0)), 0x20),\\n                494379166121476157530708105968326435548569494079142065684457716255857242276\\n            )\\n            // qH1\\n            mstore(\\n                mload(add(vk, 0x1e0)),\\n                20704187523716756528180282857397988056049614305908938091015985169373590947598\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x1e0)), 0x20),\\n                1711039150215717904294641678907719765410368126472104372784057294224997327419\\n            )\\n            // qH2\\n            mstore(\\n                mload(add(vk, 0x200)),\\n                18822945583248183258553997348222993649454022267053574236466619892496459777859\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x200)), 0x20),\\n                14151738140577784330561552892602560699610764417317335382613984109360136167394\\n            )\\n            // qH3\\n            mstore(\\n                mload(add(vk, 0x220)),\\n                2387304647210058180508070573733250363855112630235812789983280252196793324601\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x220)), 0x20),\\n                7685115375159715883862846923594198876658684538946803569647901707992033051886\\n            )\\n            // qH4\\n            mstore(\\n                mload(add(vk, 0x240)),\\n                16435018905297869097928961780716739903270571476633582949015154935556284135350\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x240)), 0x20),\\n                2036767712865186869762381470608151410855938900352103040184478909748435318476\\n            )\\n            // qEcc\\n            mstore(\\n                mload(add(vk, 0x260)),\\n                6779994430033977349039006350128159237422794493764381621361585638109046042910\\n            )\\n            mstore(\\n                add(mload(add(vk, 0x260)), 0x20),\\n                13084743573268695049814429704952197464938266719700894058263626618858073954657\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x110524ebc150b6b7273c3804009ce37d7261a00f3a484172b562f2c096fa94f1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Utils {\\n    function reverseEndianness(uint256 input) internal pure returns (uint256 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v =\\n            ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v =\\n            ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v =\\n            ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v =\\n            ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n}\\n\",\"keccak256\":\"0x5147ed6d551626c1c17afc4cf65a8770bd55e47821572264b93b29f165bc0869\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/VerifyingKeys.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IPlonkVerifier.sol\\\";\\nimport \\\"./Transfer1In2Out24DepthVk.sol\\\";\\nimport \\\"./Transfer2In2Out24DepthVk.sol\\\";\\nimport \\\"./Transfer2In3Out24DepthVk.sol\\\";\\nimport \\\"./Mint1In2Out24DepthVk.sol\\\";\\nimport \\\"./Freeze2In2Out24DepthVk.sol\\\";\\nimport \\\"./Freeze3In3Out24DepthVk.sol\\\";\\n\\nlibrary VerifyingKeys {\\n    function getVkById(uint256 encodedId)\\n        external\\n        pure\\n        returns (IPlonkVerifier.VerifyingKey memory)\\n    {\\n        if (encodedId == getEncodedId(0, 1, 2, 24)) {\\n            // transfer/burn-1-input-2-output-24-depth\\n            return Transfer1In2Out24DepthVk.getVk();\\n        } else if (encodedId == getEncodedId(0, 2, 2, 24)) {\\n            // transfer/burn-2-input-2-output-24-depth\\n            return Transfer2In2Out24DepthVk.getVk();\\n        } else if (encodedId == getEncodedId(0, 2, 3, 24)) {\\n            // transfer/burn-2-input-3-output-24-depth\\n            return Transfer2In3Out24DepthVk.getVk();\\n        } else if (encodedId == getEncodedId(1, 1, 2, 24)) {\\n            // mint-1-input-2-output-24-depth\\n            return Mint1In2Out24DepthVk.getVk();\\n        } else if (encodedId == getEncodedId(2, 2, 2, 24)) {\\n            // freeze-2-input-2-output-24-depth\\n            return Freeze2In2Out24DepthVk.getVk();\\n        } else if (encodedId == getEncodedId(2, 3, 3, 24)) {\\n            // freeze-3-input-3-output-24-depth\\n            return Freeze3In3Out24DepthVk.getVk();\\n        } else {\\n            revert(\\\"Unknown vk ID\\\");\\n        }\\n    }\\n\\n    // returns (noteType, numInput, numOutput, treeDepth) as a 4*8 = 32 byte = uint256\\n    // as the encoded ID.\\n    function getEncodedId(\\n        uint8 noteType,\\n        uint8 numInput,\\n        uint8 numOutput,\\n        uint8 treeDepth\\n    ) public pure returns (uint256 encodedId) {\\n        assembly {\\n            encodedId := add(\\n                shl(24, noteType),\\n                add(shl(16, numInput), add(shl(8, numOutput), treeDepth))\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2fb74b50d356a6c56f210dcd30cf125d2864f3ff4117915bcfc78aa2b66abe8a\",\"license\":\"GPL-3.0-or-later\"},\"contracts/mocks/TestCAPE.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../CAPE.sol\\\";\\n\\ncontract TestCAPE is CAPE {\\n    constructor(\\n        uint8 merkleTreeHeight,\\n        uint64 nRoots,\\n        address verifierAddr\\n    ) CAPE(merkleTreeHeight, nRoots, verifierAddr) {}\\n\\n    function getNumLeaves() public view returns (uint256) {\\n        return _numLeaves;\\n    }\\n\\n    function setInitialRecordCommitments(uint256[] memory elements) public {\\n        require(_rootValue == 0, \\\"Merkle tree is nonempty\\\");\\n        _updateRecordsMerkleTree(elements);\\n        addRoot(_rootValue);\\n    }\\n\\n    function publish(uint256 nullifier) public {\\n        return _publish(nullifier);\\n    }\\n\\n    function checkTransfer(TransferNote memory note) public pure {\\n        return _checkTransfer(note);\\n    }\\n\\n    function checkBurn(BurnNote memory note) public view {\\n        return _checkBurn(note);\\n    }\\n\\n    function containsRoot(uint256 root) public view returns (bool) {\\n        return _containsRoot(root);\\n    }\\n\\n    function containsBurnPrefix(bytes memory extraProofBoundData) public pure returns (bool) {\\n        return _containsBurnPrefix(extraProofBoundData);\\n    }\\n\\n    function containsBurnRecord(BurnNote memory note) public view returns (bool) {\\n        return _containsBurnRecord(note);\\n    }\\n\\n    function deriveRecordCommitment(RecordOpening memory ro) public view returns (uint256) {\\n        return _deriveRecordCommitment(ro);\\n    }\\n\\n    function addRoot(uint256 root) public {\\n        return _addRoot(root);\\n    }\\n\\n    function setHeight(uint64 newHeight) public {\\n        blockHeight = newHeight;\\n    }\\n\\n    function computeNumCommitments(CapeBlock memory newBlock) public pure returns (uint256) {\\n        return _computeNumCommitments(newBlock);\\n    }\\n\\n    function checkForeignAssetCode(\\n        uint256 assetDefinitionCode,\\n        address erc20Address,\\n        address sponsor\\n    ) public pure {\\n        _checkForeignAssetCode(assetDefinitionCode, erc20Address, sponsor);\\n    }\\n\\n    function checkDomesticAssetCode(uint256 assetDefinitionCode, uint256 internalAssetCode)\\n        public\\n        pure\\n    {\\n        _checkDomesticAssetCode(assetDefinitionCode, internalAssetCode);\\n    }\\n\\n    function computeAssetDescription(address erc20Address, address sponsor)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return _computeAssetDescription(erc20Address, sponsor);\\n    }\\n\\n    function pendingDepositsLength() public view returns (uint256) {\\n        return pendingDeposits.length;\\n    }\\n\\n    function fillUpPendingDepositsQueue() public {\\n        for (uint256 i = pendingDeposits.length; i < MAX_NUM_PENDING_DEPOSIT; i++) {\\n            pendingDeposits.push(100 + i);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc8defacdeffd1b017948d4f4a2da9d0581b38dc73631a16f358847718e2182fe\",\"license\":\"GPL-3.0-or-later\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506040518060400160405280600f81526020016e26b0b634b1b4b7bab9902a37b5b2b760891b8152506040518060400160405280600381526020016213505560ea1b81525081600390805190602001906200006e9291906200009b565b508051620000849060049060208401906200009b565b50506005805461ffff60a01b19169055506200017e565b828054620000a99062000141565b90600052602060002090601f016020900481019282620000cd576000855562000118565b82601f10620000e857805160ff191683800117855562000118565b8280016001018555821562000118579182015b8281111562000118578251825591602001919060010190620000fb565b50620001269291506200012a565b5090565b5b808211156200012657600081556001016200012b565b600181811c908216806200015657607f821691505b602082108114156200017857634e487b7160e01b600052602260045260246000fd5b50919050565b61119f806200018e6000396000f3fe608060405234801561001057600080fd5b50600436106100ba5760003560e01c806306fdde03146100bf578063095ea7b3146100dd57806318160ddd1461010057806323b872dd14610112578063313ce5671461012557806339509351146101345780634fd153861461014757806370a082311461017957806395d89b41146101a25780639a94498d146101aa578063a457c2d7146101c3578063a9059cbb146101d6578063dd62ed3e146101e9578063e19a714a14610222575b600080fd5b6100c761023b565b6040516100d49190610932565b60405180910390f35b6100f06100eb366004610968565b6102cd565b60405190151581526020016100d4565b6002545b6040519081526020016100d4565b6100f0610120366004610992565b6102e3565b604051601281526020016100d4565b6100f0610142366004610968565b6103f6565b6101776101553660046109ce565b600580546001600160a01b0319166001600160a01b0392909216919091179055565b005b6101046101873660046109ce565b6001600160a01b031660009081526020819052604090205490565b6100c7610432565b6101776005805461ffff60a01b1916600160a81b179055565b6100f06101d1366004610968565b610441565b6100f06101e4366004610968565b6104df565b6101046101f73660046109e9565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b6101776005805461ffff60a01b1916600160a01b179055565b60606003805461024a90610a1c565b80601f016020809104026020016040519081016040528092919081815260200182805461027690610a1c565b80156102c35780601f10610298576101008083540402835291602001916102c3565b820191906000526020600020905b8154815290600101906020018083116102a657829003601f168201915b5050505050905090565b60006102da3384846104ec565b50600192915050565b6005546000906001600160a01b03811690600160a01b900460ff16156103715761030b6107e4565b604051637c307c8360e01b81526000906001600160a01b03841690637c307c839061033c9085908590600401610b1f565b600060405180830381600087803b15801561035657600080fd5b505af115801561036a573d6000803e3d6000fd5b5050505050505b600554600160a81b900460ff16156103eb5761038b61082f565b604051633a79729360e21b81526001600160a01b0383169063e9e5ca4c906103b7908490600401611051565b600060405180830381600087803b1580156103d157600080fd5b505af11580156103e5573d6000803e3d6000fd5b50505050505b506001949350505050565b3360008181526001602090815260408083206001600160a01b038716845290915281205490916102da91859061042d908690611143565b6104ec565b60606004805461024a90610a1c565b3360009081526001602090815260408083206001600160a01b0386168452909152812054828110156104c85760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77604482015264207a65726f60d81b60648201526084015b60405180910390fd5b6104d533858584036104ec565b5060019392505050565b60006102da338484610610565b6001600160a01b03831661054e5760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b60648201526084016104bf565b6001600160a01b0382166105af5760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b60648201526084016104bf565b6001600160a01b0383811660008181526001602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b6001600160a01b0383166106745760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f206164604482015264647265737360d81b60648201526084016104bf565b6001600160a01b0382166106d65760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b60648201526084016104bf565b6001600160a01b0383166000908152602081905260409020548181101561074e5760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e7420657863656564732062604482015265616c616e636560d01b60648201526084016104bf565b6001600160a01b03808516600090815260208190526040808220858503905591851681529081208054849290610785908490611143565b92505081905550826001600160a01b0316846001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516107d191815260200190565b60405180910390a350505050565b505050565b6040518060c0016040528060006001600160401b0316815260200161080761086b565b815260200161081461088a565b81526000602082018190526040820181905260609091015290565b6040518060c0016040528061084261088a565b815260200160608152602001606081526020016060815260200160608152602001606081525090565b6040518060400160405280600081526020016108856108a4565b905290565b604051806040016040528060008152602001600081525090565b6040518060a001604052806108b761088a565b81526020016108c461088a565b81526020016108d161088a565b815260006020820181905260409091015290565b6000815180845260005b8181101561090b576020818501810151868301820152016108ef565b8181111561091d576000602083870101525b50601f01601f19169290920160200192915050565b60208152600061094560208301846108e5565b9392505050565b80356001600160a01b038116811461096357600080fd5b919050565b6000806040838503121561097b57600080fd5b6109848361094c565b946020939093013593505050565b6000806000606084860312156109a757600080fd5b6109b08461094c565b92506109be6020850161094c565b9150604084013590509250925092565b6000602082840312156109e057600080fd5b6109458261094c565b600080604083850312156109fc57600080fd5b610a058361094c565b9150610a136020840161094c565b90509250929050565b600181811c90821680610a3057607f821691505b60208210811415610a5157634e487b7160e01b600052602260045260246000fd5b50919050565b80518252602090810151910152565b805182526020810151610a7d602084018251610a57565b6020810151610a8f6060850182610a57565b506040810151610aa260a0850182610a57565b50606081015160e08401526001600160401b03608082015116610100840152505050565b6001600160401b0381511682526020810151610ae56020840182610a66565b506040810151610af9610140840182610a57565b506060810151610180830152608081015115156101a083015260a001516101c090910152565b6102008101610b2e8285610ac6565b6001600160a01b03929092166101e09190910152919050565b600081518084526020808501945080840160005b83811015610b7757815187529582019590820190600101610b5b565b509495945050505050565b610b8d828251610a57565b6020810151610b9f6040840182610a57565b506040810151610bb26080840182610a57565b506060810151610bc560c0840182610a57565b506080810151610100610bda81850183610a57565b60a08301519150610140610bf081860184610a57565b60c08401519250610180610c0681870185610a57565b60e085015193506101c0610c1c81880186610a57565b92850151935061020092610c3287850186610a57565b6101208601519450610240610c4981890187610a57565b92860151945061028092610c5f88850187610a57565b61016087015195506102c0610c76818a0188610a57565b838801519650610c8a6103008a0188610a57565b6101a08801516103408a0152918701516103608901526101e0870151610380890152938601516103a08801526102208601516103c0880152928501516103e0870152506102608401516104008601528301516104208501526102a0830151610440850152909101516104609092019190915250565b610d0a828251610a57565b6000602082015160606040850152610d256060850182610b47565b949350505050565b60006105008251818552610d4382860182610b47565b91505060208301518482036020860152610d5d8282610b47565b9150506040830151610d726040860182610b82565b5060608301518482036104c0860152610d8b8282610cff565b91505060808301518482036104e08601528051825260208101516001600160401b03808216602085015280604084015116604085015250506060810151610dd56060840182610a57565b506080015160c060a08301819052610def908301826108e5565b95945050505050565b600081518084526020808501808196508360051b8101915082860160005b85811015610e40578284038952610e2e848351610d2d565b98850198935090840190600101610e16565b5091979650505050505050565b805182526001600160401b03602082015116602083015260408101516107df6040840182610a57565b600081518084526020808501808196508360051b8101915082860160005b85811015610e4057828403895281516106e08151865286820151878701526040808301518188015250606080830151610ed7828901826001600160401b03169052565b5050608080830151610eeb82890182610a66565b505060a08201516101a087015260c0820151610f0b6101c0880182610b82565b5060e082015181610640880152610f2482880182610cff565b9150506101008201519150610f3d610660870183610e4d565b9986019994505090840190600101610e94565b600081518084526020808501808196508360051b8101915082860160005b85811015610e4057828403895281516105408151818752610f9182880182610b47565b9150508682015186820388880152610fa98282610b47565b915050604080830151610fbe82890182610b82565b505060608201519150610fd56104c0870183610e4d565b9986019994505090840190600101610f6e565b600081518084526020808501808196508360051b8101915082860160005b85811015610e405782840389528151610200815181875261102982880182610d2d565b91505086820151915061103e87870183610ac6565b9986019994505090840190600101611006565b60006020808352610100830161106a8285018651610a57565b8482015160e06060860152805191829052820190600090610120860190825b818110156110c257845160048082106110af57634e487b7160e01b865260218152602486fd5b5083529385019391850191600101611089565b505060408701519350601f199250828682030160808701526110e48185610df8565b935050506060850151818584030160a08601526111018382610e76565b9250506080850151818584030160c086015261111d8382610f50565b92505060a0850151818584030160e08601526111398382610fe8565b9695505050505050565b6000821982111561116457634e487b7160e01b600052601160045260246000fd5b50019056fea264697066735822122048f95dda6f9b93ca4575a207ee306c8b60b0cfefeb915ff4006aa4a102ccf3c564736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100ba5760003560e01c806306fdde03146100bf578063095ea7b3146100dd57806318160ddd1461010057806323b872dd14610112578063313ce5671461012557806339509351146101345780634fd153861461014757806370a082311461017957806395d89b41146101a25780639a94498d146101aa578063a457c2d7146101c3578063a9059cbb146101d6578063dd62ed3e146101e9578063e19a714a14610222575b600080fd5b6100c761023b565b6040516100d49190610932565b60405180910390f35b6100f06100eb366004610968565b6102cd565b60405190151581526020016100d4565b6002545b6040519081526020016100d4565b6100f0610120366004610992565b6102e3565b604051601281526020016100d4565b6100f0610142366004610968565b6103f6565b6101776101553660046109ce565b600580546001600160a01b0319166001600160a01b0392909216919091179055565b005b6101046101873660046109ce565b6001600160a01b031660009081526020819052604090205490565b6100c7610432565b6101776005805461ffff60a01b1916600160a81b179055565b6100f06101d1366004610968565b610441565b6100f06101e4366004610968565b6104df565b6101046101f73660046109e9565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b6101776005805461ffff60a01b1916600160a01b179055565b60606003805461024a90610a1c565b80601f016020809104026020016040519081016040528092919081815260200182805461027690610a1c565b80156102c35780601f10610298576101008083540402835291602001916102c3565b820191906000526020600020905b8154815290600101906020018083116102a657829003601f168201915b5050505050905090565b60006102da3384846104ec565b50600192915050565b6005546000906001600160a01b03811690600160a01b900460ff16156103715761030b6107e4565b604051637c307c8360e01b81526000906001600160a01b03841690637c307c839061033c9085908590600401610b1f565b600060405180830381600087803b15801561035657600080fd5b505af115801561036a573d6000803e3d6000fd5b5050505050505b600554600160a81b900460ff16156103eb5761038b61082f565b604051633a79729360e21b81526001600160a01b0383169063e9e5ca4c906103b7908490600401611051565b600060405180830381600087803b1580156103d157600080fd5b505af11580156103e5573d6000803e3d6000fd5b50505050505b506001949350505050565b3360008181526001602090815260408083206001600160a01b038716845290915281205490916102da91859061042d908690611143565b6104ec565b60606004805461024a90610a1c565b3360009081526001602090815260408083206001600160a01b0386168452909152812054828110156104c85760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77604482015264207a65726f60d81b60648201526084015b60405180910390fd5b6104d533858584036104ec565b5060019392505050565b60006102da338484610610565b6001600160a01b03831661054e5760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b60648201526084016104bf565b6001600160a01b0382166105af5760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b60648201526084016104bf565b6001600160a01b0383811660008181526001602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b6001600160a01b0383166106745760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f206164604482015264647265737360d81b60648201526084016104bf565b6001600160a01b0382166106d65760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b60648201526084016104bf565b6001600160a01b0383166000908152602081905260409020548181101561074e5760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e7420657863656564732062604482015265616c616e636560d01b60648201526084016104bf565b6001600160a01b03808516600090815260208190526040808220858503905591851681529081208054849290610785908490611143565b92505081905550826001600160a01b0316846001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516107d191815260200190565b60405180910390a350505050565b505050565b6040518060c0016040528060006001600160401b0316815260200161080761086b565b815260200161081461088a565b81526000602082018190526040820181905260609091015290565b6040518060c0016040528061084261088a565b815260200160608152602001606081526020016060815260200160608152602001606081525090565b6040518060400160405280600081526020016108856108a4565b905290565b604051806040016040528060008152602001600081525090565b6040518060a001604052806108b761088a565b81526020016108c461088a565b81526020016108d161088a565b815260006020820181905260409091015290565b6000815180845260005b8181101561090b576020818501810151868301820152016108ef565b8181111561091d576000602083870101525b50601f01601f19169290920160200192915050565b60208152600061094560208301846108e5565b9392505050565b80356001600160a01b038116811461096357600080fd5b919050565b6000806040838503121561097b57600080fd5b6109848361094c565b946020939093013593505050565b6000806000606084860312156109a757600080fd5b6109b08461094c565b92506109be6020850161094c565b9150604084013590509250925092565b6000602082840312156109e057600080fd5b6109458261094c565b600080604083850312156109fc57600080fd5b610a058361094c565b9150610a136020840161094c565b90509250929050565b600181811c90821680610a3057607f821691505b60208210811415610a5157634e487b7160e01b600052602260045260246000fd5b50919050565b80518252602090810151910152565b805182526020810151610a7d602084018251610a57565b6020810151610a8f6060850182610a57565b506040810151610aa260a0850182610a57565b50606081015160e08401526001600160401b03608082015116610100840152505050565b6001600160401b0381511682526020810151610ae56020840182610a66565b506040810151610af9610140840182610a57565b506060810151610180830152608081015115156101a083015260a001516101c090910152565b6102008101610b2e8285610ac6565b6001600160a01b03929092166101e09190910152919050565b600081518084526020808501945080840160005b83811015610b7757815187529582019590820190600101610b5b565b509495945050505050565b610b8d828251610a57565b6020810151610b9f6040840182610a57565b506040810151610bb26080840182610a57565b506060810151610bc560c0840182610a57565b506080810151610100610bda81850183610a57565b60a08301519150610140610bf081860184610a57565b60c08401519250610180610c0681870185610a57565b60e085015193506101c0610c1c81880186610a57565b92850151935061020092610c3287850186610a57565b6101208601519450610240610c4981890187610a57565b92860151945061028092610c5f88850187610a57565b61016087015195506102c0610c76818a0188610a57565b838801519650610c8a6103008a0188610a57565b6101a08801516103408a0152918701516103608901526101e0870151610380890152938601516103a08801526102208601516103c0880152928501516103e0870152506102608401516104008601528301516104208501526102a0830151610440850152909101516104609092019190915250565b610d0a828251610a57565b6000602082015160606040850152610d256060850182610b47565b949350505050565b60006105008251818552610d4382860182610b47565b91505060208301518482036020860152610d5d8282610b47565b9150506040830151610d726040860182610b82565b5060608301518482036104c0860152610d8b8282610cff565b91505060808301518482036104e08601528051825260208101516001600160401b03808216602085015280604084015116604085015250506060810151610dd56060840182610a57565b506080015160c060a08301819052610def908301826108e5565b95945050505050565b600081518084526020808501808196508360051b8101915082860160005b85811015610e40578284038952610e2e848351610d2d565b98850198935090840190600101610e16565b5091979650505050505050565b805182526001600160401b03602082015116602083015260408101516107df6040840182610a57565b600081518084526020808501808196508360051b8101915082860160005b85811015610e4057828403895281516106e08151865286820151878701526040808301518188015250606080830151610ed7828901826001600160401b03169052565b5050608080830151610eeb82890182610a66565b505060a08201516101a087015260c0820151610f0b6101c0880182610b82565b5060e082015181610640880152610f2482880182610cff565b9150506101008201519150610f3d610660870183610e4d565b9986019994505090840190600101610e94565b600081518084526020808501808196508360051b8101915082860160005b85811015610e4057828403895281516105408151818752610f9182880182610b47565b9150508682015186820388880152610fa98282610b47565b915050604080830151610fbe82890182610b82565b505060608201519150610fd56104c0870183610e4d565b9986019994505090840190600101610f6e565b600081518084526020808501808196508360051b8101915082860160005b85811015610e405782840389528151610200815181875261102982880182610d2d565b91505086820151915061103e87870183610ac6565b9986019994505090840190600101611006565b60006020808352610100830161106a8285018651610a57565b8482015160e06060860152805191829052820190600090610120860190825b818110156110c257845160048082106110af57634e487b7160e01b865260218152602486fd5b5083529385019391850191600101611089565b505060408701519350601f199250828682030160808701526110e48185610df8565b935050506060850151818584030160a08601526111018382610e76565b9250506080850151818584030160c086015261111d8382610f50565b92505060a0850151818584030160e08601526111398382610fe8565b9695505050505050565b6000821982111561116457634e487b7160e01b600052601160045260246000fd5b50019056fea264697066735822122048f95dda6f9b93ca4575a207ee306c8b60b0cfefeb915ff4006aa4a102ccf3c564736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "allowance(address,address)": {
        "details": "See {IERC20-allowance}."
      },
      "approve(address,uint256)": {
        "details": "See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."
      },
      "balanceOf(address)": {
        "details": "See {IERC20-balanceOf}."
      },
      "decimals()": {
        "details": "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."
      },
      "decreaseAllowance(address,uint256)": {
        "details": "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."
      },
      "increaseAllowance(address,uint256)": {
        "details": "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."
      },
      "name()": {
        "details": "Returns the name of the token."
      },
      "selectDepositAttack()": {
        "details": "pick the depositErc20 function when calling back the CAPE contract"
      },
      "selectSubmitBlockAttack()": {
        "details": "pick the submitBlock function when calling back the CAPE contract"
      },
      "setTargetContractAddress(address)": {
        "details": "Sets the address for performing the reentrancy attack."
      },
      "symbol()": {
        "details": "Returns the symbol of the token, usually a shorter version of the name."
      },
      "totalSupply()": {
        "details": "See {IERC20-totalSupply}."
      },
      "transfer(address,uint256)": {
        "details": "See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "MaliciousToken contract constructor."
      },
      "transferFrom(address,address,uint256)": {
        "notice": "Malicious implementation of transferFrom"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 55,
        "contract": "contracts/MaliciousToken.sol:MaliciousToken",
        "label": "_balances",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 61,
        "contract": "contracts/MaliciousToken.sol:MaliciousToken",
        "label": "_allowances",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 63,
        "contract": "contracts/MaliciousToken.sol:MaliciousToken",
        "label": "_totalSupply",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 65,
        "contract": "contracts/MaliciousToken.sol:MaliciousToken",
        "label": "_name",
        "offset": 0,
        "slot": "3",
        "type": "t_string_storage"
      },
      {
        "astId": 67,
        "contract": "contracts/MaliciousToken.sol:MaliciousToken",
        "label": "_symbol",
        "offset": 0,
        "slot": "4",
        "type": "t_string_storage"
      },
      {
        "astId": 3501,
        "contract": "contracts/MaliciousToken.sol:MaliciousToken",
        "label": "_targetContractAddress",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 3503,
        "contract": "contracts/MaliciousToken.sol:MaliciousToken",
        "label": "_runDeposit",
        "offset": 20,
        "slot": "5",
        "type": "t_bool"
      },
      {
        "astId": 3505,
        "contract": "contracts/MaliciousToken.sol:MaliciousToken",
        "label": "_runSubmitBlock",
        "offset": 21,
        "slot": "5",
        "type": "t_bool"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}