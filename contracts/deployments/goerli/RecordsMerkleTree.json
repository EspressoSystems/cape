{
  "address": "0x1D2ff68996F22Ed63406E6d954a635757abd3a75",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "merkleTreeHeight",
          "type": "uint8"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "getHeight",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getNumLeaves",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getRootValue",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "elements",
          "type": "uint256[]"
        }
      ],
      "name": "updateRecordsMerkleTree",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x119a53243d581d278f5aefb564313c205296dad9d808255acd893a0618320c2e",
  "receipt": {
    "to": null,
    "from": "0xb19A0B7Cf8BC81492841537b43d49dEdA35DcE4F",
    "contractAddress": "0x1D2ff68996F22Ed63406E6d954a635757abd3a75",
    "transactionIndex": 43,
    "gasUsed": "1444327",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000002000000000000000000000000000000000000000004000000000000000000000000000000000000000000001000000000000000000004000000000000000020000000000000020000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000004000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbdec3363897525d4974afd281ab5385f26695b80910d91ba95ba2ff2d5438026",
    "transactionHash": "0x119a53243d581d278f5aefb564313c205296dad9d808255acd893a0618320c2e",
    "logs": [
      {
        "transactionIndex": 43,
        "blockNumber": 7033387,
        "transactionHash": "0x119a53243d581d278f5aefb564313c205296dad9d808255acd893a0618320c2e",
        "address": "0x1D2ff68996F22Ed63406E6d954a635757abd3a75",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000b19a0b7cf8bc81492841537b43d49deda35dce4f"
        ],
        "data": "0x",
        "logIndex": 29,
        "blockHash": "0xbdec3363897525d4974afd281ab5385f26695b80910d91ba95ba2ff2d5438026"
      }
    ],
    "blockNumber": 7033387,
    "cumulativeGasUsed": "3149406",
    "status": 1,
    "byzantium": true
  },
  "args": [
    24
  ],
  "solcInputHash": "a2a06204e48e5b061a7d8a091eecad05",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"merkleTreeHeight\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getHeight\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumLeaves\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRootValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"elements\",\"type\":\"uint256[]\"}],\"name\":\"updateRecordsMerkleTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Create a records Merkle tree of the given height.\",\"params\":{\"merkleTreeHeight\":\"The height\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateRecordsMerkleTree(uint256[])\":{\"details\":\"Update the state of the record merkle tree by inserting new elements.\",\"params\":{\"elements\":\"The list of elements to be appended to the current merkle tree described by the frontier.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getHeight()\":{\"notice\":\"Returns the height of the Merkle tree.\"},\"getNumLeaves()\":{\"notice\":\"Returns the number of leaves of the Merkle tree.\"},\"getRootValue()\":{\"notice\":\"Returns the root value of the Merkle tree.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RecordsMerkleTree.sol\":\"RecordsMerkleTree\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"contracts/RecordsMerkleTree.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n//\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n//\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/RescueLib.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract RecordsMerkleTree is Ownable {\\n    enum Position {\\n        LEFT,\\n        MIDDLE,\\n        RIGHT\\n    }\\n\\n    // Representation of a (tree) node\\n    // A node contains a value and pointers (which are index in an array of other nodes).\\n    // By convention a node that has no (left,middle,right) children will point to index 0.\\n    struct Node {\\n        uint256 val;\\n        uint64 left; // Pointer (index) to the left child\\n        uint64 middle; // Pointer (index) to the middle child\\n        uint64 right; // Pointer (index) to the right child\\n    }\\n\\n    uint256 internal _rootValue;\\n    uint64 internal _numLeaves;\\n    uint8 internal _merkleTreeHeight;\\n\\n    mapping(uint256 => uint256) internal _flattenedFrontier;\\n\\n    /// @dev Create a records Merkle tree of the given height.\\n    /// @param merkleTreeHeight The height\\n    constructor(uint8 merkleTreeHeight) {\\n        _rootValue = 0;\\n        _numLeaves = 0;\\n        _merkleTreeHeight = merkleTreeHeight;\\n    }\\n\\n    /// @dev Is the given node a terminal node?\\n    /// @param node A node\\n    /// @return _ True if the node is terminal, false otherwise.\\n    function _isTerminal(Node memory node) private pure returns (bool) {\\n        return (node.left == 0) && (node.middle == 0) && (node.right == 0);\\n    }\\n\\n    /// @dev Is the given node null?\\n    /// @param node A node\\n    /// @return _ True if the node is NULL, false otherwise\\n    function _isNull(Node memory node) private pure returns (bool) {\\n        return (node.val == 0 && _isTerminal(node));\\n    }\\n\\n    /// @dev Create a new \\\"hole node\\\" at the given position in the\\n    /// tree. A cursor position can be obtained from an extant node or\\n    /// from a function that returns a position such as _buildTreeFromFrontier.\\n    /// @param cursor The index of the node in the array of nodes\\n    /// @param posSibling The position of the sibling i.e. (LEFT, MIDDLE or RIGHT)\\n    /// @return _ The new created node\\n    function _createHoleNode(uint64 cursor, Position posSibling)\\n        private\\n        pure\\n        returns (Node memory)\\n    {\\n        // Copy pasting these values to save gas\\n        // indexHoleNode = cursor - 3;\\n        // indexFirstSibling = cursor - 2;\\n        // indexSecondSibling = cursor - 1;\\n\\n        if (posSibling == Position.LEFT) {\\n            return Node(0, cursor - 3, cursor - 2, cursor - 1);\\n        } else if (posSibling == Position.MIDDLE) {\\n            return Node(0, cursor - 2, cursor - 3, cursor - 1);\\n        } else if (posSibling == Position.RIGHT) {\\n            return Node(0, cursor - 2, cursor - 1, cursor - 3);\\n        } else {\\n            revert(\\\"unreachable\\\");\\n        }\\n    }\\n\\n    /// @dev Create a Merkle tree from the given frontier.\\n    /// @param nodes The list of nodes to be filled or updated\\n    /// @return A cursor to the root node of the create tree\\n    function _buildTreeFromFrontier(Node[] memory nodes) internal view returns (uint64) {\\n        // Tree is empty\\n        if (_numLeaves == 0) {\\n            nodes[0] = Node(0, 0, 0, 0); // Empty node\\n            nodes[1] = Node(0, 0, 0, 0); // Root node\\n            return 1;\\n        }\\n\\n        // Tree is not empty\\n\\n        // Set the first node to the NULL node\\n        nodes[0] = Node(0, 0, 0, 0);\\n\\n        // Insert the leaf\\n        nodes[1] = Node(_flattenedFrontier[0], 0, 0, 0);\\n\\n        // Insert the siblings\\n        nodes[2] = Node(_flattenedFrontier[1], 0, 0, 0);\\n        nodes[3] = Node(_flattenedFrontier[2], 0, 0, 0);\\n\\n        // Compute the position of each node\\n        uint64 absolutePosition = _numLeaves - 1;\\n        uint8 localPosition = uint8(absolutePosition % 3);\\n\\n        // We process the nodes of the Merkle path\\n        uint64 cursor = 4;\\n        uint64 cursorFrontier = 3;\\n\\n        // Build the tree expect the root node\\n        while (cursor < 3 * _merkleTreeHeight + 1) {\\n            nodes[cursor] = _createHoleNode(cursor, Position(localPosition));\\n\\n            // Create the siblings of the \\\"hole node\\\". These siblings have no children\\n            nodes[cursor + 1] = Node(_flattenedFrontier[cursorFrontier], 0, 0, 0);\\n            nodes[cursor + 2] = Node(_flattenedFrontier[cursorFrontier + 1], 0, 0, 0);\\n\\n            // Move forward\\n            absolutePosition /= 3;\\n            localPosition = uint8(absolutePosition % 3);\\n\\n            cursor += 3;\\n            cursorFrontier += 2;\\n        }\\n\\n        // Add the root node\\n        nodes[cursor] = _createHoleNode(cursor, Position(localPosition));\\n        return cursor;\\n    }\\n\\n    /// @dev Compute the index of the next node when going down in the tree.\\n    /// @param nodes The list of nodes of the tree\\n    /// @param nodeIndex The index of the starting node\\n    /// @param pos The position for going down, i.e. LEFT, MIDDLE or RIGHT.\\n    /// @return The index of the next node\\n    function _nextNodeIndex(\\n        Node[] memory nodes,\\n        uint64 nodeIndex,\\n        Position pos\\n    ) private pure returns (uint64) {\\n        if (pos == Position.LEFT) {\\n            return nodes[nodeIndex].left;\\n        } else if (pos == Position.MIDDLE) {\\n            return nodes[nodeIndex].middle;\\n        } else if (pos == Position.RIGHT) {\\n            return nodes[nodeIndex].right;\\n        } else {\\n            revert(\\\"unreachable\\\");\\n        }\\n    }\\n\\n    /// @dev Update the child of a node based on the position (which child to select) and an index to the new child.\\n    /// @param node node for which we want to update the child\\n    /// @param newChildIndex index of the new child\\n    /// @param pos position of the child node relative to the node (i.e. LEFT, MIDDLE or RIGHT)\\n    function _updateChildNode(\\n        Node memory node,\\n        uint64 newChildIndex,\\n        Position pos\\n    ) private pure {\\n        // Update the node\\n        if (pos == Position.LEFT) {\\n            node.left = newChildIndex;\\n        } else if (pos == Position.MIDDLE) {\\n            node.middle = newChildIndex;\\n        } else if (pos == Position.RIGHT) {\\n            node.right = newChildIndex;\\n        }\\n    }\\n\\n    function _computeNodePos(uint64 absolutePos, uint64 branchIndex)\\n        private\\n        view\\n        returns (uint64, uint64)\\n    {\\n        uint64 localPos;\\n        uint64 divisor = uint64(3**(_merkleTreeHeight - branchIndex - 1));\\n\\n        localPos = absolutePos / divisor;\\n        absolutePos = absolutePos % divisor;\\n\\n        return (absolutePos, localPos);\\n    }\\n\\n    /// @notice Insert an element into the tree in the position num_leaves.\\n    /// @param nodes The array of nodes\\n    /// @param rootIndex The index of the root node\\n    /// @param maxIndex The index of the latest element inserted in the nodes array\\n    /// @param element The value of the element to insert into the tree\\n    /// @return updated the value of maxIndex\\n    function _pushElement(\\n        Node[] memory nodes,\\n        uint64 rootIndex,\\n        uint64 maxIndex,\\n        uint256 element\\n    ) private returns (uint64) {\\n        require(_numLeaves < 3**_merkleTreeHeight, \\\"The tree is full.\\\");\\n\\n        // Get the position of the leaf from the smart contract state\\n        uint64 leafPos = _numLeaves;\\n        uint64 branchIndex = 0;\\n        uint64 currentNodeIndex = rootIndex;\\n        uint64 previousNodeIndex = rootIndex;\\n\\n        // Go down inside the tree until finding the first terminal node.\\n        uint64 absolutePos = leafPos;\\n        uint64 localPos = 0;\\n        while (!_isNull(nodes[currentNodeIndex])) {\\n            (absolutePos, localPos) = _computeNodePos(absolutePos, branchIndex);\\n\\n            previousNodeIndex = currentNodeIndex;\\n            currentNodeIndex = _nextNodeIndex(nodes, currentNodeIndex, Position(localPos));\\n\\n            branchIndex += 1;\\n        }\\n\\n        // maxIndex tracks the index of the last element inserted in the tree\\n        uint64 newNodeIndex = maxIndex + 1;\\n\\n        // Create new nodes until completing the path one level above the leaf level\\n        // Always inserting to the left\\n\\n        // To compensate the extra increment at the end of the previous loop ,\\n        // except if the tree is reduced to a single root node.\\n        if (branchIndex > 0) {\\n            branchIndex -= 1;\\n        }\\n\\n        while (branchIndex < _merkleTreeHeight - 1) {\\n            nodes[newNodeIndex] = Node(0, 0, 0, 0);\\n            _updateChildNode(nodes[previousNodeIndex], newNodeIndex, Position(localPos));\\n\\n            // Prepare the next iteration of the loop\\n            previousNodeIndex = newNodeIndex;\\n            newNodeIndex += 1;\\n            branchIndex += 1;\\n            (absolutePos, localPos) = _computeNodePos(absolutePos, branchIndex);\\n        }\\n\\n        // The last node contains the leaf value (compute the hash)\\n        // Remember position is computed with the remainder\\n\\n        // Leaf node where the value is hash(0,_numLeaves,element)\\n        uint256 val = RescueLib.hash(0, _numLeaves, element);\\n        nodes[newNodeIndex] = Node(val, 0, 0, 0);\\n        _updateChildNode(nodes[previousNodeIndex], newNodeIndex, Position(localPos));\\n\\n        // Increment the number of leaves\\n        //\\n        // This operation is costly and happens in a loop. However, for now the\\n        // merkle tree is usually updated with a single new element. In this\\n        // case we would not save gas by moving the update of _numLeaves. The\\n        // gas cost is also likely negligible compared to the whole operation of\\n        // inserting an element.\\n        //\\n        // slither-disable-next-line costly-loop\\n        _numLeaves += 1;\\n\\n        // Return the new value of maxIndex\\n        return newNodeIndex;\\n    }\\n\\n    /// @dev Store the frontier.\\n    /// @param nodes The list of node of the tree\\n    /// @param rootIndex The index of the root node\\n    function _storeFrontier(Node[] memory nodes, uint64 rootIndex) private {\\n        uint64 frontierSize = 2 * _merkleTreeHeight + 1;\\n\\n        /// Collect the values from the root to the leaf but in reverse order\\n        uint64 currentNodeIndex = rootIndex;\\n        uint64 firstSiblingIndex = 0;\\n        uint64 secondSiblingIndex = 0;\\n        // Go down until the leaf\\n        for (uint256 i = 0; i < _merkleTreeHeight; i++) {\\n            // Pick the non-empty node that is most right\\n            Node memory currentNode = nodes[currentNodeIndex];\\n            if (!_isNull(nodes[currentNode.right])) {\\n                // Keep to the right\\n                currentNodeIndex = currentNode.right;\\n                firstSiblingIndex = currentNode.left;\\n                secondSiblingIndex = currentNode.middle;\\n            } else if (!_isNull(nodes[currentNode.middle])) {\\n                // Keep to the middle\\n                currentNodeIndex = currentNode.middle;\\n                firstSiblingIndex = currentNode.left;\\n                secondSiblingIndex = currentNode.right;\\n            } else {\\n                // Keep to the left\\n                currentNodeIndex = currentNode.left;\\n                firstSiblingIndex = currentNode.middle;\\n                secondSiblingIndex = currentNode.right;\\n            }\\n            uint256 secondSiblingPos = frontierSize - 1 - (2 * i);\\n            uint256 firstSiblingPos = secondSiblingPos - 1;\\n            _flattenedFrontier[secondSiblingPos] = nodes[secondSiblingIndex].val;\\n            _flattenedFrontier[firstSiblingPos] = nodes[firstSiblingIndex].val;\\n        }\\n        // currentNodeIndex points to the leaf\\n        _flattenedFrontier[0] = nodes[currentNodeIndex].val;\\n    }\\n\\n    /// @dev Update the state of the record merkle tree by inserting new elements.\\n    /// @param elements The list of elements to be appended to the current merkle tree described by the frontier.\\n    function updateRecordsMerkleTree(uint256[] memory elements) external onlyOwner {\\n        // The total number of nodes is bounded by 3*height+1 + 3*N*height = 3*(N+1)*height + 1\\n        // where N is the number of new records\\n        uint256 numElements = elements.length;\\n        Node[] memory nodes = new Node[](3 * (numElements + 1) * _merkleTreeHeight + 2);\\n\\n        /// Insert the new elements ///\\n\\n        // maxIndex tracks the index of the last element inserted in the tree\\n        uint64 rootIndex = _buildTreeFromFrontier(nodes);\\n        uint64 maxIndex = rootIndex;\\n        for (uint32 i = 0; i < elements.length; i++) {\\n            maxIndex = _pushElement(nodes, rootIndex, maxIndex, elements[i]);\\n        }\\n        //// Compute the root hash value ////\\n        _rootValue = _computeRootValueAndUpdateTree(nodes, rootIndex);\\n\\n        //// Store the frontier\\n        _storeFrontier(nodes, rootIndex);\\n    }\\n\\n    /// @notice Returns the root value of the Merkle tree.\\n    function getRootValue() external view returns (uint256) {\\n        return _rootValue;\\n    }\\n\\n    /// @notice Returns the height of the Merkle tree.\\n    function getHeight() external view returns (uint8) {\\n        return _merkleTreeHeight;\\n    }\\n\\n    /// @notice Returns the number of leaves of the Merkle tree.\\n    function getNumLeaves() external view returns (uint64) {\\n        return _numLeaves;\\n    }\\n\\n    /// @dev Update the tree by hashing the children of each node.\\n    /// @param nodes The tree. Note that the nodes are updated by this function.\\n    /// @param rootNodePos The index of the root node in the list of nodes.\\n    /// @return The value obtained at the root.\\n    function _computeRootValueAndUpdateTree(Node[] memory nodes, uint256 rootNodePos)\\n        private\\n        returns (uint256)\\n    {\\n        // If the root node has no children return its value\\n        Node memory rootNode = nodes[rootNodePos];\\n        if (_isTerminal(rootNode)) {\\n            return rootNode.val;\\n        } else {\\n            uint256 valLeft = _computeRootValueAndUpdateTree(nodes, rootNode.left);\\n            uint256 valMiddle = _computeRootValueAndUpdateTree(nodes, rootNode.middle);\\n            uint256 valRight = _computeRootValueAndUpdateTree(nodes, rootNode.right);\\n\\n            nodes[rootNode.left].val = valLeft;\\n            nodes[rootNode.middle].val = valMiddle;\\n            nodes[rootNode.right].val = valRight;\\n\\n            return RescueLib.hash(valLeft, valMiddle, valRight);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdf07a42805dc343f2a6552c8c531ef697244e648beb1fa6b33324421a168e268\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/RescueLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n//\\n// Copyright (c) 2022 Espresso Systems (espressosys.com)\\n// This file is part of the Configurable Asset Privacy for Ethereum (CAPE) library.\\n//\\n// This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\\n// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n// You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary RescueLib {\\n    /// The constants are obtained from the Sage script\\n    /// https://github.com/EspressoSystems/Marvellous/blob/fcd4c41672f485ac2f62526bc87a16789d4d0459/rescue254.sage\\n\\n    // These constants are no longer used, left here for readability.\\n    // uint256 private constant _N_ROUNDS = 12;\\n    // uint256 private constant _STATE_SIZE = 4;\\n    // uint256 private constant _SCHEDULED_KEY_SIZE = (2 * _N_ROUNDS + 1) * _STATE_SIZE;\\n    // uint256 private constant _ALPHA = 5;\\n\\n    // Obtained by running KeyScheduling([0,0,0,0]). See Algorithm 2 of AT specification document.\\n\\n    uint256 private constant _PRIME =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    uint256 private constant _ALPHA_INV =\\n        17510594297471420177797124596205820070838691520332827474958563349260646796493;\\n\\n    // MDS is hardcoded\\n    function _linearOp(\\n        uint256 s0,\\n        uint256 s1,\\n        uint256 s2,\\n        uint256 s3\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Matrix multiplication\\n        unchecked {\\n            return (\\n                mulmod(\\n                    21888242871839275222246405745257275088548364400416034343698204186575808479992,\\n                    s0,\\n                    _PRIME\\n                ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186575806058117,\\n                        s1,\\n                        _PRIME\\n                    ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186575491214367,\\n                        s2,\\n                        _PRIME\\n                    ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186535831058117,\\n                        s3,\\n                        _PRIME\\n                    ),\\n                mulmod(19500, s0, _PRIME) +\\n                    mulmod(3026375, s1, _PRIME) +\\n                    mulmod(393529500, s2, _PRIME) +\\n                    mulmod(49574560750, s3, _PRIME),\\n                mulmod(\\n                    21888242871839275222246405745257275088548364400416034343698204186575808491587,\\n                    s0,\\n                    _PRIME\\n                ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186575807886437,\\n                        s1,\\n                        _PRIME\\n                    ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186575729688812,\\n                        s2,\\n                        _PRIME\\n                    ) +\\n                    mulmod(\\n                        21888242871839275222246405745257275088548364400416034343698204186565891044437,\\n                        s3,\\n                        _PRIME\\n                    ),\\n                mulmod(156, s0, _PRIME) +\\n                    mulmod(20306, s1, _PRIME) +\\n                    mulmod(2558556, s2, _PRIME) +\\n                    mulmod(320327931, s3, _PRIME)\\n            );\\n        }\\n    }\\n\\n    function _expAlphaInv4Setup(uint256[6] memory scratch) private pure {\\n        assembly {\\n            let p := scratch\\n            mstore(p, 0x20) // Length of Base\\n            mstore(add(p, 0x20), 0x20) // Length of Exponent\\n            mstore(add(p, 0x40), 0x20) // Length of Modulus\\n            mstore(add(p, 0x80), _ALPHA_INV) // Exponent\\n            mstore(add(p, 0xa0), _PRIME) // Modulus\\n        }\\n    }\\n\\n    function _expAlphaInv4(\\n        uint256[6] memory scratch,\\n        uint256 s0,\\n        uint256 s1,\\n        uint256 s2,\\n        uint256 s3\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 o0,\\n            uint256 o1,\\n            uint256 o2,\\n            uint256 o3\\n        )\\n    {\\n        assembly {\\n            // define pointer\\n            let p := scratch\\n            let basep := add(p, 0x60)\\n            mstore(basep, s0) // Base\\n            // store data assembly-favouring ways\\n            pop(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, basep, 0x20))\\n            // data\\n            o0 := mload(basep)\\n            mstore(basep, s1) // Base\\n            pop(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, basep, 0x20))\\n            // data\\n            o1 := mload(basep)\\n            mstore(basep, s2) // Base\\n            pop(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, basep, 0x20))\\n            // data\\n            o2 := mload(basep)\\n            mstore(basep, s3) // Base\\n            pop(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, basep, 0x20))\\n            // data\\n            o3 := mload(basep)\\n        }\\n    }\\n\\n    // Computes the Rescue permutation on some input\\n    // Recall that the scheduled key is precomputed in our case\\n    // @param input input for the permutation\\n    // @return permutation output\\n    function perm(\\n        // slither-disable-next-line write-after-write\\n        uint256 s0,\\n        // slither-disable-next-line write-after-write\\n        uint256 s1,\\n        // slither-disable-next-line write-after-write\\n        uint256 s2,\\n        // slither-disable-next-line write-after-write\\n        uint256 s3\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // slither-disable-next-line uninitialized-local\\n        uint256[6] memory alphaInvScratch;\\n\\n        _expAlphaInv4Setup(alphaInvScratch);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 14613516837064033601098425266946467918409544647446217386229959902054563533267,\\n                s1 + 376600575581954944138907282479272751264978206975465380433764825531344567663,\\n                s2 + 7549886658634274343394883631367643327196152481472281919735617268044202589860,\\n                s3 + 3682071510138521345600424597536598375718773365536872232193107639375194756918\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                18657517374128716281071590782771170166993445602755371021955596036781411817786;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                7833794394096838639430144230563403530989402760602204539559270044687522640191;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                21303828694647266539931030987057572024333442749881970102454081226349775826204;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                10601447988834057856019990466870413629636256450824419416829818546423193802418;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 3394657260998945409283098835682964352503279447198495330506177586645995289229,\\n                s1 + 18437084083724939316390841967750487133622937044030373241106776324730657101302,\\n                s2 + 9281739916935170266925270432337475828741505406943764438550188362765269530037,\\n                s3 + 7363758719535652813463843693256839865026387361836644774317493432208443086206\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                307094088106440279963968943984309088038734274328527845883669678290790702381;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                20802277384865839022876847241719852837518994021170013346790603773477912819001;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                19754579269464973651593381036132218829220609572271224048608091445854164824042;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                3618840933841571232310395486452077846249117988789467996234635426899783130819;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 2604166168648013711791424714498680546427073388134923208733633668316805639713,\\n                s1 + 21355705619901626246699129842094174300693414345856149669339147704587730744579,\\n                s2 + 492957643799044929042114590851019953669919577182050726596188173945730031352,\\n                s3 + 8495959434717951575638107349559891417392372124707619959558593515759091841138\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                15608173629791582453867933160400609222904457931922627396107815347244961625587;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                16346164988481725869223011419855264063160651334419415042919928342589111681923;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                21085652277104054699752179865196164165969290053517659864117475352262716334100;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                20640310021063232205677193759981403045043444605175178332133134865746039279935;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 6015589261538006311719125697023069952804098656652050863009463360598997670240,\\n                s1 + 12498423882721726012743791752811798719201859023192663855805526312393108407357,\\n                s2 + 10785527781711732350693172404486938622378708235957779975342240483505724965040,\\n                s3 + 5563181134859229953817163002660048854420912281911747312557025480927280392569\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                4585980485870975597083581718044393941512074846925247225127276913719050121968;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                8135760428078872176830812746579993820254685977237403304445687861806698035222;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                4525715538433244696411192727226186804883202134636681498489663161593606654720;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                2537497100749435007113677475828631400227339157221711397900070636998427379023;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 6957758175844522415482704083077249782181516476067074624906502033584870962925,\\n                s1 + 17134288156316028142861248367413235848595762718317063354217292516610545487813,\\n                s2 + 20912428573104312239411321877435657586184425249645076131891636094671938892815,\\n                s3 + 16000236205755938926858829908701623009580043315308207671921283074116709575629\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                10226182617544046880850643054874064693998595520540061157646952229134207239372;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                18584346134948015676264599354709457865255277240606855245909703396343731224626;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                9263628039314899758000383385773954136696958567872461042004915206775147151562;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                21095966719856094705113273596585696209808876361583941931684481364905087347856;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 2671157351815122058649197205531097090514563992249109660044882868649840700911,\\n                s1 + 19371695134219415702961622134896564229962454573253508904477489696588594622079,\\n                s2 + 5458968308231210904289987830881528056037123818964633914555287871152343390175,\\n                s3 + 7336332584551233792026746889434554547883125466404119632794862500961953384162\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                10351436748086126474964482623536554036637945319698748519226181145454116702488;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                10588209357420186457766745724579739104572139534486480334142455690083813419064;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                14330277147584936710957102218096795520430543834717433464500965846826655802131;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                20752197679372238381408962682213349118865256502118746003818603260257076802028;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 19390446529582160674621825412345750405397926216690583196542690617266028463414,\\n                s1 + 4169994013656329171830126793466321040216273832271989491631696813297571003664,\\n                s2 + 3014817248268674641565961681956715664833306954478820029563459099892548946802,\\n                s3 + 14285412497877984113655094566695921704826935980354186365694472961163628072901\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                16224484149774307577146165975762490690838415946665379067259822320752729067513;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                5404416528124718330316441408560295270695591369912905197499507811036327404407;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                20127204244332635127213425090893250761286848618448128307344971109698523903374;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                14939477686176063572999014162186372798386193194442661892600584389296609365740;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 183740587182448242823071506013879595265109215202349952517434740768878294134,\\n                s1 + 15366166801397358994305040367078329374182896694582870542425225835844885654667,\\n                s2 + 10066796014802701613007252979619633540090232697942390802486559078446300507813,\\n                s3 + 4824035239925904398047276123907644574421550988870123756876333092498925242854\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                5526416022516734657935645023952329824887761902324086126076396040056459740202;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                18157816292703983306114736850721419851645159304249709756659476015594698876611;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                767446206481623130855439732549764381286210118638028499466788453347759203223;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                16303412231051555792435190427637047658258796056382698277687500021321460387129;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 15475465085113677237835653765189267963435264152924949727326000496982746660612,\\n                s1 + 14574823710073720047190393602502575509282844662732045439760066078137662816054,\\n                s2 + 13746490178929963947720756220409862158443939172096620003896874772477437733602,\\n                s3 + 13804898145881881347835367366352189037341704254740510664318597456840481739975\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                3523599105403569319090449327691358425990456728660349400211678603795116364226;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                8632053982708637954870974502506145434219829622278773822242070316888003350278;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                20293222318844554840191640739970825558851264905959070636369796127300969629060;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                7583204376683983181255811699503668584283525661852773339144064901897953897564;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 7562572155566079175343789986900217168516831778275127159068657756836798778249,\\n                s1 + 12689811910161401007144285031988539999455902164332232460061366402869461973371,\\n                s2 + 21878400680687418538050108788381481970431106443696421074205107984690362920637,\\n                s3 + 3428721187625124675258692786364137915132424621324969246210899039774126165479\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                2552744099402346352193097862110515290335034445517764751557635302899937367219;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                13706727374402840004346872704605212996406886221231239230397976011930486183550;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                19786308443934570499119114884492461847023732197118902978413499381102456961966;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                11767081169862697956461405434786280425108140215784390008330611807075539962898;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 1273319740931699377003430019539548781935202579355152343831464213279794249000,\\n                s1 + 20225620070386241931202098463018472034137960205721651875253423327929063224115,\\n                s2 + 13107884970924459680133954992354588464904218518440707039430314610799573960437,\\n                s3 + 10574066469653966216567896842413898230152427846140046825523989742590727910280\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                21386271527766270535632132320974945129946865648321206442664310421414128279311;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                15743262855527118149527268525857865250723531109306484598629175225221686341453;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                16251140915157602891864152518526119259367827194524273940185283798897653655734;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                5420158299017134702074915284768041702367316125403978919545323705661634647751;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            (s0, s1, s2, s3) = _expAlphaInv4(\\n                alphaInvScratch,\\n                s0 + 14555572526833606349832007897859411042036463045080050783981107823326880950231,\\n                s1 + 15234942318869557310939446038663331226792664588406507247341043508129993934298,\\n                s2 + 19560004467494472556570844694553210033340577742756929194362924850760034377042,\\n                s3 + 21851693551359717578445799046408060941161959589978077352548456186528047792150\\n            );\\n        }\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            uint256 tmp = s0 +\\n                19076469206110044175016166349949136119962165667268661130584159239385341119621;\\n            s0 = mulmod(tmp, tmp, _PRIME);\\n            s0 = mulmod(s0, s0, _PRIME);\\n            s0 = mulmod(s0, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s1 +\\n                19132104531774396501521959463346904008488403861940301898725725957519076019017;\\n            s1 = mulmod(tmp, tmp, _PRIME);\\n            s1 = mulmod(s1, s1, _PRIME);\\n            s1 = mulmod(s1, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s2 +\\n                6606159937109409334959297158878571243749055026127553188405933692223704734040;\\n            s2 = mulmod(tmp, tmp, _PRIME);\\n            s2 = mulmod(s2, s2, _PRIME);\\n            s2 = mulmod(s2, tmp, _PRIME);\\n        }\\n        unchecked {\\n            uint256 tmp = s3 +\\n                13442678592538344046772867528443594004918096722084104155946229264098946917042;\\n            s3 = mulmod(tmp, tmp, _PRIME);\\n            s3 = mulmod(s3, s3, _PRIME);\\n            s3 = mulmod(s3, tmp, _PRIME);\\n        }\\n\\n        (s0, s1, s2, s3) = _linearOp(s0, s1, s2, s3);\\n\\n        unchecked {\\n            return (\\n                s0 + 11975757366382164299373991853632416786161357061467425182041988114491638264212,\\n                s1 + 10571372363668414752587603575617060708758897046929321941050113299303675014148,\\n                s2 + 5405426474713644587066466463343175633538103521677501186003868914920014287031,\\n                s3 + 18665277628144856329335676361545218245401014824195451740181902217370165017984\\n            );\\n        }\\n    }\\n\\n    // Computes the hash of three field elements and returns a single element\\n    // In our case the rate is 3 and the capacity is 1\\n    // This hash function the one used in the Records Merkle tree.\\n    // @param a first element\\n    // @param b second element\\n    // @param c third element\\n    // @return the first element of the Rescue state\\n    function hash(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) public view returns (uint256 o) {\\n        (o, a, b, c) = perm(a % _PRIME, b % _PRIME, c % _PRIME, 0);\\n        o %= _PRIME;\\n    }\\n\\n    function checkBounded(uint256[15] memory inputs) internal pure {\\n        for (uint256 i = 0; i < inputs.length; ++i) {\\n            require(inputs[i] < _PRIME, \\\"inputs must be below _PRIME\\\");\\n        }\\n    }\\n\\n    // This function is external to ensure that the solidity compiler generates\\n    // a separate library contract. This is required to reduce the size of the\\n    // CAPE contract.\\n    function commit(uint256[15] memory inputs) external view returns (uint256) {\\n        checkBounded(inputs);\\n\\n        uint256 a;\\n        uint256 b;\\n        uint256 c;\\n        uint256 d;\\n\\n        for (uint256 i = 0; i < 5; i++) {\\n            unchecked {\\n                (a, b, c, d) = perm(\\n                    (a + inputs[3 * i + 0]) % _PRIME,\\n                    (b + inputs[3 * i + 1]) % _PRIME,\\n                    (c + inputs[3 * i + 2]) % _PRIME,\\n                    d\\n                );\\n\\n                (a, b, c, d) = (a % _PRIME, b % _PRIME, c % _PRIME, d % _PRIME);\\n            }\\n        }\\n\\n        return a;\\n    }\\n}\\n\",\"keccak256\":\"0x5d852913c47167b7e785dadec2913f3a468e3279af846ef0d52de3ce106dd274\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161193038038061193083398101604081905261002f916100b8565b61003833610068565b60006001556002805460ff90921668010000000000000000026001600160481b03199092169190911790556100e2565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000602082840312156100ca57600080fd5b815160ff811681146100db57600080fd5b9392505050565b61183f806100f16000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063715018a61161005b578063715018a6146100cc5780638da5cb5b146100d4578063927d52ab146100ef578063f2fde38b1461010a57600080fd5b806319efb11d14610082578063330ee6a7146100a65780636444c8d1146100bb575b600080fd5b600254600160401b900460ff1660405160ff90911681526020015b60405180910390f35b6100b96100b4366004611418565b61011d565b005b60015460405190815260200161009d565b6100b96102ac565b6000546040516001600160a01b03909116815260200161009d565b6002546040516001600160401b03909116815260200161009d565b6100b96101183660046114d5565b610312565b6000546001600160a01b0316331461017c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b8051600254600090600160401b900460ff16610199836001611514565b6101a490600361152c565b6101ae919061152c565b6101b9906002611514565b6001600160401b038111156101d0576101d0611402565b60405190808252806020026020018201604052801561022257816020015b6040805160808101825260008082526020808301829052928201819052606082015282526000199092019101816101ee5790505b5090506000610230826103f4565b90508060005b85518163ffffffff16101561028457610270848484898563ffffffff16815181106102635761026361154b565b6020026020010151610856565b91508061027c81611561565b915050610236565b5061029883836001600160401b0316610c1c565b6001556102a58383610dbd565b5050505050565b6000546001600160a01b031633146103065760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610173565b6103106000610fe2565b565b6000546001600160a01b0316331461036c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610173565b6001600160a01b0381166103e85760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610173565b6103f181610fe2565b50565b6002546000906001600160401b031681036104b057604080516080810182526000808252602082018190529181018290526060810182905283519091849161043e5761043e61154b565b602002602001018190525060405180608001604052806000815260200160006001600160401b0316815260200160006001600160401b0316815260200160006001600160401b03168152508260018151811061049c5761049c61154b565b602002602001018190525060019050919050565b60408051608081018252600080825260208201819052918101829052606081018290528351909184916104e5576104e561154b565b602090810291909101810191909152604080516080810182526000808052600384527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff54825292810183905290810182905260608101919091528251839060019081106105545761055461154b565b6020908102919091018101919091526040805160808101825260016000908152600384527fa15bc60c955c405d20d9149c709e2460f1c2d9a497496a7f46004d1772c3054c54825292810183905290810182905260608101919091528251839060029081106105c5576105c561154b565b60200260200101819052506040518060800160405280600360006002815260200190815260200160002054815260200160006001600160401b0316815260200160006001600160401b0316815260200160006001600160401b0316815250826003815181106106365761063661154b565b602090810291909101015260025460009061065c906001906001600160401b0316611584565b9050600061066b6003836115c2565b9050600460035b60025461068a90600160401b900460ff1660036115e8565b610695906001611611565b60ff16826001600160401b0316101561080e576106c6828460ff1660028111156106c1576106c1611636565b61104a565b86836001600160401b0316815181106106e1576106e161154b565b602090810291909101810191909152604080516080810182526001600160401b03841660009081526003845282812054825292810183905290810182905260608101919091528661073384600161164c565b6001600160401b03168151811061074c5761074c61154b565b6020026020010181905250604051806080016040528060036000846001610773919061164c565b6001600160401b03168152602080820192909252604090810160009081205484529183018290528201819052606090910152866107b184600261164c565b6001600160401b0316815181106107ca576107ca61154b565b60209081029190910101526107e0600385611677565b93506107ed6003856115c2565b92506107fa60038361164c565b915061080760028261164c565b9050610672565b610827828460ff1660028111156106c1576106c1611636565b86836001600160401b0316815181106108425761084261154b565b602090810291909101015250949350505050565b60025460009061087190600160401b900460ff166003611779565b6002546001600160401b0316106108ca5760405162461bcd60e51b815260206004820152601160248201527f54686520747265652069732066756c6c2e0000000000000000000000000000006044820152606401610173565b6002546001600160401b03166000858083835b6109088b856001600160401b0316815181106108fb576108fb61154b565b60200260200101516111eb565b610957576109168286611201565b85945090925090506109438b846001600160401b038416600281111561093e5761093e611636565b611260565b935061095060018661164c565b94506108dd565b60006109648a600161164c565b90506001600160401b0386161561098357610980600187611584565b95505b60025461099c90600190600160401b900460ff16611788565b60ff16866001600160401b03161015610a8d5760405180608001604052806000815260200160006001600160401b0316815260200160006001600160401b0316815260200160006001600160401b03168152508c826001600160401b031681518110610a0a57610a0a61154b565b6020026020010181905250610a5c8c856001600160401b031681518110610a3357610a3361154b565b602002602001015182846001600160401b03166002811115610a5757610a57611636565b611339565b925082610a6a60018261164c565b9050610a7760018761164c565b9550610a838387611201565b9093509150610983565b600254604051631c0b758d60e31b81526000600482018190526001600160401b039092166024820152604481018b905273D7Cc25389f8ea6C9E30Ea2c5c9fB681Fb898C8399063e05bac6890606401602060405180830381865af4158015610af9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1d91906117ab565b9050604051806080016040528082815260200160006001600160401b0316815260200160006001600160401b0316815260200160006001600160401b03168152508d836001600160401b031681518110610b7957610b7961154b565b6020026020010181905250610bc68d866001600160401b031681518110610ba257610ba261154b565b602002602001015183856001600160401b03166002811115610a5757610a57611636565b6002805460019190600090610be59084906001600160401b031661164c565b92506101000a8154816001600160401b0302191690836001600160401b031602179055508198505050505050505050949350505050565b600080838381518110610c3157610c3161154b565b60200260200101519050610c44816113bf565b15610c5157519050610db7565b6000610c6a8583602001516001600160401b0316610c1c565b90506000610c858684604001516001600160401b0316610c1c565b90506000610ca08785606001516001600160401b0316610c1c565b9050828785602001516001600160401b031681518110610cc257610cc261154b565b60200260200101516000018181525050818785604001516001600160401b031681518110610cf257610cf261154b565b60200260200101516000018181525050808785606001516001600160401b031681518110610d2257610d2261154b565b602090810291909101015152604051631c0b758d60e31b815260048101849052602481018390526044810182905273D7Cc25389f8ea6C9E30Ea2c5c9fB681Fb898C8399063e05bac6890606401602060405180830381865af4158015610d8c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610db091906117ab565b9450505050505b92915050565b60028054600091610dd891600160401b900460ff16906115e8565b610de3906001611611565b60ff16905081600080805b600254600160401b900460ff16811015610f8657600087856001600160401b031681518110610e1f57610e1f61154b565b60200260200101519050610e4b8882606001516001600160401b0316815181106108fb576108fb61154b565b610e6957806060015194508060200151935080604001519250610ebf565b610e8b8882604001516001600160401b0316815181106108fb576108fb61154b565b610ea957806040015194508060200151935080606001519250610ebf565b8060200151945080604001519350806060015192505b6000610ecc83600261152c565b610ed7600189611584565b6001600160401b0316610eea91906117c4565b90506000610ef96001836117c4565b905089856001600160401b031681518110610f1657610f1661154b565b602002602001015160000151600360008481526020019081526020016000208190555089866001600160401b031681518110610f5457610f5461154b565b602090810291909101810151516000928352600390915260409091205550819050610f7e816117db565b915050610dee565b5085836001600160401b031681518110610fa257610fa261154b565b602090810291909101810151516000805260039091527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff55505050505050565b600080546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60408051608081018252600080825260208201819052918101829052606081018290529082600281111561108057611080611636565b036110e8576040518060800160405280600081526020016003856110a49190611584565b6001600160401b031681526020016110bd600286611584565b6001600160401b031681526020016110d6600186611584565b6001600160401b031690529050610db7565b60018260028111156110fc576110fc611636565b03611139576040518060800160405280600081526020016002856111209190611584565b6001600160401b031681526020016110bd600386611584565b600282600281111561114d5761114d611636565b036111a3576040518060800160405280600081526020016002856111719190611584565b6001600160401b0316815260200161118a600186611584565b6001600160401b031681526020016110d6600386611584565b60405162461bcd60e51b815260206004820152600b60248201527f756e726561636861626c650000000000000000000000000000000000000000006044820152606401610173565b8051600090158015610db75750610db7826113bf565b600080600080600185600260089054906101000a900460ff1660ff166112279190611584565b6112319190611584565b61123c9060036117f4565b90506112488187611677565b915061125481876115c2565b96919550909350505050565b60008082600281111561127557611275611636565b036112a85783836001600160401b0316815181106112955761129561154b565b6020026020010151602001519050611332565b60018260028111156112bc576112bc611636565b036112ef5783836001600160401b0316815181106112dc576112dc61154b565b6020026020010151604001519050611332565b600282600281111561130357611303611636565b036111a35783836001600160401b0316815181106113235761132361154b565b60200260200101516060015190505b9392505050565b600081600281111561134d5761134d611636565b0361136557506001600160401b031660209190910152565b600181600281111561137957611379611636565b0361139157506001600160401b031660409190910152565b60028160028111156113a5576113a5611636565b036113ba576001600160401b03821660608401525b505050565b600081602001516001600160401b031660001480156113e9575060408201516001600160401b0316155b8015610db7575050606001516001600160401b03161590565b634e487b7160e01b600052604160045260246000fd5b6000602080838503121561142b57600080fd5b82356001600160401b038082111561144257600080fd5b818501915085601f83011261145657600080fd5b81358181111561146857611468611402565b8060051b604051601f19603f8301168101818110858211171561148d5761148d611402565b6040529182528482019250838101850191888311156114ab57600080fd5b938501935b828510156114c9578435845293850193928501926114b0565b98975050505050505050565b6000602082840312156114e757600080fd5b81356001600160a01b038116811461133257600080fd5b634e487b7160e01b600052601160045260246000fd5b60008219821115611527576115276114fe565b500190565b6000816000190483118215151615611546576115466114fe565b500290565b634e487b7160e01b600052603260045260246000fd5b600063ffffffff80831681810361157a5761157a6114fe565b6001019392505050565b60006001600160401b03838116908316818110156115a4576115a46114fe565b039392505050565b634e487b7160e01b600052601260045260246000fd5b60006001600160401b03808416806115dc576115dc6115ac565b92169190910692915050565b600060ff821660ff84168160ff0481118215151615611609576116096114fe565b029392505050565b600060ff821660ff84168060ff0382111561162e5761162e6114fe565b019392505050565b634e487b7160e01b600052602160045260246000fd5b60006001600160401b0380831681851680830382111561166e5761166e6114fe565b01949350505050565b60006001600160401b0380841680611691576116916115ac565b92169190910492915050565b600181815b808511156116d85781600019048211156116be576116be6114fe565b808516156116cb57918102915b93841c93908002906116a2565b509250929050565b6000826116ef57506001610db7565b816116fc57506000610db7565b8160018114611712576002811461171c57611738565b6001915050610db7565b60ff84111561172d5761172d6114fe565b50506001821b610db7565b5060208310610133831016604e8410600b841016171561175b575081810a610db7565b611765838361169d565b8060001904821115611609576116096114fe565b600061133260ff8416836116e0565b600060ff821660ff8416808210156117a2576117a26114fe565b90039392505050565b6000602082840312156117bd57600080fd5b5051919050565b6000828210156117d6576117d66114fe565b500390565b6000600182016117ed576117ed6114fe565b5060010190565b60006113326001600160401b038416836116e056fea2646970667358221220dadafd98d7aaeed8045089408beb8396497221d819acc51c010796abc5d5d35e64736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063715018a61161005b578063715018a6146100cc5780638da5cb5b146100d4578063927d52ab146100ef578063f2fde38b1461010a57600080fd5b806319efb11d14610082578063330ee6a7146100a65780636444c8d1146100bb575b600080fd5b600254600160401b900460ff1660405160ff90911681526020015b60405180910390f35b6100b96100b4366004611418565b61011d565b005b60015460405190815260200161009d565b6100b96102ac565b6000546040516001600160a01b03909116815260200161009d565b6002546040516001600160401b03909116815260200161009d565b6100b96101183660046114d5565b610312565b6000546001600160a01b0316331461017c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b8051600254600090600160401b900460ff16610199836001611514565b6101a490600361152c565b6101ae919061152c565b6101b9906002611514565b6001600160401b038111156101d0576101d0611402565b60405190808252806020026020018201604052801561022257816020015b6040805160808101825260008082526020808301829052928201819052606082015282526000199092019101816101ee5790505b5090506000610230826103f4565b90508060005b85518163ffffffff16101561028457610270848484898563ffffffff16815181106102635761026361154b565b6020026020010151610856565b91508061027c81611561565b915050610236565b5061029883836001600160401b0316610c1c565b6001556102a58383610dbd565b5050505050565b6000546001600160a01b031633146103065760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610173565b6103106000610fe2565b565b6000546001600160a01b0316331461036c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610173565b6001600160a01b0381166103e85760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610173565b6103f181610fe2565b50565b6002546000906001600160401b031681036104b057604080516080810182526000808252602082018190529181018290526060810182905283519091849161043e5761043e61154b565b602002602001018190525060405180608001604052806000815260200160006001600160401b0316815260200160006001600160401b0316815260200160006001600160401b03168152508260018151811061049c5761049c61154b565b602002602001018190525060019050919050565b60408051608081018252600080825260208201819052918101829052606081018290528351909184916104e5576104e561154b565b602090810291909101810191909152604080516080810182526000808052600384527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff54825292810183905290810182905260608101919091528251839060019081106105545761055461154b565b6020908102919091018101919091526040805160808101825260016000908152600384527fa15bc60c955c405d20d9149c709e2460f1c2d9a497496a7f46004d1772c3054c54825292810183905290810182905260608101919091528251839060029081106105c5576105c561154b565b60200260200101819052506040518060800160405280600360006002815260200190815260200160002054815260200160006001600160401b0316815260200160006001600160401b0316815260200160006001600160401b0316815250826003815181106106365761063661154b565b602090810291909101015260025460009061065c906001906001600160401b0316611584565b9050600061066b6003836115c2565b9050600460035b60025461068a90600160401b900460ff1660036115e8565b610695906001611611565b60ff16826001600160401b0316101561080e576106c6828460ff1660028111156106c1576106c1611636565b61104a565b86836001600160401b0316815181106106e1576106e161154b565b602090810291909101810191909152604080516080810182526001600160401b03841660009081526003845282812054825292810183905290810182905260608101919091528661073384600161164c565b6001600160401b03168151811061074c5761074c61154b565b6020026020010181905250604051806080016040528060036000846001610773919061164c565b6001600160401b03168152602080820192909252604090810160009081205484529183018290528201819052606090910152866107b184600261164c565b6001600160401b0316815181106107ca576107ca61154b565b60209081029190910101526107e0600385611677565b93506107ed6003856115c2565b92506107fa60038361164c565b915061080760028261164c565b9050610672565b610827828460ff1660028111156106c1576106c1611636565b86836001600160401b0316815181106108425761084261154b565b602090810291909101015250949350505050565b60025460009061087190600160401b900460ff166003611779565b6002546001600160401b0316106108ca5760405162461bcd60e51b815260206004820152601160248201527f54686520747265652069732066756c6c2e0000000000000000000000000000006044820152606401610173565b6002546001600160401b03166000858083835b6109088b856001600160401b0316815181106108fb576108fb61154b565b60200260200101516111eb565b610957576109168286611201565b85945090925090506109438b846001600160401b038416600281111561093e5761093e611636565b611260565b935061095060018661164c565b94506108dd565b60006109648a600161164c565b90506001600160401b0386161561098357610980600187611584565b95505b60025461099c90600190600160401b900460ff16611788565b60ff16866001600160401b03161015610a8d5760405180608001604052806000815260200160006001600160401b0316815260200160006001600160401b0316815260200160006001600160401b03168152508c826001600160401b031681518110610a0a57610a0a61154b565b6020026020010181905250610a5c8c856001600160401b031681518110610a3357610a3361154b565b602002602001015182846001600160401b03166002811115610a5757610a57611636565b611339565b925082610a6a60018261164c565b9050610a7760018761164c565b9550610a838387611201565b9093509150610983565b600254604051631c0b758d60e31b81526000600482018190526001600160401b039092166024820152604481018b905273__$2783a64b147d5f689049cabc192a316d9d$__9063e05bac6890606401602060405180830381865af4158015610af9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1d91906117ab565b9050604051806080016040528082815260200160006001600160401b0316815260200160006001600160401b0316815260200160006001600160401b03168152508d836001600160401b031681518110610b7957610b7961154b565b6020026020010181905250610bc68d866001600160401b031681518110610ba257610ba261154b565b602002602001015183856001600160401b03166002811115610a5757610a57611636565b6002805460019190600090610be59084906001600160401b031661164c565b92506101000a8154816001600160401b0302191690836001600160401b031602179055508198505050505050505050949350505050565b600080838381518110610c3157610c3161154b565b60200260200101519050610c44816113bf565b15610c5157519050610db7565b6000610c6a8583602001516001600160401b0316610c1c565b90506000610c858684604001516001600160401b0316610c1c565b90506000610ca08785606001516001600160401b0316610c1c565b9050828785602001516001600160401b031681518110610cc257610cc261154b565b60200260200101516000018181525050818785604001516001600160401b031681518110610cf257610cf261154b565b60200260200101516000018181525050808785606001516001600160401b031681518110610d2257610d2261154b565b602090810291909101015152604051631c0b758d60e31b815260048101849052602481018390526044810182905273__$2783a64b147d5f689049cabc192a316d9d$__9063e05bac6890606401602060405180830381865af4158015610d8c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610db091906117ab565b9450505050505b92915050565b60028054600091610dd891600160401b900460ff16906115e8565b610de3906001611611565b60ff16905081600080805b600254600160401b900460ff16811015610f8657600087856001600160401b031681518110610e1f57610e1f61154b565b60200260200101519050610e4b8882606001516001600160401b0316815181106108fb576108fb61154b565b610e6957806060015194508060200151935080604001519250610ebf565b610e8b8882604001516001600160401b0316815181106108fb576108fb61154b565b610ea957806040015194508060200151935080606001519250610ebf565b8060200151945080604001519350806060015192505b6000610ecc83600261152c565b610ed7600189611584565b6001600160401b0316610eea91906117c4565b90506000610ef96001836117c4565b905089856001600160401b031681518110610f1657610f1661154b565b602002602001015160000151600360008481526020019081526020016000208190555089866001600160401b031681518110610f5457610f5461154b565b602090810291909101810151516000928352600390915260409091205550819050610f7e816117db565b915050610dee565b5085836001600160401b031681518110610fa257610fa261154b565b602090810291909101810151516000805260039091527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff55505050505050565b600080546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60408051608081018252600080825260208201819052918101829052606081018290529082600281111561108057611080611636565b036110e8576040518060800160405280600081526020016003856110a49190611584565b6001600160401b031681526020016110bd600286611584565b6001600160401b031681526020016110d6600186611584565b6001600160401b031690529050610db7565b60018260028111156110fc576110fc611636565b03611139576040518060800160405280600081526020016002856111209190611584565b6001600160401b031681526020016110bd600386611584565b600282600281111561114d5761114d611636565b036111a3576040518060800160405280600081526020016002856111719190611584565b6001600160401b0316815260200161118a600186611584565b6001600160401b031681526020016110d6600386611584565b60405162461bcd60e51b815260206004820152600b60248201527f756e726561636861626c650000000000000000000000000000000000000000006044820152606401610173565b8051600090158015610db75750610db7826113bf565b600080600080600185600260089054906101000a900460ff1660ff166112279190611584565b6112319190611584565b61123c9060036117f4565b90506112488187611677565b915061125481876115c2565b96919550909350505050565b60008082600281111561127557611275611636565b036112a85783836001600160401b0316815181106112955761129561154b565b6020026020010151602001519050611332565b60018260028111156112bc576112bc611636565b036112ef5783836001600160401b0316815181106112dc576112dc61154b565b6020026020010151604001519050611332565b600282600281111561130357611303611636565b036111a35783836001600160401b0316815181106113235761132361154b565b60200260200101516060015190505b9392505050565b600081600281111561134d5761134d611636565b0361136557506001600160401b031660209190910152565b600181600281111561137957611379611636565b0361139157506001600160401b031660409190910152565b60028160028111156113a5576113a5611636565b036113ba576001600160401b03821660608401525b505050565b600081602001516001600160401b031660001480156113e9575060408201516001600160401b0316155b8015610db7575050606001516001600160401b03161590565b634e487b7160e01b600052604160045260246000fd5b6000602080838503121561142b57600080fd5b82356001600160401b038082111561144257600080fd5b818501915085601f83011261145657600080fd5b81358181111561146857611468611402565b8060051b604051601f19603f8301168101818110858211171561148d5761148d611402565b6040529182528482019250838101850191888311156114ab57600080fd5b938501935b828510156114c9578435845293850193928501926114b0565b98975050505050505050565b6000602082840312156114e757600080fd5b81356001600160a01b038116811461133257600080fd5b634e487b7160e01b600052601160045260246000fd5b60008219821115611527576115276114fe565b500190565b6000816000190483118215151615611546576115466114fe565b500290565b634e487b7160e01b600052603260045260246000fd5b600063ffffffff80831681810361157a5761157a6114fe565b6001019392505050565b60006001600160401b03838116908316818110156115a4576115a46114fe565b039392505050565b634e487b7160e01b600052601260045260246000fd5b60006001600160401b03808416806115dc576115dc6115ac565b92169190910692915050565b600060ff821660ff84168160ff0481118215151615611609576116096114fe565b029392505050565b600060ff821660ff84168060ff0382111561162e5761162e6114fe565b019392505050565b634e487b7160e01b600052602160045260246000fd5b60006001600160401b0380831681851680830382111561166e5761166e6114fe565b01949350505050565b60006001600160401b0380841680611691576116916115ac565b92169190910492915050565b600181815b808511156116d85781600019048211156116be576116be6114fe565b808516156116cb57918102915b93841c93908002906116a2565b509250929050565b6000826116ef57506001610db7565b816116fc57506000610db7565b8160018114611712576002811461171c57611738565b6001915050610db7565b60ff84111561172d5761172d6114fe565b50506001821b610db7565b5060208310610133831016604e8410600b841016171561175b575081810a610db7565b611765838361169d565b8060001904821115611609576116096114fe565b600061133260ff8416836116e0565b600060ff821660ff8416808210156117a2576117a26114fe565b90039392505050565b6000602082840312156117bd57600080fd5b5051919050565b6000828210156117d6576117d66114fe565b500390565b6000600182016117ed576117ed6114fe565b5060010190565b60006113326001600160401b038416836116e056fea2646970667358221220dadafd98d7aaeed8045089408beb8396497221d819acc51c010796abc5d5d35e64736f6c634300080d0033",
  "libraries": {
    "RescueLib": "0xD7Cc25389f8ea6C9E30Ea2c5c9fB681Fb898C839"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Create a records Merkle tree of the given height.",
        "params": {
          "merkleTreeHeight": "The height"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "updateRecordsMerkleTree(uint256[])": {
        "details": "Update the state of the record merkle tree by inserting new elements.",
        "params": {
          "elements": "The list of elements to be appended to the current merkle tree described by the frontier."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getHeight()": {
        "notice": "Returns the height of the Merkle tree."
      },
      "getNumLeaves()": {
        "notice": "Returns the number of leaves of the Merkle tree."
      },
      "getRootValue()": {
        "notice": "Returns the root value of the Merkle tree."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7,
        "contract": "contracts/RecordsMerkleTree.sol:RecordsMerkleTree",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3824,
        "contract": "contracts/RecordsMerkleTree.sol:RecordsMerkleTree",
        "label": "_rootValue",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 3826,
        "contract": "contracts/RecordsMerkleTree.sol:RecordsMerkleTree",
        "label": "_numLeaves",
        "offset": 0,
        "slot": "2",
        "type": "t_uint64"
      },
      {
        "astId": 3828,
        "contract": "contracts/RecordsMerkleTree.sol:RecordsMerkleTree",
        "label": "_merkleTreeHeight",
        "offset": 8,
        "slot": "2",
        "type": "t_uint8"
      },
      {
        "astId": 3832,
        "contract": "contracts/RecordsMerkleTree.sol:RecordsMerkleTree",
        "label": "_flattenedFrontier",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}